{"source":"/*\n@module javascript\n@class Boolean\n\n#Summary\nThe Boolean object is an object wrapper for a boolean value.\n\n#Constructor\n\tnew Boolean(value)\n\n#Description\nThe value passed as the first parameter is converted to a boolean value, if necessary. If value is omitted or is 0, -0, null, false, NaN, undefined, or the empty string (\"\"), the object has an initial value of false. All other values, including any object or the string \"false\", create an object with an initial value of true.\n\nDo not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.\n\nAny object whose value is not undefined or null, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement. For example, the condition in the following if statement evaluates to true:\n\n\tx = new Boolean(false);\n\tif (x) {\n\t  // . . . this code is executed\n\t}\n\tThis behavior does not apply to Boolean primitives. For example, the condition in the following if statement evaluates to false:\n\n\tx = false;\n\tif (x) {\n\t  // . . . this code is not executed\n\t}\nDo not use a Boolean object to convert a non-boolean value to a boolean value. Instead, use Boolean as a function to perform this task:\n\n\tx = Boolean(expression);     // preferred\n\tx = new Boolean(expression); // don't use\n\tIf you specify any object, including a Boolean object whose value is false, as the initial value of a Boolean object, the new Boolean object has a value of true.\n\n\tmyFalse = new Boolean(false);   // initial value of false\n\tg = new Boolean(myFalse);       // initial value of true\n\tmyString = new String(\"Hello\"); // string object\n\ts = new Boolean(myString);      // initial value of true\n\tDo not use a Boolean object in place of a Boolean primitive.\n\n#Properties\nFor properties available on Boolean instances, see Properties of Boolean instances.\n\nBoolean.length\nLength property whose value is 1.\nBoolean.prototype\nRepresents the prototype for the Boolean constructor.\n#Properties inherited from Function:\narity, caller, constructor, length, name\n##Methods\nFor methods available on Boolean instances, see Methods of Boolean instances.\n\nThe global Boolean object contains no methods of its own, however, it does inherit some methods through the prototype chain:\n\n#Methods inherited from Function:\napply, call, toSource, toString\n\n#Boolean instances\nAll Boolean instances inherit from Boolean.prototype. As with all constructors, the prototype object dictates instances' inherited properties and methods.\n\n#Properties\n\nBoolean.prototype.constructor\nReturns the function that created an instance's prototype. This is the Boolean function by default.\nProperties inherited from Object:\n__parent__, __proto__\n#Methods\n\nBoolean.prototype.toSource() \nReturns a string containing the source of the Boolean object; you can use this string to create an equivalent object. Overrides the Object.prototype.toSource() method.\nBoolean.prototype.toString()\nReturns a string of either \"true\" or \"false\" depending upon the value of the object. Overrides the Object.prototype.toString() method.\nBoolean.prototype.valueOf()\nReturns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.\n\n\n#Examples\nCreating Boolean objects with an initial value of false\n\n\tvar bNoParam = new Boolean();\n\tvar bZero = new Boolean(0);\n\tvar bNull = new Boolean(null);\n\tvar bEmptyString = new Boolean(\"\");\n\tvar bfalse = new Boolean(false);\n\tCreating Boolean objects with an initial value of true\n\n\tvar btrue = new Boolean(true);\n\tvar btrueString = new Boolean(\"true\");\n\tvar bfalseString = new Boolean(\"false\");\n\tvar bSuLin = new Boolean(\"Su Lin\");\n\n\n*/\n\n\n/*\n@method valueOf\n#Summary\nThe valueOf() method returns the primitive value of a Boolean object.\n\n#Syntax\n\tbool.valueOf()\n\n#Description\nThe valueOf method of Boolean returns the primitive value of a Boolean object or literal Boolean as a Boolean data type.\n\nThis method is usually called internally by JavaScript and not explicitly in code.\n\n#Examples\n##Example: Using valueOf\n\n\tx = new Boolean();\n\tmyVar = x.valueOf()      // assigns false to myVar\n*/\n\n/*\n@module javascript\n@class Error\n\n#Summary\nThe Error constructor creates an error object. Instances of Error objects are thrown when runtime errors occur. The Error object can also be used as a base objects for user-defined exceptions. See below for standard built-in error types.\n\n#Syntax\n\tnew Error([message[, fileName[,lineNumber]]])\n#Description\nRuntime errors result in new Error objects being created and thrown.\n\nThis page documents the use of the Error object itself and its use as a constructor function. For a list of properties and methods inherited by Error instances, see Error.prototype.\n\n#Error types\n\nBesides the generic Error constructor, there are six other core error constructors in JavaScript. For client-side exceptions, see Exception Handling Statements.\n\n\tEvalError\n\tCreates an instance representing an error that occurs regarding the global function eval().\n\tInternalError \n\tCreates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. \"too much recursion\".\n\tRangeError\n\tCreates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.\n\tReferenceError\n\tCreates an instance representing an error that occurs when de-referencing an invalid reference.\n\tSyntaxError\n\tCreates an instance representing a syntax error that occurs while parsing code in eval().\n\tTypeError\n\tCreates an instance representing an error that occurs when a variable or parameter is not of a valid type.\n\tURIError\n\tCreates an instance representing an error that occurs when encodeURI() or decodeURl() are passed invalid parameters.\n\n#Properties\nError.prototype\nAllows the addition of properties to Error instances.\n#Methods\nThe global Error object contains no methods of its own, however, it does inherit some methods through the prototype chain.\n\n#Error instances\nAll Error instances and instances of non-generic errors inherit from Error.prototype. As with all constructor functions, you can use the prototype of the constructor to add properties or methods to all instances created with that constructor.\n\n#Properties\n\n##Standard properties\n\nError.prototype.constructor\nSpecifies the function that created an instance's prototype.\n\tError.prototype.message\n\tError message.\n\tError.prototype.name\n\tError name.\n\n\n#Vendor-specific extensions\n\n##Non-standard\nThis feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.\n##Microsoft\n\n\tError.prototype.description\n\tError description. Similar to message.\n\tError.prototype.number\n\tError number.\n##Mozilla\n\n\tError.prototype.fileName\n\tPath to file that raised this error.\n\tError.prototype.lineNumber\n\tLine number in file that raised this error.\n\tError.prototype.columnNumber\n\tColumn number in line that raised this error.\n\tError.prototype.stack\n\tStack trace.\n\n#Examples\n##Example: Throwing a generic error\n\nUsually you create an Error object with the intention of raising it using the throw keyword. You can handle the error using the try...catch construct:\n\n\ttry {\n\t  throw new Error(\"Whoops!\");\n\t} catch (e) {\n\t  alert(e.name + \": \" + e.message);\n\t}\n\tExample: Handling a specific error\n\n\tYou can choose to handle only specific error types by testing the error type with the error's constructor property or, if you're writing for modern JavaScript engines, instanceof keyword:\n\n\ttry {\n\t  foo.bar();\n\t} catch (e) {\n\t  if (e instanceof EvalError) {\n\t    alert(e.name + \": \" + e.message);\n\t  } else if (e instanceof RangeError) {\n\t    alert(e.name + \": \" + e.message);\n\t  }\n\t  // ... etc\n\t}\n##Custom Error Types\n\nYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. The common way to do this is demonstrated below.\n\nNote that the thrown MyError will report incorrect lineNumber and fileName at least in Firefox.\nSee also the \"What's a good way to extend Error in JavaScript?\" discussion on Stackoverflow.\n\n\t// Create a new object, that prototypally inherits from the Error constructor.\n\tfunction MyError(message) {\n\t  this.name = \"MyError\";\n\t  this.message = message || \"Default Message\";\n\t}\n\tMyError.prototype = new Error();\n\tMyError.prototype.constructor = MyError;\n\n\ttry {\n\t  throw new MyError();\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"Default Message\"\n\t}\n\n\ttry {\n\t  throw new MyError(\"custom message\");\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"custom message\"\n\t}\n\n*/\n\n/*\n\n@constructor Boolean\n@param {String} message Human-readable description of the error\n@param {String} fileName The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.\n@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation.\n*/\n\n\n\n/*\n@property {String} message\n\n#Summary\nThe message property is a human-readable description of the error.\n\n#Description\nThis property contains a brief description of the error if one is available or has been set. SpiderMonkey makes extensive use of the message property for exceptions. The message property combined with the name property is used by the Error.prototype.toString() method to create a string representation of the Error.\n\nBy default, the message property is an empty string, but this behavior can be overridden for an instance by specifying a message as the first argument to the Error constructor.\n\n#Examples\n##Example: Throwing a custom error\n\n\tvar e = new Error(\"Could not parse input\"); // e.message is \"Could not parse input\"\n\tthrow e;\n*/\n\n\n\n\n\n/*\n@property {String} name\n#Summary\nThe name property represents a name for the type of error. The initial value is \"Error\".\n\n#Description\nBy default, Error instances are given the name \"Error\". The name property, in addition to the message property, is used by the Error.prototype.toString() method to create a string representation of the error.\n\n#Examples\n##Example: Throwing a custom error\n\n\tvar e = new Error(\"Malformed input\"); // e.name is \"Error\"\n\n\te.name = \"ParseError\"; \n\tthrow e;\n\t// e.toString() would return \"ParseError: Malformed input\"\n\n*/\n\n\n\n\n/*\n@class EvalError @extends Error\nThe EvalError object indicates an error regarding the global eval() function.\n*/\n\n/*\n@class RangeError @extends Error\n\nThe RangeError object indicates an error when a value is not in the set or range of allowed values.\n\nA RangeError is thrown when trying to pass a number as an argument to a function that does not allow a range that includes that number. This can be encountered when to create an array of an illegal length with the Array constructor, or when passing bad values to the numeric methods Number.toExponential(), Number.toFixed() or Number.toPrecision().\n*/\n\n\n/*\n@class ReferenceError @extends Error\n#Summary\nThe ReferenceError object represents an error when a non-existent variable is referenced.\n\n#Description\nA ReferenceError is thrown when trying to dereference a variable that has not been declared.\n*/\n\n\n\n/*\n@class SyntaxError @extends Error\n\n#Summary\nThe SyntaxError object represents an error when trying to interpret syntactically invalid code.\n\n#Description\nA SyntaxError is thrown when the JavaScript engine encounters tokens or token order that does not conform to the syntax of the language when parsing code.\n*/\n\n\n/*\n@class TypeError @extends Error\nThe TypeError object represents an error when a value is not of the expected type.\n*/\n\n/*\n@class URIError @extends Error\n\nThe URIError object represents an error when a global URI handling function was used in a wrong way.\n*/\n\n\n/*\n@module javascript\n\n@class Function\n\n#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.\n*/\n\n\n/*\n@property {Number} length\n\n#Summary\nThe length property specifies the number of arguments expected by the function.\n\n#Description\nlength is a property of a function object, and indicates how many arguments the function expects, i.e. the number of formal parameters. This number does not include the rest parameter. By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.\n\nData property of the Function constructor\n\nThe Function constructor is itself a Function object. It's length data property has a value of 1. The property attributes are: Writable: false, Enumerable: false, Configurable: true.\n\nProperty of the Function prototype object\n\nThe length property of the Function prototype object has a value of 0.\n\n#Examples\n\tconsole.log ( Function.length ); //1\n\n\tconsole.log( (function ()        {}).length ); //0\n\tconsole.log( (function (a)       {}).length ); //1\n\tconsole.log( (function (a, b)    {}).length ); //2 etc. \n\tconsole.log( (function (...args) {}).length ); //0, rest parameter is no\n\n*/\n\n\n/*\n@property {FunctionPrototype} prototype\n#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.\n*/\n\n\n\n/*\n@method apply\n\nThe apply() method calls a function with a given this value and arguments provided as an array (or an array-like object).\n\nNote: While the syntax of this function is almost identical to that of call(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.apply(thisArg, [argsArray])\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object. With apply, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\napply is very similar to call(), except for the type of arguments it supports. You can use an arguments array instead of a named set of parameters. With apply, you can use an array literal, for example, fun.apply(this, ['eat', 'bananas']), or an Array object, for example, fun.apply(this, new Array('eat', 'bananas')).\n\nYou can also use arguments for the argsArray parameter. arguments is a local variable of a function. It can be used for all unspecified arguments of the called object. Thus, you do not have to know the arguments of the called object when you use the apply method. You can use arguments to pass all the arguments to the called object. The called object is then responsible for handling the arguments.\n\nSince ECMAScript 5th Edition you can also use any kind of object which is array-like, so in practice this means it's going to have a property length and integer properties in the range [0...length). As an example you can now use a NodeList or a own custom object like {'length': 2, '0': 'eat', '1': 'bananas'}.\n\nNote: Most browsers, including Chrome 14 and Internet Explorer 9, still do not accept array-like objects and will throw an exception.\n#Examples\nUsing apply to chain constructors\n\nYou can use apply to chain constructors for an object, similar to Java. In the following example we will create a global Function method called construct, which will make you able to use an array-like object with a constructor instead of an arguments list.\n\n\tFunction.prototype.construct = function (aArgs) {\n\t    var fConstructor = this, fNewConstr = function () { fConstructor.apply(this, aArgs); };\n\t    fNewConstr.prototype = fConstructor.prototype;\n\t    return new fNewConstr();\n\t};\n\nExample usage:\n\n\tfunction MyConstructor () {\n\t    for (var nProp = 0; nProp < arguments.length; nProp++) {\n\t        this[\"property\" + nProp] = arguments[nProp];\n\t    }\n\t}\n\n\tvar myArray = [4, \"Hello world!\", false];\n\tvar myInstance = MyConstructor.construct(myArray);\n\n\talert(myInstance.property1); // alerts \"Hello world!\"\n\talert(myInstance instanceof MyConstructor); // alerts \"true\"\n\talert(myInstance.constructor); // alerts \"MyConstructor\"\n\nNote: This non-native Function.construct method will not work with some native constructors (like Date, for example). In these cases you have to use the Function.bind method (for example, imagine to have an array like the following, to be used with Date constructor: [2012, 11, 4]; in this case you have to write something like: new (Function.prototype.bind.apply(Date, [null].concat([2012, 11, 4])))() â€“ anyhow this is not the best way to do things and probably should not be used in any production environment).\nUsing apply and built-in functions\n\nClever usage of apply allows you to use built-ins functions for some tasks that otherwise probably would have been written by looping over the array values. As an example here we are going to use Math.max/Math.min to find out the maximum/minimum value in an array.\n\n\t//min/max number in an array \n\tvar numbers = [5, 6, 2, 3, 7];\n\n\t//using Math.min/Math.max apply \n\tvar max = Math.max.apply(null, numbers); // This about equal to Math.max(numbers[0], ...) or Math.max(5, 6, ..) \n\tvar min = Math.min.apply(null, numbers);\n\n\t/ vs. simple loop based algorithm \n\tmax = -Infinity, min = +Infinity;\n\n\tfor (var i = 0; i < numbers.length; i++) {\n\t  if (numbers[i] > max)\n\t    max = numbers[i];\n\t  if (numbers[i] < min) \n\t    min = numbers[i];\n\t}\n\nBut beware: in using apply this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (think more than tens of thousands of arguments) vary across engines (JavaScriptCore has hard-coded argument limit of 65536), because the limit (indeed even the nature of any excessively-large-stack behavior) is unspecified. Some engines will throw an exception. More perniciously, others will arbitrarily limit the number of arguments actually passed to the applied function. (To illustrate this latter case: if such an engine had a limit of four arguments [actual limits are of course significantly higher], it would be as if the arguments 5, 6, 2, 3 had been passed to apply in the examples above, rather than the full array.) If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:\n\n\tfunction minOfArray(arr) {\n\t  var min = Infinity;\n\t  var QUANTUM = 32768;\n\n\t  for (var i = 0, len = arr.length; i < len; i += QUANTUM) {\n\t    var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len)));\n\t    min = Math.min(submin, min);\n\t  }\n\n\t  return min;\n\t}\n\n\tvar min = minOfArray([5, 6, 2, 3, 7]);\nUsing apply in \"monkey-patching\"\n\nApply can be the best way to monkey-patch a builtin function of Firefox, or JS libraries. Given someobject.foo function, you can modify the function in a somewhat hacky way, like so:\n\n\tvar originalfoo = someobject.foo;\n\tsomeobject.foo = function() {\n\t  //Do stuff before calling function\n\t  console.log(arguments);\n\t  //Call the function as it would have been called normally:\n\t  originalfoo.apply(this,arguments);\n\t  //Run stuff after, here.\n\t}\n\nThis method is especially handy where you want to debug events, or interface with something that has no API like the various .on([event]... events, such as those usable on the Devtools Inspector).\n\n\n@param {Object}thisArg The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.\n@param {Array} argsArray An array-like object, specifying the arguments with which fun should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.\n\n@returns the result of evaluating this function with given context and parameters\n*/\n\n\n\n\n\n\n\n/*\n@method bind\n\n#Summary\nThe bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.\n\n#Syntax\n\tfun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nThe bind() function creates a new function (a bound function) with the same function body (internal call property in ECMAScript 5 terms) as the function it is being called on (the bound function's target function) with the this value bound to the first argument of bind(), which cannot be overridden. bind() also accepts leading default arguments to provide to the target function when the bound function is called. A bound function may also be constructed using the new operator: doing so acts as though the target function had instead been constructed. The provided this value is ignored, while prepended arguments are provided to the emulated function.\n\n#Examples\nCreating a bound function\n\nThe simplest use of bind() is to make a function that, no matter how it is called, is called with a particular this value. A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g. by using that method in callback-based code). Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:\n\n\tthis.x = 9; \n\tvar module = {\n\t  x: 81,\n\t  getX: function() { return this.x; }\n\t};\n\n\tmodule.getX(); // 81\n\n\tvar getX = module.getX;\n\tgetX(); // 9, because in this case, \"this\" refers to the global object\n\n\t// create a new function with 'this' bound to module\n\tvar boundGetX = getX.bind(module);\n\tboundGetX(); // 81\n\n##Partial Functions\n\nThe next simplest use of bind() is to make a function with pre-specified initial arguments. These arguments (if any) follow the provided this value and are then inserted at the start of the arguments passed to the target function, followed by the arguments passed to the bound function, whenever the bound function is called.\n\n\tfunction list() {\n\t  return Array.prototype.slice.call(arguments);\n\t}\n\n\tvar list1 = list(1, 2, 3); // [1, 2, 3]\n\n\t//  Create a function with a preset leading argument\n\tvar leadingThirtysevenList = list.bind(undefined, 37);\n\n\tvar list2 = leadingThirtysevenList(); // [37]\n\tvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n##With setTimeout\n\nBy default within window.setTimeout(), the this keyword will be set to the window (or global) object. When working with class methods that require this to refer to class instances, you may explicitly bind this to the callback function, in order to maintain the instance.\n\n\tfunction LateBloomer() {\n\t  this.petalCount = Math.ceil( Math.random() * 12 ) + 1;\n\t}\n\n\t// declare bloom after a delay of 1 second\n\tLateBloomer.prototype.bloom = function() {\n\t  window.setTimeout( this.declare.bind( this ), 1000 );\n\t};\n\n\tLateBloomer.prototype.declare = function() {\n\t  console.log('I am a beautiful flower with ' + \n\t    this.petalCount + ' petals!');\n\t};\n\n##Bound functions used as constructors\n\nWarning: This section demonstrates JavaScript capabilities and documents some edge cases of the bind() method. The methods shown below are not the best way to do things and probably should not be used in any production environment.\nBound functions are automatically suitable for use with the new operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided this is ignored. However, provided arguments are still prepended to the constructor call:\n\n\tfunction Point(x, y) {\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\n\tPoint.prototype.toString = function() { \n\t  return this.x + \",\" + this.y; \n\t};\n\n\tvar p = new Point(1, 2);\n\tp.toString(); // \"1,2\"\n\n\n\tvar emptyObj = {};\n\tvar YAxisPoint = Point.bind(emptyObj, 0);\n\t// not supported in the polyfill below, works fine with native bind:\n\tvar YAxisPoint = Point.bind(null,0 );\n\n\tvar axisPoint = new YAxisPoint(5);\n\taxisPoint.toString(); //  \"0,5\"\n\n\taxisPoint instanceof Point; // true\n\taxisPoint instanceof YAxisPoint; // true\n\tnew Point(17, 42) instanceof YAxisPoint; // false\nNote that you need do nothing special to create a bound function for use with new. The corollary is that you need do nothing special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using new.\n\n\t// Example can be run directly in your JavaScript console\n\t// ...continuing from above\n\n\t// Can still be called as a normal function \n\t// (although usually this is undesired)\n\tYAxisPoint(13);\n\n\temptyObj.x + \",\" + emptyObj.y;\n\t// >  \"0,13\"\nIf you wish to support use of a bound function only using new, or only by calling it, the target function must enforce that restriction.\n\n##Creating shortcuts\n\nbind() is also helpful in cases where you want to create a shortcut to a function which requires a specific this value.\n\nTake Array.prototype.slice, for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:\n\n\tvar slice = Array.prototype.slice;\n\n\t// ...\n\n\tslice.call(arguments);\n\tWith bind(), this can be simplified. In the following piece of code, slice is a bound function to the call() function of Function.prototype, with the this value set to the slice() function of Array.prototype. This means that additional call() calls can be eliminated:\n\n\t// same as \"slice\" in the previous example\n\tvar unboundSlice = Array.prototype.slice;\n\tvar slice = Function.prototype.call.bind(unboundSlice);\n\n\t// ...\n\n\tslice(arguments);\n#Polyfill\nThe bind function is a recent addition to ECMA-262, 5th edition; as such it may not be present in all browsers. You can partially work around this by inserting the following code at the beginning of your scripts, allowing use of much of the functionality of bind() in implementations that do not natively support it.\n\n\tif (!Function.prototype.bind) {\n\t  Function.prototype.bind = function (oThis) {\n\t    if (typeof this !== \"function\") {\n\t      // closest thing possible to the ECMAScript 5\n\t      // internal IsCallable function\n\t      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\t    }\n\n\t    var aArgs = Array.prototype.slice.call(arguments, 1), \n\t        fToBind = this, \n\t        fNOP = function () {},\n\t        fBound = function () {\n\t          return fToBind.apply(this instanceof fNOP && oThis\n\t                 ? this\n\t                 : oThis,\n\t                 aArgs.concat(Array.prototype.slice.call(arguments)));\n\t        };\n\n\t    fNOP.prototype = this.prototype;\n\t    fBound.prototype = new fNOP();\n\n\t    return fBound;\n\t  };\n\t}\n\nSome of the many differences (there may well be others, as this list does not seriously attempt to be exhaustive) between this algorithm and the specified algorithm are:\n\nThe partial implementation relies Array.prototype.slice, Array.prototype.concat, Function.prototype.call and Function.prototype.apply, built-in methods to have their original values.\nThe partial implementation creates functions that do not have immutable \"poison pill\" caller and arguments properties that throw a TypeError upon get, set, or deletion. (This could be added if the implementation supports Object.defineProperty, or partially implemented [without throw-on-delete behavior] if the implementation supports the __defineGetter__ and __defineSetter__ extensions.)\nThe partial implementation creates functions that have a prototype property. (Proper bound functions have none.)\nThe partial implementation creates bound functions whose length property does not agree with that mandated by ECMA-262: it creates functions with length 0, while a full implementation, depending on the length of the target function and the number of pre-specified arguments, may return a non-zero length.\nIf you choose to use this partial implementation, you must not rely on those cases where behavior deviates from ECMA-262, 5th edition! With some care, however (and perhaps with additional modification to suit specific needs), this partial implementation may be a reasonable bridge to the time when bind() is widely implemented according to the specification.\n\n@param thisArg The value to be passed as the this parameter to the target function when the bound function is called. The value is ignored if the bound function is constructed using the new operator.\n@param args Arguments to prepend to arguments provided to the bound function when invoking the target function.\n\n*/\n\n\n\n\n\n\n/*\n@method call\n\n#Summary\nThe call() method calls a function with a given this value and arguments provided individually.\n\nNOTE: While the syntax of this function is almost identical to that of apply(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.call(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object.\n\nWith call, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\n#Examples\n##Using call to chain constructors for an object\n\nYou can use call to chain constructors for an object, similar to Java. In the following example, the constructor for the Product object is defined with two parameters, name and price. Two other functions Food and Toy invoke Product passing this and name and price. Product initializes the properties name and price, both specialized functions define the category.\n\n\tfunction Product(name, price) {\n\t  this.name = name;\n\t  this.price = price;\n\n\t  if (price < 0) {\n\t    throw RangeError('Cannot create product ' +\n\t                      this.name + ' with a negative price');\n\t  }\n\n\t  return this;\n\t}\n\n\tfunction Food(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'food';\n\t}\n\n\tFood.prototype = Object.create(Product.prototype);\n\n\tfunction Toy(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'toy';\n\t}\n\n\tToy.prototype = Object.create(Product.prototype);\n\n\tvar cheese = new Food('feta', 5);\n\tvar fun = new Toy('robot', 40);\n \n##Using call to invoke an anonymous function\n\nIn this purely constructed example, we create anonymous function and use call to invoke it on every object in an array. The main purpose of the anonymous function here is to add a print function to every object, which is able to print the right index of the object in the array. Passing the object as this value was not strictly necessary, but is done for explanatory purpose.\n\n\tvar animals = [\n\t  {species: 'Lion', name: 'King'},\n\t  {species: 'Whale', name: 'Fail'}\n\t];\n\n\tfor (var i = 0; i < animals.length; i++) {\n\t  (function (i) { \n\t    this.print = function () { \n\t      console.log('#' + i  + ' ' + this.species \n\t                  + ': ' + this.name); \n\t    } \n\t    this.print();\n\t  }).call(animals[i], i);\n\t}\n\n\n@param thisArg The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.\n@param arg1,arg2,... Arguments for the object.\n\n*/\n\n\n\n\n/*\n@method toString\n#Summary\nThe toString() method returns a string representing the source code of the function.\n\n#Syntax\n\tfunction.toString(indentation)\n#Description\nThe Function object overrides the toString method inherited from Object; it does not inherit Object.prototype.toString. For Function objects, the toString method returns a string representation of the object in the form of a function declaration. That is, toString decompiles the function, and the string returned includes the function keyword, the argument list, curly braces, and the source of the function body.\n\nJavaScript calls the toString method automatically when a Function is to be represented as a text value, e.g. when a function is concatenated with a string.\n\n@return {String}\n*/\n\n/*\n@module javascript\n@class Number\n\n#Summary\nThe Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor.\n\n#Constructor\n\tnew Number(value);\n\n#Description\nThe primary uses for the Number object are:\n\nIf the argument cannot be converted into a number, it returns NaN.\nIn a non-constructor context (i.e., without the new operator, Number can be used to perform a type conversion.\n\n\n#Examples\n##Example: Using the Number object to assign values to numeric variables\n\nThe following example uses the Number object's properties to assign values to several numeric variables:\n\n\tvar biggestNum = Number.MAX_VALUE;\n\tvar smallestNum = Number.MIN_VALUE;\n\tvar infiniteNum = Number.POSITIVE_INFINITY;\n\tvar negInfiniteNum = Number.NEGATIVE_INFINITY;\n\tvar notANum = Number.NaN;\n##Example: Integer range for Number\n\nThe following example shows minimum and maximum integer values that can be represented as Number object (for details, refer to EcmaScript standard, chapter 8.5 The Number Type):\n\n\tvar biggestInt = 9007199254740992;\n\tvar smallestInt = -9007199254740992;\n\nWhen parsing data that has been serialized to JSON, integer values falling out of this range can be expected to become corrupted when JSON parser coerces them to Number type. Using String instead is a possible workaround.\n\n##Example: Using Number to convert a Date object\n\nThe following example converts the Date object to a numerical value using Number as a function:\n\n\tvar d = new Date(\"December 17, 1995 03:24:00\");\n\tprint(Number(d));\n\nThis displays \"819199440000\".\n\n*/\n\n/*\n@constructor Number\n@param {Any}value The numeric value of the object being created.\n*/\n\n\n\n\n\n\n/*\n@property {Number} MAX_VALUE\n\n#Summary\nThe Number.MAX_VALUE property represents the maximum numeric value representable in JavaScript.\n\n#Description\nThe MAX_VALUE property has a value of approximately 1.79E+308. Values larger than MAX_VALUE are represented as \"Infinity\".\n\nBecause MAX_VALUE is a static property of Number, you always use it as Number.MAX_VALUE, rather than as a property of a Number object you created.\n\n#Examples\n##Example: Using MAX_VALUE\n\n\tThe following code multiplies two numeric values. If the result is less than or equal to MAX_VALUE, the func1 function is called; otherwise, the func2 function is called.\n\n\tif (num1 * num2 <= Number.MAX_VALUE) {\n\t   func1();\n\t} else {\n\t   func2();\n\t}\n\n@static\n\n*/\n\n\n\n/*\n@property {Number} MIN_VALUE\n\n#Summary\nThe Number.MIN_VALUE property represents the smallest positive numeric value representable in JavaScript.\n\n#Description\nThe MIN_VALUE property is the number closest to 0, not the most negative number, that JavaScript can represent.\n\nMIN_VALUE has a value of approximately 5e-324. Values smaller than MIN_VALUE (\"underflow values\") are converted to 0.\n\nBecause MIN_VALUE is a static property of Number, you always use it as Number.MIN_VALUE, rather than as a property of a Number object you created.\n\n#Examples\n##Example: Using MIN_VALUE\n\nThe following code divides two numeric values. If the result is greater than or equal to MIN_VALUE, the func1 function is called; otherwise, the func2 function is called.\n\n\tif (num1 / num2 >= Number.MIN_VALUE) {\n\t    func1();\n\t} else {\n\t    func2();\n\t}\n\n@static\n*/\n\n\n\n\n/*\n@property {Number}NEGATIVE_INFINITY\n\n#Summary\nThe Number.NEGATIVE_INFINITY property represents the negative Infinity value.\n\nYou do not have to create a Number object to access this static property (use Number.NEGATIVE_INFINITY).\n\n#Description\nThe value of Number.NEGATIVE_INFINITY is the same as the negative value of the global object's Infinity property.\n\nThis value behaves slightly differently than mathematical infinity:\n\n* Any positive value, including POSITIVE_INFINITY, multiplied by NEGATIVE_INFINITY is NEGATIVE_INFINITY.\n* Any negative value, including NEGATIVE_INFINITY, multiplied by NEGATIVE_INFINITY is POSITIVE_INFINITY.\n* Zero multiplied by NEGATIVE_INFINITY is NaN.\n* NaN multiplied by NEGATIVE_INFINITY is NaN.\n* NEGATIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is POSITIVE_INFINITY.\n* NEGATIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is NEGATIVE_INFINITY.\n* NEGATIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\n* Any number divided by NEGATIVE_INFINITY is zero.\n\nYou might use the Number.NEGATIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that isFinite would be more appropriate in such a case.\n\n#Example\nIn the following example, the variable smallNumber is assigned a value that is smaller than the minimum value. When the if statement executes, smallNumber has the value \"-Infinity\", so smallNumber is set to a more manageable value before continuing.\n\n\tvar smallNumber = (-Number.MAX_VALUE) * 2\n\n\tif (smallNumber == Number.NEGATIVE_INFINITY) {\n\t smallNumber = returnFinite();\n\t}\n\n@static\n*/\n\n\n\n/*\n@property {Number} NaN\n#Summary\nThe Number.NaN property represents Not-A-Number. Equivalent of NaN.\n\nYou do not have to create a Number object to access this static property (use Number.NaN).\n@static\n*/\n\n\n\n/*\n@property {Number}POSITIVE_INFINITY\n\n#Summary\nThe Number.POSITIVE_INFINITY property represents the positive Infinity value.\n\nYou do not have to create a Number object to access this static property (use Number.POSITIVE_INFINITY).\n\n#Description\nThe value of Number.POSITIVE_INFINITY is the same as the value of the global object's Infinity property.\n\nThis value behaves slightly differently than mathematical infinity:\n\n* Any positive value, including POSITIVE_INFINITY, multiplied by POSITIVE_INFINITY is POSITIVE_INFINITY.\n* Any negative value, including NEGATIVE_INFINITY, multiplied by POSITIVE_INFINITY is NEGATIVE_INFINITY.\n* Zero multiplied by POSITIVE_INFINITY is NaN.\n* NaN multiplied by POSITIVE_INFINITY is NaN.\n* POSITIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is NEGATIVE_INFINITY.\n* POSITIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is POSITIVE_INFINITY.\n* POSITIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\n* Any number divided by POSITIVE_INFINITY is Zero.\n* You might use the Number.POSITIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that isFinite would be more appropriate in such a case.\n\n#Example\nIn the following example, the variable bigNumber is assigned a value that is larger than the maximum value. When the if statement executes, bigNumber has the value \"Infinity\", so bigNumber is set to a more manageable value before continuing.\n\n\tvar bigNumber = Number.MAX_VALUE * 2\n\tif (bigNumber == Number.POSITIVE_INFINITY) {\n\t bigNumber = returnFinite();\n\t}\n\n@static \n*/\n\n/*\n@module javascript\n\n@class Object\nAdapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n\n#Description\nThe Object constructor creates an object wrapper for the given value. If the value is null or undefined, it will create and return an empty object, otherwise, it will return an object of a Type that corresponds to the given value. If the value is an object already, it will return the value.\n\nWhen called in a non-constructor context, Object behaves identically to new Object().\n\n#Object instances and Object prototype object\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden. For example, other constructors' prototypes override the constructor property and provide their own toString methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.\n\n#Examples\n##Example: Using Object given undefined and null types\n\nThe following examples store an empty Object object in o:\n\n\tvar o = new Object();\n\tvar o = new Object(undefined);\n\tvar o = new Object(null);\n##Example: Using Object to create Boolean objects\n\nThe following examples store Boolean objects in o:\n\n\t// equivalent to o = new Boolean(true);\n\tvar o = new Object(true);\n\t// equivalent to o = new Boolean(false);\n\tvar o = new Object(Boolean());\n\n\n@property {ObjectPrototype} prototype\n\n@static \n\n*/\n\n/*\n@constructor bla bla\n\n\t// Object initialiser or literal \n\t{ [ nameValuePair1 [, nameValuePair2 [, ...nameValuePairN] ] ] }  \n\t// Called as a constructor \n\tnew Object( [ value ] )\n\n@param nameValuePair1,nameValuePair2,...nameValuePairN Pairs of names (strings) and values (any value) where the name is separated from the value by a colon.\n@param value Any value.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method __defineGetter__()  \nAssociates a function with a property that, when accessed, executes that function and returns its return value.\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method hasOwnProperty\n##Summary\nThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n##Syntax\nobj.hasOwnProperty(prop)\n\n##Examples\n###Example: Using hasOwnProperty to test for a property's existence\n\nThe following example determines whether the o object contains a property named prop:\n\n\to = new Object();\n\to.prop = 'exists';\n\n\tfunction changeO() {\n\t  o.newprop = o.prop;\n\t  delete o.prop;\n\t}\n\n\to.hasOwnProperty('prop');   // returns true\n\tchangeO();\n\to.hasOwnProperty('prop');   // returns false\n\n###Example: Direct versus inherited properties\n\nThe following example differentiates between direct properties and properties inherited through the prototype chain:\n\n\to = new Object();\n\to.prop = 'exists';\n\to.hasOwnProperty('prop');             // returns true\n\to.hasOwnProperty('toString');         // returns false\n\to.hasOwnProperty('hasOwnProperty');   // returns false\n\n##Example: Iterating over the properties of an object\n\nThe following example shows how to iterate over the properties of an object without executing on inherit properties. Note that the for..in loop is already only iterating enumerable items, so one should not assume based on the lack of non-enumerable properties shown in the loop that hasOwnProperty itself is confined strictly to enumerable items (as with Object.getOwnPropertyNames()).\n\n\tvar buz = {\n\t    fog: 'stack'\n\t};\n\n\tfor (var name in buz) {\n\t    if (buz.hasOwnProperty(name)) {\n\t        alert(\"this is fog (\" + name + \") for sure. Value: \" + buz[name]);\n\t    }\n\t    else {\n\t        alert(name); // toString or something else\n\t    }\n\t}\n\n###Example: hasOwnProperty as a property\n\nJavaScript does not protect the property name hasOwnProperty; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an external hasOwnProperty to get correct results:\n\n\tvar foo = {\n\t    hasOwnProperty: function() {\n\t        return false;\n\t    },\n\t    bar: 'Here be dragons'\n\t};\n\n\tfoo.hasOwnProperty('bar'); // always returns false\n\n\t// Use another Object's hasOwnProperty and call it with 'this' set to foo\n\t({}).hasOwnProperty.call(foo, 'bar'); // true\n\n\t// It's also possible to use the hasOwnProperty property from the Object property for this purpose\n\tObject.prototype.hasOwnProperty.call(foo, 'bar'); // true\n\nNote that in the last case there are no newly created objects.\n\n@param param The name of the property to test.\n\n*/\n\n\n\n\n\n\n\n\n/*\n@method isPrototypeOf\n##Summary\nThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\n\tNote: isPrototypeOf differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n\nThe isPrototypeOf method allows you to check whether or not an object exists within another object's prototype chain.\n\nFor example, consider the following prototype chain:\n\n\tfunction Fee() {\n\t  // . . .\n\t}\n\n\tfunction Fi() {\n\t  // . . .\n\t}\n\tFi.prototype = new Fee();\n\n\tfunction Fo() {\n\t  // . . .\n\t}\n\tFo.prototype = new Fi();\n\n\tfunction Fum() {\n\t  // . . .\n\t}\n\tFum.prototype = new Fo();\n\nLater on down the road, if you instantiate Fum and need to check if Fi's prototype exists within the Fum prototype chain, you could do this:\n\n\tvar fum = new Fum();\n\t. . .\n\t\n\tif (Fi.prototype.isPrototypeOf(fum)) {\n\t  // do something safe\n\t}\nThis, along with the instanceof operator particularly comes in handy if you have code that can only function when dealing with objects descended from a specific prototype chain, e.g., to guarantee that certain methods or properties will be present on that object.\n\n\n@param {Object} obj the object whose prototype chain will be searched\n*/\n\n\n\n\n\n/*\n@method propertyIsEnumerable\n##Summary\nThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n\n##Description\nEvery object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.\n\n##Examples\n###Example: A basic use of propertyIsEnumerable\n\nThe following example shows the use of propertyIsEnumerable on objects and arrays:\n\n\tvar o = {};\n\tvar a = [];\n\to.prop = 'is enumerable';\n\ta[0] = 'is enumerable';\n\n\to.propertyIsEnumerable('prop');   // returns true\n\ta.propertyIsEnumerable(0);        // returns true\n\n###Example: User-defined versus built-in objects\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n\tvar a = ['is enumerable'];\n\n\ta.propertyIsEnumerable(0);          // returns true\n\ta.propertyIsEnumerable('length');   // returns false\n\n\tMath.propertyIsEnumerable('random');   // returns false\n\tthis.propertyIsEnumerable('Math');     // returns false\n\tExample: Direct versus inherited properties\n\n\tvar a = [];\n\ta.propertyIsEnumerable('constructor');         // returns false\n\n\tfunction firstConstructor() {\n\t  this.property = 'is not enumerable';\n\t}\n\n\tfirstConstructor.prototype.firstMethod = function () {};\n\n\tfunction secondConstructor() {\n\t  this.method = function method() { return 'is enumerable'; };\n\t}\n\n\tsecondConstructor.prototype = new firstConstructor;\n\tsecondConstructor.prototype.constructor = secondConstructor;\n\n\tvar o = new secondConstructor();\n\to.arbitraryProperty = 'is enumerable';\n\n\to.propertyIsEnumerable('arbitraryProperty');   // returns true\n\to.propertyIsEnumerable('method');              // returns true\n\to.propertyIsEnumerable('property');            // returns false\n\n\to.property = 'is enumerable';\n\n\to.propertyIsEnumerable('property');            // returns true\n\n\t// These return false as they are on the prototype which \n\t// propertyIsEnumerable does not consider (even though the last two\n\t// are iteratable with for-in)\n\to.propertyIsEnumerable('prototype');   // returns false (as of JS 1.8.1/FF3.6)\n\to.propertyIsEnumerable('constructor'); // returns false\n\to.propertyIsEnumerable('firstMethod'); // returns false\n\n@param prop\nThe name of the property to test.\n*/\n\n\n\n\n/*\n@method toLocaleString\n##Summary\nThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n##Syntax\nobj.toLocaleString();\n##Description\nObject's toLocaleString returns the result of calling toString().\n\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. See the list below.\n\n##Objects overriding toLocaleString\n\nArray: Array.prototype.toLocaleString()\nNumber: Number.prototype.toLocaleString()\nDate: Date.prototype.toLocaleString()\n*/\n\n\n\n\n\n/*\n@method toString\n##Summary\nThe toString() method returns a string representing object.\n\n##Syntax\nobj.toString()\n##Description\nEvery object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected. By default, the toString() method is inherited by every object descended from Object. If this method is not overridden in a custom object, toString() returns \"[object type]\", where type is the object type. The following code illustrates this:\n\nvar o = new Object();\no.toString();           // returns [object Object]\nStarting in JavaScript 1.8.5 toString() called on null returns [object Null], and undefined returns [object Undefined], as defined in the 5th Edition of ECMAScript and a subsequent Errata. See Using toString to detect object type.\n##Examples\n###Overriding the default toString method\n\nYou can create a function to be called in place of the default toString() method. The toString() method takes no arguments and should return a string. The toString() method you create can be any value you want, but it will be most useful if it carries information about the object.\n\nThe following code defines the Dog object type and creates theDog, an object of type Dog:\n\n\tfunction Dog(name,breed,color,sex) {\n\t   this.name=name;\n\t   this.breed=breed;\n\t   this.color=color;\n\t   this.sex=sex;\n\t}\n\n\ttheDog = new Dog(\"Gabby\",\"Lab\",\"chocolate\",\"female\");\nIf you call the toString() method on this custom object, it returns the default value inherited from Object:\n\n\ttheDog.toString(); //returns [object Object]\n\tThe following code creates and assigns dogToString() to override the default toString() method. This function generates a string containing the name, breed, color, and sex of the object, in the form \"property = value;\".\n\n\tDog.prototype.toString = function dogToString() {\n\t  var ret = \"Dog \" + this.name + \" is a \" + this.sex + \" \" + this.color + \" \" + this.breed;\n\t  return ret;\n\t}\nWith the preceding code in place, any time theDog is used in a string context, JavaScript automatically calls the dogToString() function, which returns the following string:\n\nDog Gabby is a female chocolate Lab\nUsing toString() to detect object class\n\ntoString() can be used with every object and allows you to get its class. To use the Object.prototype.toString() with every object, you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter called thisArg.\n\n\tvar toString = Object.prototype.toString;\n\n\ttoString.call(new Date); // [object Date]\n\ttoString.call(new String); // [object String]\n\ttoString.call(Math); // [object Math]\n\n\t//Since JavaScript 1.8.5\n\ttoString.call(undefined); // [object Undefined]\n\ttoString.call(null); // [object Null]\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method create\n\n#Summary\nThe Object.create() method creates a new object with the specified prototype object and properties.\n\n#Syntax\n\tObject.create(proto[, propertiesObject])\n\n#Examples\n\n##Example: Classical inheritance with Object.create\n\nBelow is an example of how to use Object.create to achieve classical inheritance. This is for single inheritance, which is all that Javascript supports.\n\n\t// Shape - superclass\n\tfunction Shape() {\n\t  this.x = 0;\n\t  this.y = 0;\n\t}\n\n\t// superclass method\n\tShape.prototype.move = function(x, y) {\n\t  this.x += x;\n\t  this.y += y;\n\t  console.info('Shape moved.');\n\t};\n\n\t// Rectangle - subclass\n\tfunction Rectangle() {\n\t  Shape.call(this); // call super constructor.\n\t}\n\n\t// subclass extends superclass\n\tRectangle.prototype = Object.create(Shape.prototype);\n\tRectangle.prototype.constructor = Rectangle;\n\n\tvar rect = new Rectangle();\n\n\trect instanceof Rectangle; // true\n\trect instanceof Shape; // true\n\n\trect.move(1, 1); // Outputs, 'Shape moved.'\n\tIf you wish to inherit from multiple objects, then mixins are a possibility.\n\n\tfunction MyClass() {\n\t  SuperClass.call(this);\n\t  OtherSuperClass.call(this);\n\t}\n\n\tMyClass.prototype = Object.create(SuperClass.prototype); // inherit\n\tmixin(MyClass.prototype, OtherSuperClass.prototype); // mixin\n\n\tMyClass.prototype.myMethod = function() {\n\t  // do a thing\n\t};\n\nThe mixin function would copy the functions from the superclass prototype to the subclass prototype, the mixin function needs to be supplied by the user. An example of a mixin like function would be jQuery.extend.\n\n##Example: Using propertiesObject argument with Object.create\n\n\tvar o;\n\n\t// create an object with null as prototype\n\to = Object.create(null);\n\n\n\to = {};\n\t// is equivalent to:\n\to = Object.create(Object.prototype);\n\n\n\t// Example where we create an object with a couple of sample properties.\n\t// (Note that the second parameter maps keys to *property descriptors*.)\n\to = Object.create(Object.prototype, {\n\t  // foo is a regular 'value property'\n\t  foo: { writable: true, configurable: true, value: 'hello' },\n\t  // bar is a getter-and-setter (accessor) property\n\t  bar: {\n\t    configurable: false,\n\t    get: function() { return 10; },\n\t    set: function(value) { console.log('Setting `o.bar` to', value); }\n\t  }\n\t});\n\n\n\tfunction Constructor() {}\n\to = new Constructor();\n\t// is equivalent to:\n\to = Object.create(Constructor.prototype);\n\t// Of course, if there is actual initialization code in the\n\t// Constructor function, the Object.create cannot reflect it\n\n\n\t// create a new object whose prototype is a new, empty object\n\t// and a adding single property 'p', with value 42\n\to = Object.create({}, { p: { value: 42 } });\n\n\t// by default properties ARE NOT writable, enumerable or configurable:\n\to.p = 24;\n\to.p;\n\t// 42\n\n\to.q = 12;\n\tfor (var prop in o) {\n\t  console.log(prop);\n\t}\n\t// 'q'\n\n\tdelete o.p;\n\t// false\n\n\t// to specify an ES3 property\n\to2 = Object.create({}, {\n\t  p: {\n\t    value: 42,\n\t    writable: true,\n\t    enumerable: true,\n\t    configurable: true\n\t  }\n\t});\n\n##Polyfill\nThis polyfill covers the main use case which is creating a new object for which the prototype has been chosen but doesn't take the second argument into account.\n\n\tif (typeof Object.create != 'function') {\n\t  Object.create = (function() {\n\t    var Object = function() {};\n\t    return function (prototype) {\n\t      if (arguments.length > 1) {\n\t        throw Error('Second argument not supported');\n\t      }\n\t      if (typeof prototype != 'object') {\n\t        throw TypeError('Argument must be an object');\n\t      }\n\t      Object.prototype = prototype;\n\t      var result = new Object();\n\t      Object.prototype = null;\n\t      return result;\n\t    };\n\t  })();\n\t}\n\n@static\n\n@param {Object} proto The object which should be the prototype of the newly-created object.\n\n@param {Object} propertiesObject If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). @optional\n\n@throws Throws a TypeError exception if the proto parameter isn't null or an object.\n\n*/\n\n\n\n\n\n\n\n\n/*\n@method defineProperties\n\n#Summary\nThe Object.defineProperties() method defines new or modifies existing properties directly on an object, returning the object.\n\n#Syntax\n\tObject.defineProperties(obj, props)\n\n#Description\nObject.defineProperties, in essence, defines all properties corresponding to the enumerable own properties of props on the object obj object.\n\n#Example\n\n\tObject.defineProperties(obj, {\n\t  \"property1\": {\n\t    value: true,\n\t    writable: true\n\t  },\n\t  \"property2\": {\n\t    value: \"Hello\",\n\t    writable: false\n\t  }\n\t  // etc. etc.\n\t});\n\n\n# Polyfill\n\nAssuming a pristine execution environment with all names and properties referring to their initial values, Object.defineProperties is almost completely equivalent (note the comment in isCallable) to the following reimplementation in JavaScript:\n\n\tfunction defineProperties(obj, properties) {\n\t  function convertToDescriptor(desc) {\n\t    function hasProperty(obj, prop) {\n\t      return Object.prototype.hasOwnProperty.call(obj, prop);\n\t    }\n\n\t    function isCallable(v) {\n\t      // NB: modify as necessary if other values than functions are callable.\n\t      return typeof v === \"function\";\n\t    }\n\n\t    if (typeof desc !== \"object\" || desc === null)\n\t      throw new TypeError(\"bad desc\");\n\n\t    var d = {};\n\n\t    if (hasProperty(desc, \"enumerable\"))\n\t      d.enumerable = !!obj.enumerable;\n\t    if (hasProperty(desc, \"configurable\"))\n\t      d.configurable = !!obj.configurable;\n\t    if (hasProperty(desc, \"value\"))\n\t      d.value = obj.value;\n\t    if (hasProperty(desc, \"writable\"))\n\t      d.writable = !!desc.writable;\n\t    if (hasProperty(desc, \"get\")) {\n\t      var g = desc.get;\n\n\t      if (!isCallable(g) && typeof g !== \"undefined\")\n\t        throw new TypeError(\"bad get\");\n\t      d.get = g;\n\t    }\n\t    if (hasProperty(desc, \"set\")) {\n\t      var s = desc.set;\n\t      if (!isCallable(s) && typeof s !== \"undefined\")\n\t        throw new TypeError(\"bad set\");\n\t      d.set = s;\n\t    }\n\n\t    if ((\"get\" in d || \"set\" in d) && (\"value\" in d || \"writable\" in d))\n\t      throw new TypeError(\"identity-confused descriptor\");\n\n\t    return d;\n\t  }\n\n\t  if (typeof obj !== \"object\" || obj === null)\n\t    throw new TypeError(\"bad obj\");\n\n\t  properties = Object(properties);\n\n\t  var keys = Object.keys(properties);\n\t  var descs = [];\n\n\t  for (var i = 0; i < keys.length; i++)\n\t    descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);\n\n\t  for (var i = 0; i < descs.length; i++)\n\t    Object.defineProperty(obj, descs[i][0], descs[i][1]);\n\n\t  return obj;\n\t} \n\n\n@static \n\n@param {Object} obj The object on which to define or modify properties.\n@param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.\n\n\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method defineProperty\n\n#Summary\nThe Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\n\n#Syntax\nObject.defineProperty(obj, prop, descriptor)\n\n#Description\nThis method allows precise addition to or modification of a property on an object. Normal property addition through assignment creates properties which show up during property enumeration (for...in loop or Object.keys method), whose values may be changed, and which may be deleted. This method allows these extra details to be changed from their defaults.\n\nProperty descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both.\n\nBoth data and accessor descriptors are objects. They share the following optional keys:\n\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\nDefaults to false.\n\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\nDefaults to false.\nA data descriptor also has the following optional keys:\n\n###value\nThe value associated with the property. Can be any valid JavaScript value (number, object, function, etc).\nDefaults to undefined.\nwritable\ntrue if and only if the value associated with the property may be changed with an assignment operator.\nDefaults to false.\nAn accessor descriptor also has the following optional keys:\n\n###get\nA function which serves as a getter for the property, or undefined if there is no getter. The function return will be used as the value of property.\nDefaults to undefined.\n\n###set\nA function which serves as a setter for the property, or undefined if there is no setter. The function will receive as only argument the new value being assigned to the property.\nDefaults to undefined.\nBear in mind that these options are not necessarily own properties so, if inherited, will be considered too. In order to ensure these defaults are preserved you might freeze the Object.prototype upfront, specify all options explicitly, or point to null as __proto__ property.\n\n\t// using __proto__\n\tObject.defineProperty(obj, 'key', {\n\t  __proto__: null, // no inherited properties\n\t  value: 'static'  // not enumerable\n\t                   // not configurable\n\t                   // not writable\n\t                   // as defaults\n\t});\n\n\t// being explicit\n\tObject.defineProperty(obj, 'key', {\n\t  enumerable: false,\n\t  configurable: false,\n\t  writable: false,\n\t  value: 'static'\n\t});\n\n\t// recycling same object\n\tfunction withValue(value) {\n\t  var d = withValue.d || (\n\t    withValue.d = {\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false,\n\t      value: null\n\t    }\n\t  );\n\t  d.value = value;\n\t  return d;\n\t}\n\t// ... and ...\n\tObject.defineProperty(obj, 'key', withValue('static'));\n\n\t// if freeze is available, prevents the code to add\n\t// value, get, set, enumerable, writable, configurable\n\t// to the Object prototype\n\t(Object.freeze || Object)(Object.prototype);\n\n#Examples\n\nIf you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see additional examples.\n\n##Example: Creating a property\n\nWhen the property specified doesn't exist in the object, Object.defineProperty() creates a new property as described. Fields may be omitted from the descriptor, and default values for those fields are imputed. All of the Boolean-valued fields default to false. The value, get, and set fields default to undefined. A property which is defined without get/set/value/writable is called â€œgenericâ€ and is â€œtypedâ€ as a data descriptor.\n\n\tvar o = {}; // Creates a new object\n\n\t// Example of an object property added with defineProperty with a data property descriptor\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: true,\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\t// 'a' property exists in the o object and its value is 37\n\n\t// Example of an object property added with defineProperty with an accessor property descriptor\n\tvar bValue = 38;\n\tObject.defineProperty(o, 'b', {\n\t  get: function() { return bValue; },\n\t  set: function(newValue) { bValue = newValue; },\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\to.b; // 38\n\t// 'b' property exists in the o object and its value is 38\n\t// The value of o.b is now always identical to bValue, unless o.b is redefined\n\n\t// You cannot try to mix both:\n\tObject.defineProperty(o, 'conflict', {\n\t  value: 0x9f91102,\n\t  get: function() { return 0xdeadbeef; }\n\t});\n\t// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors\n\n##Example: Modifying a property\n\nWhen the property already exists, Object.defineProperty() attempts to modify the property according to the values in the descriptor and the object's current configuration. If the old descriptor had its configurable attribute set to false (the property is said to be â€œnon-configurableâ€), then no attribute besides writable can be changed. In that case, it is also not possible to switch back and forth between the data and accessor property types.\n\nIf a property is non-configurable, its writable attribute can only be changed to false.\n\nA TypeError is thrown when attempts are made to change non-configurable property attributes (besides the writable attribute) unless the current and new values are the same.\n\n##Writable attribute\n\nWhen the writable property attribute is set to false, the property is said to be â€œnon-writableâ€. It cannot be reassigned.\n\n\tvar o = {}; // Creates a new object\n\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: false\n\t});\n\n\tconsole.log(o.a); // logs 37\n\to.a = 25; // No error thrown (it would throw in strict mode, even if the value had been the same)\n\tconsole.log(o.a); // logs 37. The assignment didn't work.\n\nAs seen in the example, trying to write into the non-writable property doesn't change it but doesn't throw an error either.\n\n##Enumerable attribute\n\nThe enumerable property attribute defines whether the property shows up in a for...in loop and Object.keys() or not.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', { value: 1, enumerable: true });\n\tObject.defineProperty(o, 'b', { value: 2, enumerable: false });\n\tObject.defineProperty(o, 'c', { value: 3 }); // enumerable defaults to false\n\to.d = 4; // enumerable defaults to true when creating a property by setting it\n\n\tfor (var i in o) {\n\t  console.log(i);\n\t}\n\t// logs 'a' and 'd' (in undefined order)\n\n\tObject.keys(o); // ['a', 'd']\n\n\to.propertyIsEnumerable('a'); // true\n\to.propertyIsEnumerable('b'); // false\n\to.propertyIsEnumerable('c'); // false\n\tConfigurable attribute\n\n\tThe configurable attribute controls at the same time whether the property can be deleted from the object and whether its attributes (other than writable) can be changed.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', {\n\t  get: function() { return 1; },\n\t  configurable: false\n\t});\n\n\tObject.defineProperty(o, 'a', { configurable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { enumerable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { set: function() {} }); // throws a TypeError (set was undefined previously)\n\tObject.defineProperty(o, 'a', { get: function() { return 1; } }); // throws a TypeError (even though the new get does exactly the same thing)\n\tObject.defineProperty(o, 'a', { value: 12 }); // throws a TypeError\n\n\tconsole.log(o.a); // logs 1\n\tdelete o.a; // Nothing happens\n\tconsole.log(o.a); // logs 1\n\n\nIf the configurable attribute of o.a had been true, none of the errors would be thrown and the property would be deleted at the end.\n\n##Example: Adding properties and default values\n\nIt's important to consider the way default values of attributes are applied. There is often a difference between simply using dot notation to assign a value and using Object.defineProperty(), as shown in the example below.\n\n\tvar o = {};\n\n\to.a = 1;\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: true,\n\t  configurable: true,\n\t  enumerable: true\n\t});\n\n\n\t// On the other hand,\n\tObject.defineProperty(o, 'a', { value: 1 });\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: false,\n\t  configurable: false,\n\t  enumerable: false\n\t});\n\n\n##Example: Custom Setters and Getters\n\nExample below shows how to implement a self-archiving object. When temperature property is set, the archive array gets a log entry.\n\n\tfunction Archiver() {\n\t  var temperature = null;\n\t  var archive = [];\n\n\t  Object.defineProperty(this, 'temperature', {\n\t    get: function() {\n\t      console.log('get!');\n\t      return temperature;\n\t    },\n\t    set: function(value) {\n\t      temperature = value;\n\t      archive.push({ val: temperature });\n\t    }\n\t  });\n\n\t  this.getArchive = function() { return archive; };\n\t}\n\n\tvar arc = new Archiver();\n\tarc.temperature; // 'get!'\n\tarc.temperature = 11;\n\tarc.temperature = 13;\n\tarc.getArchive(); // [{ val: 11 }, { val: 13 }]\t\n\n\n@static\n@param {Object} obj The object on which to define the property.\n@param {String} prop The name of the property to be defined or modified.\n@param {Object} descriptor The descriptor for the property being defined or modified.\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method freeze\n\n#Summary\nThe Object.freeze() method freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen.\n\n#Syntax\nObject.freeze(obj)\n\n#Description\nNothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail, either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode).\n\nValues cannot be changed for data properties. Accessor properties (getters and setters) work the same (and still give the illusion that you are changing the value). Note that values that are objects can still be modified, unless they are also frozen.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.freeze(obj);\n\n\tassert(Object.isFrozen(obj) === true);\n\n\t// Now any changes will fail\n\tobj.foo = 'quux'; // silently does nothing\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors\n\tfunction fail(){\n\t  'use strict';\n\t  obj.foo = 'sparky'; // throws a TypeError\n\t  delete obj.quaxxor; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\n\tfail();\n\n\t// Attempted changes through Object.defineProperty will also throw\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // throws a TypeError\n\tThe following example shows that object values in a frozen object can be mutated (freeze is shallow).\n\n\tobj = {\n\t  internal: {}\n\t};\n\n\tObject.freeze(obj);\n\tobj.internal.a = 'aValue';\n\n\tobj.internal.a // 'aValue'\n\n\t// To make obj fully immutable, freeze each object in obj.\n\t// To do so, we use this function.\n\n\tfunction deepFreeze(o) {\n\t  var prop, propKey;\n\t  Object.freeze(o); // First freeze the object.\n\t  for (propKey in o) {\n\t    prop = o[propKey];\n\t    if (!o.hasOwnProperty(propKey) || !(typeof prop === 'object') || Object.isFrozen(prop)) {\n\t      // If the object is on the prototype, not an object, or is already frozen,\n\t      // skip it. Note that this might leave an unfrozen reference somewhere in the\n\t      // object if there is an already frozen object containing an unfrozen object.\n\t      continue;\n\t    }\n\n\t    deepFreeze(prop); // Recursively call deepFreeze.\n\t  }\n\t}\n\n\tobj2 = {\n\t  internal: {}\n\t};\n\n\tdeepFreeze(obj2);\n\tobj2.internal.a = 'anotherValue';\n\tobj2.internal.a; // undefined\n\n\n@static\n\n@param obj The object to freeze.\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method getOwnPropertyDescriptor\n\n#Summary\nThe Object.getOwnPropertyDescriptor() method returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object.\n\n#Syntax\n\tObject.getOwnPropertyDescriptor(obj, prop)\n\n#Description\nThis method permits examination of the precise description of a property. A property in JavaScript consists of a string-valued name and a property descriptor. Further information about property descriptor types and their attributes can be found in Object.defineProperty().\n\nA property descriptor is a record with some of the following attributes:\n\n###value\nThe value associated with the property (data descriptors only).\n###writable\ntrue if and only if the value associated with the property may be changed (data descriptors only).\n###get\nA function which serves as a getter for the property, or undefined if there is no getter (accessor descriptors only).\n###set\nA function which serves as a setter for the property, or undefined if there is no setter (accessor descriptors only).\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\n\n#Examples\n\n\tvar o, d;\n\n\to = { get foo() { return 17; } };\n\td = Object.getOwnPropertyDescriptor(o, 'foo');\n\t// d is { configurable: true, enumerable: true, get: , set: undefined }\n\n\to = { bar: 42 };\n\td = Object.getOwnPropertyDescriptor(o, 'bar');\n\t// d is { configurable: true, enumerable: true, value: 42, writable: true }\n\n\to = {};\n\tObject.defineProperty(o, 'baz', { value: 8675309, writable: false, enumerable: false });\n\td = Object.getOwnPropertyDescriptor(o, 'baz');\n\t// d is { value: 8675309, writable: false, enumerable: false, configurable: false }\n\n\n@static \n@param {Object}obj The object in which to look for the property.\n@param {String}prop The name of the property whose description is to be retrieved.\n@returns A property descriptor of the given property if it exists on the object, undefined otherwise.\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method getOwnPropertyNames\n\n#Summary\nThe Object.getOwnPropertyNames() method returns an array of all properties (enumerable or not) found directly upon a given object.\n\n#Syntax\nObject.getOwnPropertyNames(obj)\n\n#Description\nObject.getOwnPropertyNames returns an array whose elements are strings corresponding to the enumerable and non-enumerable properties found directly upon obj. The ordering of the enumerable properties in the array is consistent with the ordering exposed by a for...in loop (or by Object.keys) over the properties of the object. The ordering of the non-enumerable properties in the array, and among the enumerable properties, is not defined.\n\n#Examples\n##Example: Using getOwnPropertyNames\n\n\tvar arr = ['a', 'b', 'c'];\n\tprint(Object.getOwnPropertyNames(arr).sort()); // prints '0,1,2,length'\n\n\t// Array-like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tprint(Object.getOwnPropertyNames(obj).sort()); // prints '0,1,2'\n\n\t// Printing property names and values using Array.forEach\n\tObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n\t  print(val + ' -> ' + obj[val]);\n\t});\n\t// prints\n\t// 0 -> a\n\t// 1 -> b\n\t// 2 -> c\n\n\t// non-enumerable property\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: false } });\n\tmy_obj.foo = 1;\n\n\tprint(Object.getOwnPropertyNames(my_obj).sort()); // prints 'foo,getFoo'\n\nIf you want only the enumerable properties, see Object.keys() or use a for...in loop (although note that this will return enumerable properties not found directly upon that object but also along the prototype chain for the object unless the latter is filtered with hasOwnProperty()).\n\nItems on the prototype chain are not listed:\n\n\tfunction ParentClass() {}\n\tParentClass.prototype.inheritedMethod = function() {};\n\n\tfunction ChildClass() {\n\t  this.prop = 5;\n\t  this.method = function() {};\n\t}\n\tChildClass.prototype = new ParentClass;\n\tChildClass.prototype.prototypeMethod = function() {};\n\n\talert(\n\t  Object.getOwnPropertyNames(\n\t    new ChildClass() // ['prop', 'method']\n\t  )\n\t);\n\n##Example: Get Non-Enumerable Only\n\nThis uses the Array.prototype.filter() function to remove the enumerable keys (obtained with Object.keys()) from a list of all keys (obtained with Object.getOwnPropertyNames) leaving only the non-enumerable keys.\n\n\tvar target = myObject;\n\tvar enum_and_nonenum = Object.getOwnPropertyNames(target);\n\tvar enum_only = Object.keys(target);\n\tvar nonenum_only = enum_and_nonenum.filter(function(key) {\n\t  var indexInEnum = enum_only.indexOf(key);\n\t  if (indexInEnum == -1) {\n\t    // not found in enum_only keys mean the key is non-enumerable,\n\t    // so return true so we keep this in the filter\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t});\n\n\tconsole.log(nonenum_only);\n\n@static\n@param {Object} obj The object whose enumerable and non-enumerable own properties are to be returned.\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method isExtensible\n#Summary\nThe Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it).\n\n#Syntax\n\tObject.isExtensible(obj)\n\n#Description\nObjects are extensible by default: they can have new properties added to them, and (in engines that support __proto__  their __proto__ property) can be modified. An object can be marked as non-extensible using Object.preventExtensions(), Object.seal(), or Object.freeze().\n\n#Examples\n\t// New objects are extensible.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Sealed objects are by definition non-extensible.\n\tvar sealed = Object.seal({});\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// Frozen objects are also by definition non-extensible.\n\tvar frozen = Object.freeze({});\n\tassert(Object.isExtensible(frozen) === false);\n\tNotes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n\n\t> Object.isExtensible(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isExtensible(1)\n\tfalse                \n\n@static \n\n@param {Object} obj The object which should be checked.\n@return {boolean}\n*/\n\n\n\n\n/*\n@method isFrozen\n\n#Summary\nThe Object.isFrozen() determines if an object is frozen.\n\n#Syntax\n\tObject.isFrozen(obj)\n\n#Description\nAn object is frozen if and only if it is not extensible, all its properties are non-configurable, and all its data properties (that is, properties which are not accessor properties with getter or setter components) are non-writable.\n\n#Examples\n\t// A new object is extensible, so it is not frozen.\n\tassert(Object.isFrozen({}) === false);\n\n\t// An empty object which is not extensible is vacuously frozen.\n\tvar vacuouslyFrozen = Object.preventExtensions({});\n\tassert(Object.isFrozen(vacuouslyFrozen) === true);\n\n\t// A new object with one property is also extensible, ergo not frozen.\n\tvar oneProp = { p: 42 };\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// Preventing extensions to the object still doesn't make it frozen,\n\t// because the property is still configurable (and writable).\n\tObject.preventExtensions(oneProp);\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// ...but then deleting that property makes the object vacuously frozen.\n\tdelete oneProp.p;\n\tassert(Object.isFrozen(oneProp) === true);\n\n\t// A non-extensible object with a non-writable but still configurable property is not frozen.\n\tvar nonWritable = { e: 'plep' };\n\tObject.preventExtensions(nonWritable);\n\tObject.defineProperty(nonWritable, 'e', { writable: false }); // make non-writable\n\tassert(Object.isFrozen(nonWritable) === false);\n\n\t// Changing that property to non-configurable then makes the object frozen.\n\tObject.defineProperty(nonWritable, 'e', { configurable: false }); // make non-configurable\n\tassert(Object.isFrozen(nonWritable) === true);\n\n\t// A non-extensible object with a non-configurable but still writable property also isn't frozen.\n\tvar nonConfigurable = { release: 'the kraken!' };\n\tObject.preventExtensions(nonConfigurable);\n\tObject.defineProperty(nonConfigurable, 'release', { configurable: false });\n\tassert(Object.isFrozen(nonConfigurable) === false);\n\n\t// Changing that property to non-writable then makes the object frozen.\n\tObject.defineProperty(nonConfigurable, 'release', { writable: false });\n\tassert(Object.isFrozen(nonConfigurable) === true);\n\n\t// A non-extensible object with a configurable accessor property isn't frozen.\n\tvar accessor = { get food() { return 'yum'; } };\n\tObject.preventExtensions(accessor);\n\tassert(Object.isFrozen(accessor) === false);\n\n\t// ...but make that property non-configurable and it becomes frozen.\n\tObject.defineProperty(accessor, 'food', { configurable: false });\n\tassert(Object.isFrozen(accessor) === true);\n\n\t// But the easiest way for an object to be frozen is if Object.freeze has been called on it.\n\tvar frozen = { 1: 81 };\n\tassert(Object.isFrozen(frozen) === false);\n\tObject.freeze(frozen);\n\tassert(Object.isFrozen(frozen) === true);\n\n\t// By definition, a frozen object is non-extensible.\n\tassert(Object.isExtensible(frozen) === false);\n\n\t// Also by definition, a frozen object is sealed.\n\tassert(Object.isSealed(frozen) === true);\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n\n\t> Object.isFrozen(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isFrozen(1)\n\ttrue                          // ES6 code\n\n\n@static\n@param {Object}obj The object which should be checked.\n@returns boolean\n*/\n\n\n\n\n\n/*\n@method isSealed\n\n#Summary\nThe Object.isSealed() method determines if an object is sealed.\n\n#Syntax\n\tObject.isSealed(obj)\n#Description\nReturns true if the object is sealed, otherwise false. An object is sealed if it is not extensible and if all its properties are non-configurable and therefore not removable (but not necessarily non-writable).\n\n#Examples\n\t// Objects aren't sealed by default.\n\tvar empty = {};\n\tassert(Object.isSealed(empty) === false);\n\n\t// If you make an empty object non-extensible, it is vacuously sealed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isSealed(empty) === true);\n\n\t// The same is not true of a non-empty object, unless its properties are all non-configurable.\n\tvar hasProp = { fee: 'fie foe fum' };\n\tObject.preventExtensions(hasProp);\n\tassert(Object.isSealed(hasProp) === false);\n\n\t// But make them all non-configurable and the object becomes sealed.\n\tObject.defineProperty(hasProp, 'fee', { configurable: false });\n\tassert(Object.isSealed(hasProp) === true);\n\n\t// The easiest way to seal an object, of course, is Object.seal.\n\tvar sealed = {};\n\tObject.seal(sealed);\n\tassert(Object.isSealed(sealed) === true);\n\n\t// A sealed object is, by definition, non-extensible.\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// A sealed object might be frozen, but it doesn't have to be.\n\tassert(Object.isFrozen(sealed) === true); // all properties also non-writable\n\n\tvar s2 = Object.seal({ p: 3 });\n\tassert(Object.isFrozen(s2) === false); // 'p' is still writable\n\n\tvar s3 = Object.seal({ get p() { return 0; } });\n\tassert(Object.isFrozen(s3) === true); // only configurability matters for accessor properties\n\n#Notes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n\n\t> Object.isSealed(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isSealed(1)\n\ttrue                          // ES6 code\n\n\n@static\n@param {Object} obj The object which should be checked.\n@returns {boolean}\n*/\n\n\n\n\n\n\n\n/*\n@method keys\n#Summary\nThe Object.keys() method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n#Syntax\n\tObject.keys(obj)\n\n#Examples\n\tvar arr = ['a', 'b', 'c'];\n\tconsole.log(Object.keys(arr)); // console: ['0', '1', '2']\n\n\t// array like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tconsole.log(Object.keys(obj)); // console: ['0', '1', '2']\n\n\t// array like object with random key ordering\n\tvar an_obj = { 100: 'a', 2: 'b', 7: 'c' };\n\tconsole.log(Object.keys(an_obj)); // console: ['2', '7', '100']\n\n\t// getFoo is property which isn't enumerable\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\n\tmy_obj.foo = 1;\n\n\tconsole.log(Object.keys(my_obj)); // console: ['foo']\nIf you want all properties, even not enumerables, see Object.getOwnPropertyNames().\n\n#Polyfill\nTo add compatible Object.keys support in older environments that do not natively support it, copy the following snippet:\n\n\t// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n\tif (!Object.keys) {\n\t  Object.keys = (function() {\n\t    'use strict';\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty,\n\t        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n\t        dontEnums = [\n\t          'toString',\n\t          'toLocaleString',\n\t          'valueOf',\n\t          'hasOwnProperty',\n\t          'isPrototypeOf',\n\t          'propertyIsEnumerable',\n\t          'constructor'\n\t        ],\n\t        dontEnumsLength = dontEnums.length;\n\n\t    return function(obj) {\n\t      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n\t        throw new TypeError('Object.keys called on non-object');\n\t      }\n\n\t      var result = [], prop, i;\n\n\t      for (prop in obj) {\n\t        if (hasOwnProperty.call(obj, prop)) {\n\t          result.push(prop);\n\t        }\n\t      }\n\n\t      if (hasDontEnumBug) {\n\t        for (i = 0; i < dontEnumsLength; i++) {\n\t          if (hasOwnProperty.call(obj, dontEnums[i])) {\n\t            result.push(dontEnums[i]);\n\t          }\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t  }());\n\t}\nPlease note that the above code includes non-enumerable keys in IE7 (and maybe IE8), when passing in an object from a different window.\n\nFor a simple browser polyfill, see Javascript - Object.keys Browser Compatibility.\n\n@static\n@param {Object} obj The object whose enumerable own properties are to be returned.\n@returns {Array<String>} method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n*/\n\n\n\n\n\n\n\n\n/*\n@method preventExtensions\n\n#Summary\nThe Object.preventExtensions() method prevents new properties from ever being added to an object (i.e. prevents future extensions to the object).\n\n#Syntax\n\tObject.preventExtensions(obj)\n\n#Description\nAn object is extensible if new properties can be added to it. Object.preventExtensions() marks an object as no longer extensible, so that it will never have properties beyond the ones it had at the time it was marked as non-extensible. Note that the properties of a non-extensible object, in general, may still be deleted. Attempting to add new properties to a non-extensible object will fail, either silently or by throwing a TypeError (most commonly, but not exclusively, when in strict mode).\n\nObject.preventExtensions() only prevents addition of own properties. Properties can still be added to the object prototype. However, calling Object.preventExtensions() on an object will also prevent extensions on its __proto__  property.\n\nIf there is a way to turn an extensible object to a non-extensible one, there is no way to do the opposite in ECMAScript 5.\n\n#Examples\n\t// Object.preventExtensions returns the object being made non-extensible.\n\tvar obj = {};\n\tvar obj2 = Object.preventExtensions(obj);\n\tassert(obj === obj2);\n\n\t// Objects are extensible by default.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Object.defineProperty throws when adding a new property to a non-extensible object.\n\tvar nonExtensible = { removable: true };\n\tObject.preventExtensions(nonExtensible);\n\tObject.defineProperty(nonExtensible, 'new', { value: 8675309 }); // throws a TypeError\n\n\t// In strict mode, attempting to add new properties to a non-extensible object throws a TypeError.\n\tfunction fail() {\n\t  'use strict';\n\t  nonExtensible.newProperty = 'FAIL'; // throws a TypeError\n\t}\n\tfail();\n\n\t// EXTENSION (only works in engines supporting __proto__\n\t// (which is deprecated. Use Object.getPrototypeOf instead)):\n\t// A non-extensible object's prototype is immutable.\n\tvar fixed = Object.preventExtensions({});\n\tfixed.__proto__ = { oh: 'hai' }; // throws a TypeError\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return it.\n\n\t> Object.preventExtensions(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.preventExtensions(1)\n\t1                             // ES6 code\n\n@static\n@param {Object}obj The object which should be made non-extensible.\n\n*/\n\n\n\n\n\n\n\n/*\n@method hasOwnProperty\n\n#Summary\nThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n#Syntax\n\tobj.hasOwnProperty(prop)\n\n#Description\nEvery object descended from Object inherits the hasOwnProperty method. This method can be used to determine whether an object has the specified property as a direct property of that object; unlike the in operator, this method does not check down the object's prototype chain.\n\n#Examples\n##Example: Using hasOwnProperty to test for a property's existence\n\nThe following example determines whether the o object contains a property named prop:\n\n\to = new Object();\n\to.prop = 'exists';\n\n\tfunction changeO() {\n\t  o.newprop = o.prop;\n\t  delete o.prop;\n\t}\n\n\to.hasOwnProperty('prop');   // returns true\n\tchangeO();\n\to.hasOwnProperty('prop');   // returns false\n\tExample: Direct versus inherited properties\n\n\tThe following example differentiates between direct properties and properties inherited through the prototype chain:\n\n\to = new Object();\n\to.prop = 'exists';\n\to.hasOwnProperty('prop');             // returns true\n\to.hasOwnProperty('toString');         // returns false\n\to.hasOwnProperty('hasOwnProperty');   // returns false\n##Example: Iterating over the properties of an object\n\nThe following example shows how to iterate over the properties of an object without executing on inherit properties. Note that the for...in loop is already only iterating enumerable items, so one should not assume based on the lack of non-enumerable properties shown in the loop that hasOwnProperty itself is confined strictly to enumerable items (as with Object.getOwnPropertyNames()).\n\n\tvar buz = {\n\t  fog: 'stack'\n\t};\n\n\tfor (var name in buz) {\n\t  if (buz.hasOwnProperty(name)) {\n\t    alert('this is fog (' + name + ') for sure. Value: ' + buz[name]);\n\t  }\n\t  else {\n\t    alert(name); // toString or something else\n\t  }\n\t}\n##Example: hasOwnProperty as a property\n\nJavaScript does not protect the property name hasOwnProperty; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an external hasOwnProperty to get correct results:\n\n\tvar foo = {\n\t  hasOwnProperty: function() {\n\t    return false;\n\t  },\n\t  bar: 'Here be dragons'\n\t};\n\n\tfoo.hasOwnProperty('bar'); // always returns false\n\n\t// Use another Object's hasOwnProperty and call it with 'this' set to foo\n\t({}).hasOwnProperty.call(foo, 'bar'); // true\n\n\t// It's also possible to use the hasOwnProperty property from the Object prototype for this purpose\n\tObject.prototype.hasOwnProperty.call(foo, 'bar'); // true\nNote that in the last case there are no newly created objects.\n\n@static \n@param {String}prop The name of the property to test.\n\n*/\n\n\n\n\n\n\n\n/*\n@method  isPrototypeOf\n\n\n#Summary\nThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\nNote: isPrototypeOf differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n#Syntax\n\tprototypeObj.isPrototypeOf(obj)\n#Description\nThe isPrototypeOf method allows you to check whether or not an object exists within another object's prototype chain.\n\nFor example, consider the following prototype chain:\n\n\tfunction Fee() {\n\t  // ...\n\t}\n\n\tfunction Fi() {\n\t  // ...\n\t}\n\tFi.prototype = new Fee();\n\n\tfunction Fo() {\n\t  // ...\n\t}\n\tFo.prototype = new Fi();\n\n\tfunction Fum() {\n\t  // ...\n\t}\n\tFum.prototype = new Fo();\nLater on down the road, if you instantiate Fum and need to check if Fi's prototype exists within the Fum prototype chain, you could do this:\n\n\tvar fum = new Fum();\n\t// ...\n\n\tif (Fi.prototype.isPrototypeOf(fum)) {\n\t  // do something safe\n\t}\nThis, along with the instanceof operator particularly comes in handy if you have code that can only function when dealing with objects descended from a specific prototype chain, e.g., to guarantee that certain methods or properties will be present on that object.\n\n\n@static \n@param {Object} prototypeObj An object to be tested against each link in the prototype chain of the object argument.\n@param {Object}object The object whose prototype chain will be searched.\n@returns {boolean}\n*/\n\n\n\n\n\n\n/*\n\n@method propertyIsEnumerable\n\n#Summary\nThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n#Syntax\n\tobj.propertyIsEnumerable(prop)\n\n#Description\nEvery object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.\n\n#Examples\n##Example: A basic use of propertyIsEnumerable\n\nThe following example shows the use of propertyIsEnumerable on objects and arrays:\n\n\tvar o = {};\n\tvar a = [];\n\to.prop = 'is enumerable';\n\ta[0] = 'is enumerable';\n\n\to.propertyIsEnumerable('prop');   // returns true\n\ta.propertyIsEnumerable(0);        // returns true\n##Example: User-defined versus built-in objects\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n\tvar a = ['is enumerable'];\n\n\ta.propertyIsEnumerable(0);          // returns true\n\ta.propertyIsEnumerable('length');   // returns false\n\n\tMath.propertyIsEnumerable('random');   // returns false\n\tthis.propertyIsEnumerable('Math');     // returns false\n##Example: Direct versus inherited properties\n\n\tvar a = [];\n\ta.propertyIsEnumerable('constructor');         // returns false\n\n\tfunction firstConstructor() {\n\t  this.property = 'is not enumerable';\n\t}\n\n\tfirstConstructor.prototype.firstMethod = function() {};\n\n\tfunction secondConstructor() {\n\t  this.method = function method() { return 'is enumerable'; };\n\t}\n\n\tsecondConstructor.prototype = new firstConstructor;\n\tsecondConstructor.prototype.constructor = secondConstructor;\n\n\tvar o = new secondConstructor();\n\to.arbitraryProperty = 'is enumerable';\n\n\to.propertyIsEnumerable('arbitraryProperty');   // returns true\n\to.propertyIsEnumerable('method');              // returns true\n\to.propertyIsEnumerable('property');            // returns false\n\n\to.property = 'is enumerable';\n\n\to.propertyIsEnumerable('property');            // returns true\n\n\t// These return false as they are on the prototype which \n\t// propertyIsEnumerable does not consider (even though the last two\n\t// are iteratable with for-in)\n\to.propertyIsEnumerable('prototype');   // returns false (as of JS 1.8.1/FF3.6)\n\to.propertyIsEnumerable('constructor'); // returns false\n\to.propertyIsEnumerable('firstMethod'); // returns false\n\n\n@param {String}prop The name of the property to test.\n@return {boolean}\n\n*/\n\n\n\n/*\n@method toLocaleString\n#Summary\nThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n#Syntax\n\tobj.toLocaleString();\n#Description\nObject's toLocaleString returns the result of calling toString().\n\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. See the list below.\n\nObjects overriding toLocaleString\n\n\tArray: Array.prototype.toLocaleString()\n\tNumber: Number.prototype.toLocaleString()\n\tDate: Date.prototype.toLocaleString()\n*/\n\n\n\n/*\n@method toString\n\n#Summary\nThe toString() method returns a string representing object.\n\n#Syntax\n\tobj.toString()\n#Description\nEvery object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected. By default, the toString() method is inherited by every object descended from Object. If this method is not overridden in a custom object, toString() returns \"[object type]\", where type is the object type. The following code illustrates this:\n\n\tvar o = new Object();\n\to.toString();           // returns [object Object]\nNote: Starting in JavaScript 1.8.5 toString() called on null returns [object Null], and undefined returns [object Undefined], as defined in the 5th Edition of ECMAScript and a subsequent Errata. See Using toString to detect object type.\n#Examples\n##Example: Overriding the default toString method\n\nYou can create a function to be called in place of the default toString() method. The toString() method takes no arguments and should return a string. The toString() method you create can be any value you want, but it will be most useful if it carries information about the object.\n\nThe following code defines the Dog object type and creates theDog, an object of type Dog:\n\n\tfunction Dog(name, breed, color, sex) {\n\t  this.name = name;\n\t  this.breed = breed;\n\t  this.color = color;\n\t  this.sex = sex;\n\t}\n\n\ttheDog = new Dog('Gabby', 'Lab', 'chocolate', 'female');\nIf you call the toString() method on this custom object, it returns the default value inherited from Object:\n\n\ttheDog.toString(); // returns [object Object]\nThe following code creates and assigns dogToString() to override the default toString() method. This function generates a string containing the name, breed, color, and sex of the object, in the form \"property = value;\".\n\n\tDog.prototype.toString = function dogToString() {\n\t  var ret = 'Dog ' + this.name + ' is a ' + this.sex + ' ' + this.color + ' ' + this.breed;\n\t  return ret;\n\t}\n\nWith the preceding code in place, any time theDog is used in a string context, JavaScript automatically calls the dogToString() function, which returns the following string:\n\n\tDog Gabby is a female chocolate Lab\n\n##Example: Using toString() to detect object class\n\ntoString() can be used with every object and allows you to get its class. To use the Object.prototype.toString() with every object, you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter called thisArg.\n\n\tvar toString = Object.prototype.toString;\n\n\ttoString.call(new Date);    // [object Date]\n\ttoString.call(new String);  // [object String]\n\ttoString.call(Math);        // [object Math]\n\n\t// Since JavaScript 1.8.5\n\ttoString.call(undefined);   // [object Undefined]\n\ttoString.call(null);        // [object Null]\n\n@return{String}returns a string representing object.\n*/\n\n\n\n\n\n/*\n@method valueOf\n#Summary\nThe valueOf() method returns the primitive value of the specified object.\n\n#Syntax\n\tobject.valueOf()\n#Description\nJavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\n\nBy default, the valueOf method is inherited by every object descended from Object. Every built-in core object overrides this method to return an appropriate value. If an object has no primitive value, valueOf returns the object itself, which is displayed as:\n\n\t[object Object]\nYou can use valueOf within your own code to convert a built-in object into a primitive value. When you create a custom object, you can override Object.prototype.valueOf() to call a custom method instead of the default Object method.\n\n##Overriding valueOf for custom objects\n\nYou can create a function to be called in place of the default valueOf method. Your function must take no arguments.\n\nSuppose you have an object type myNumberType and you want to create a valueOf method for it. The following code assigns a user-defined function to the object's valueOf method:\n\n\tmyNumberType.prototype.valueOf = function() { return customPrimitiveValue; };\nWith the preceding code in place, any time an object of type myNumberType is used in a context where it is to be represented as a primitive value, JavaScript automatically calls the function defined in the preceding code.\n\nAn object's valueOf method is usually invoked by JavaScript, but you can invoke it yourself as follows:\n\n\tmyNumber.valueOf()\nNote: Objects in string contexts convert via the toString() method, which is different from String objects converting to string primitives using valueOf. All objects have a string conversion, if only \"[object type]\". But many objects do not convert to number, boolean, or function.\n#Examples\n##Example: Using valueOf\n\n\to = new Object();\n\tmyVar = o.valueOf();      // [object Object]\n*/\n\n\n\n\n/*\n@method seal\n#Summary\nThe Object.seal() method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.\n\n#Syntax\n\tObject.seal(obj)\n\n#Description\nBy default, objects are extensible (new properties can be added to them). Sealing an object prevents new properties from being added and marks all existing properties as non-configurable. This has the effect of making the set of properties on the object fixed and immutable. Making all properties non-configurable also prevents them from being converted from data properties to accessor properties and vice versa, but it does not prevent the values of data properties from being changed. Attempting to delete or add properties to a sealed object, or to convert a data property to accessor or vice versa, will fail, either silently or by throwing a TypeError (most commonly, although not exclusively, when in strict mode code).\n\nThe prototype chain remains untouched. However, the __proto__  property is sealed as well.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed.\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.seal(obj);\n\n\tassert(o === obj);\n\tassert(Object.isSealed(obj) === true);\n\n\t// Changing property values on a sealed object still works.\n\tobj.foo = 'quux';\n\n\t// But you can't convert data properties to accessors, or vice versa.\n\tObject.defineProperty(obj, 'foo', { get: function() { return 'g'; } }); // throws a TypeError\n\n\t// Now any changes, other than to property values, will fail.\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\tdelete obj.foo; // silently doesn't delete the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors.\n\tfunction fail() {\n\t  'use strict';\n\t  delete obj.foo; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\tfail();\n\n\t// Attempted additions through Object.defineProperty will also throw.\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // changes existing property value\n\n@static \n\n@param  obj The object which should be sealed.\n*/\n\n\n\n\n\n/*\n@class Any\nThis is an artificial type that means 'any value is valid here'\n*/\n\n/*\n\n@module javascript \n\n\n\n@class ObjectPrototype\n\nAdapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\n\n#Description\nThe Object.prototype property represents the Object prototype object.\n\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden (except an Object with a null prototype, i.e. Object.create(null)). For example, other constructors' prototypes override the constructor property and provide their own toString() methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.\n\n#Examples\nSince Javascript doesn't exactly have sub-class objects, prototype is a useful workaround to make a â€œbase classâ€ object of certain functions that act as objects. For example:\n\n\tvar Person = function() {\n\t  this.canTalk = true;\n\t  this.greet = function() {\n\t    if (this.canTalk) {\n\t      console.log('Hi, I'm ' + this.name);\n\t    }\n\t  };\n\t};\n\n\tvar Employee = function(name, title) {\n\t  this.name = name;\n\t  this.title = title;\n\t  this.greet = function() {\n\t    if (this.canTalk) {\n\t      console.log(\"Hi, I'm \" + this.name + \", the \" + this.title);\n\t    }\n\t  };\n\t};\n\tEmployee.prototype = new Person();\n\n\tvar Customer = function(name) {\n\t  this.name = name;\n\t};\n\tCustomer.prototype = new Person();\n\n\tvar Mime = function(name) {\n\t  this.name = name;\n\t  this.canTalk = false;\n\t};\n\tMime.prototype = new Person();\n\n\tvar bob = new Employee('Bob', 'Builder');\n\tvar joe = new Customer('Joe');\n\tvar rg = new Employee('Red Green', 'Handyman');\n\tvar mike = new Customer('Mike');\n\tvar mime = new Mime('Mime');\n\tbob.greet();\n\tjoe.greet();\n\trg.greet();\n\tmike.greet();\n\tmime.greet();\n\nThis will output:\n\n\tHi, I'm Bob, the Builder\n\tHi, I'm Joe\n\tHi, I'm Red Green, the Handyman\n\tHi, I'm Mike\n\n*/\n\n\n\n/*\n\n\n\n@property {Function} constructor Specifies the function that creates an object's prototype.\n\n##Summary\nReturns a reference to the Object function that created the instance's prototype. Note that the value of this property is a reference to the function itself, not a string containing the function's name. The value is only read-only for primitive values such as 1, true and \"test\".\n\n##Description\n\nAll objects inherit a constructor property from their prototype:\n\n\tvar o = {};\n\to.constructor === Object; // true\n\n\tvar a = [];\n\ta.constructor === Array; // true\n\n\tvar n = new Number(3);\n\tn.constructor === Number; // true\n\n##Examples\n\n###Example: Displaying the constructor of an object\n\nThe following example creates a prototype, Tree, and an object of that type, theTree. The example then displays the constructor property for the object theTree.\n\n\tfunction Tree(name) {\n\t  this.name = name;\n\t}\n\n\tvar theTree = new Tree('Redwood');\n\tconsole.log('theTree.constructor is ' + theTree.constructor);\n\tThis example displays the following output:\n\n\ttheTree.constructor is function Tree(name) {\n\t  this.name = name;\n\t}\n\n###Example: Changing the constructor of an object\n\nThe following example shows how to modify constructor value of generic objects. Only true, 1 and \"test\" will not be affected as they have read-only native constructors. This example shows that it is not always safe to rely on the constructor property of an object.\n\n\tfunction Type () {}\n\n\tvar types = [\n\t  new Array(),\n\t  [],\n\t  new Boolean(),\n\t  true,             // remains unchanged\n\t  new Date(),\n\t  new Error(),\n\t  new Function(),\n\t  function () {},\n\t  Math,\n\t  new Number(),\n\t  1,                // remains unchanged\n\t  new Object(),\n\t  {},\n\t  new RegExp(),\n\t  /(?:)/,\n\t  new String(),\n\t  'test'            // remains unchanged\n\t];\n\tfor (var i = 0; i < types.length; i++) {\n\t  types[i].constructor = Type;\n\t  types[i] = [types[i].constructor, types[i] instanceof Type, types[i].toString()];\n\t}\n\tconsole.log(types.join('\\n'));\n\tThis example displays the following output:\n\n\tfunction Type() {},false,\n\tfunction Type() {},false,\n\tfunction Type() {},false,false\n\tfunction Boolean() {\n\t    [native code]\n\t},false,true\n\tfunction Type() {},false,Mon Sep 01 2014 16:03:49 GMT+0600\n\tfunction Type() {},false,Error\n\tfunction Type() {},false,function anonymous() {\n\n\t}\n\tfunction Type() {},false,function () {}\n\tfunction Type() {},false,[object Math]\n\tfunction Type() {},false,0\n\tfunction Number() {\n\t    [native code]\n\t},false,1\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,\n\tfunction String() {\n\t    [native code]\n\t},false,Ñ‚ÐµÑÑ‚\n\n*/\n\n\n\n\n\n\n\n/*\n@property {Object} __proto__ \nPoints to the object which was used as prototype when the object was instantiated.\n\n@property {Function} __noSuchMethod__ \nAllows a function to be defined that will be executed when an undefined object member is called as a method.\n*/\n\n\n\n/* \n@module javascript\n\n@class String\n\n#Summary\nThe String global object is a constructor for strings, or a sequence of characters.\n\n#Syntax\nString literals take the forms:\n\n\t'string text' \"string text\" \"ä¸­æ–‡ espaÃ±ol English à¤¹à¤¿à¤¨à¥à¤¦à¥€ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© portuguÃªs à¦¬à¦¾à¦‚à¦²à¦¾ Ñ€ÑƒÑÑÐºÐ¸Ð¹ æ—¥æœ¬èªž à¨ªà©°à¨œà¨¾à¨¬à©€ í•œêµ­ì–´\"\n\nBeside regular, printable characters, special characters can be encoded using escape notation:\n\n\tCode\tOutput\n\t\\0\tthe NUL character\n\t\\'\tsingle quote\n\t\\\"\tdouble quote\n\t\\\\\tbackslash\n\t\\n\tnew line\n\t\\r\tcarriage return\n\t\\v\tvertical tab\n\t\\t\ttab\n\t\\b\tbackspace\n\t\\f\tform feed\n\t\\uXXXX\tunicode codepoint\n\t\\xXX\tthe Latin-1 character\n\nOr, using the String global object directly:\n\n\tString(thing) new String(thing)\n\n#Description\nStrings are useful for holding data that can be represented in text form. Some of the most-used operations on strings are to check their length, to build and concatenate them using the + and += string operators, checking for the existence or location of substrings with the indexOf method, or extracting substrings with the substring method.\n\n##Character access\n\nThere are two ways to access an individual character in a string. The first is the charAt method:\n\n\treturn 'cat'.charAt(1); // returns \"a\"\n\nThe other way (introduced in ECMAScript 5) is to treat the string as an array-like object, where individual characters correspond to a numerical index:\n\n\treturn 'cat'[1]; // returns \"a\"\n\nFor character access using bracket notation, attempting to delete or assign a value to these properties will not succeed. The properties involved are neither writable nor configurable. (See Object.defineProperty for more information.)\n\n##Comparing strings\n\nC developers have the strcmp() function for comparing strings. In JavaScript, you just use the less-than and greater-than operators:\n\n\tvar a = \"a\";\n\tvar b = \"b\";\n\tif (a < b) // true\n\t  print(a + \" is less than \" + b);\n\telse if (a > b)\n\t  print(a + \" is greater than \" + b);\n\telse\n\t  print(a + \" and \" + b + \" are equal.\");\n\nA similar result can be achieved using the localeCompare method inherited by String instances.\n\n##Distinction between string primitives and String objects\n\nNote that JavaScript distinguishes between String objects and primitive string values. (The same is true of Boolean and Numbers.)\n\nString literals (denoted by double or single quotes) and strings returned from String calls in a non-constructor context (i.e., without using the new keyword) are primitive strings. JavaScript automatically converts primitives to String objects, so that it's possible to use String object methods for primitive strings. In contexts where a method is to be invoked on a primitive string or a property lookup occurs, JavaScript will automatically wrap the string primitive and call the method or perform the property lookup.\n\n\tvar s_prim = \"foo\";\n\tvar s_obj = new String(s_prim);\n\n\tconsole.log(typeof s_prim); // Logs \"string\"\n\tconsole.log(typeof s_obj);  // Logs \"object\"\n\tString primitives and String objects also give different results when using eval. Primitives passed to eval are treated as source code; String objects are treated as all other objects are, by returning the object. For example:\n\n\ts1 = \"2 + 2\";               // creates a string primitive\n\ts2 = new String(\"2 + 2\");   // creates a String object\n\tconsole.log(eval(s1));      // returns the number 4\n\tconsole.log(eval(s2));      // returns the string \"2 + 2\"\n\nFor these reasons, code may break when it encounters String objects when it expects a primitive string instead, although generally authors need not worry about the distinction.\n\nA String object can always be converted to its primitive counterpart with the valueOf method.\n\n\tconsole.log(eval(s2.valueOf())); // returns the number 4\n\nNote: For another possible approach to strings in JavaScript, please read the article about StringView â€“ a C-like representation of strings based on typed arrays.\n\n\n#String generic methods\nThe String instance methods are also available in Firefox as of JavaScript 1.6 (though not part of the ECMAScript standard) on the String object for applying String methods to any object:\n\n\tvar num = 15;\n\talert(String.replace(num, /5/, '2'));\n\nGenerics are also available on Array methods.\n\nThe following is a shim to provide support to non-supporting browsers:\n\n\t//globals define\n\t// Assumes all supplied String instance methods already present\n\t// (one may use shims for these if not available)\n\t(function () {\n\t    'use strict';\n\n\t    var i,\n\t        // We could also build the array of methods with the following, but the\n\t        //   getOwnPropertyNames() method is non-shimable:\n\t        // Object.getOwnPropertyNames(String).filter(function (methodName)\n\t        //  {return typeof String[methodName] === 'function'});\n\t        methods = [\n\t            'quote', 'substring', 'toLowerCase', 'toUpperCase', 'charAt',\n\t            'charCodeAt', 'indexOf', 'lastIndexOf', 'startsWith', 'endsWith',\n\t            'trim', 'trimLeft', 'trimRight', 'toLocaleLowerCase',\n\t            'toLocaleUpperCase', 'localeCompare', 'match', 'search',\n\t            'replace', 'split', 'substr', 'concat', 'slice'\n\t        ],\n\t        methodCount = methods.length,\n\t        assignStringGeneric = function (methodName) {\n\t            var method = String.prototype[methodName];\n\t            String[methodName] = function (arg1) {\n\t                return method.apply(arg1, Array.prototype.slice.call(arguments, 1));\n\t            };\n\t        };\n\n\t    for (i = 0; i < methodCount; i++) {\n\t        assignStringGeneric(methods[i]);\n\t    }\n\t}());\n\n#Examples\n##String conversion\n\nIt's possible to use String as a \"safer\" toString alternative, as although it still normally calls the underlying toString, it also works for null and undefined. For example:\n\n\tvar outputStrings = [];\n\tfor (let i = 0, n = inputValues.length; i < n; ++i) {\n\t  outputStrings.push(String(inputValues[i]));\n\t}\n\n*/\n\n\n\n\n\n\n/*\n@property {Number} length\n\n#Summary\nThe length property represents the length of a string.\n\n#Syntax\n\n\tstr.length\n\n#Description\n\nThis property returns the number of code units in the string. UTF-16, the string format used by JavaScript, uses a single 16-bit code unit to represent the most common characters, but needs to use two code units for less commonly-used characters, so it's possible for the value returned by length to not match the actual number of characters in the string.\n\nFor an empty string, length is 0.\n\nThe static property String.length returns the value 1.\n\n#Examples\n\n\tvar x = \"Mozilla\";\n\tvar empty = \"\";\n\n\tconsole.log(\"Mozilla is \" + x.length + \" code units long\");\n\t// \"Mozilla is 7 code units long\" \n\n\tconsole.log(\"The empty string is has a length of \" + empty.length);\n\t // \"The empty string is has a length of 0\" \n\n*/\n\n\n\n\n/*\n@method fromCharCode\n\n#Summary\nThe static String.fromCharCode() method returns a string created by using the specified sequence of Unicode values.\n\n#Syntax\nString.fromCharCode(num1, ..., numN)\n#Description\nThis method returns a string and not a String object.\n\nBecause fromCharCode is a static method of String, you always use it as String.fromCharCode(), rather than as a method of a String object you created.\n\n#Examples\nExample: Using fromCharCode\n\nThe following example returns the string \"ABC\".\n\n\tString.fromCharCode(65,66,67)\n\n#Getting it to work with higher values\nAlthough most common Unicode values can be represented with one 16-bit number (as expected early on during JavaScript standardization) and fromCharCode() can be used to return a single character for the most common values (i.e., UCS-2 values which are the subset of UTF-16 with the most common characters), in order to deal with ALL legal Unicode values (up to 21 bits), fromCharCode() alone is inadequate. Since the higher code point characters use two (lower value) \"surrogate\" numbers to form a single character, String.fromCodePoint() (part of the ES6 draft) can be used to return such a pair and thus adequately represent these higher valued characters.\n\n@return {String}  returns a string created by using the specified sequence of Unicode values.}\n\n@param p1,...pn A sequence of numbers that are Unicode values\n\n*/\n\n\n\n\n\n\n\n/*\n@method charAt\n\n\n#Summary\nThe charAt() method returns the specified character from a string.\n\n#Syntax\n\tstr.charAt(index)\n#Description\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string called stringName is stringName.length - 1. If the index you supply is out of range, JavaScript returns an empty string.\n\n#Examples\n##Example: Displaying characters at different locations in a string\n\nThe following example displays characters at different locations in the string \"Brave new world\":\n\n\tvar anyString = \"Brave new world\";\n\n\tconsole.log(\"The character at index 0   is '\" + anyString.charAt(0)   + \"'\");\n\tconsole.log(\"The character at index 1   is '\" + anyString.charAt(1)   + \"'\");\n\tconsole.log(\"The character at index 2   is '\" + anyString.charAt(2)   + \"'\");\n\tconsole.log(\"The character at index 3   is '\" + anyString.charAt(3)   + \"'\");\n\tconsole.log(\"The character at index 4   is '\" + anyString.charAt(4)   + \"'\");\n\tconsole.log(\"The character at index 999 is '\" + anyString.charAt(999) + \"'\");\n\nThese lines display the following:\n\n\tThe character at index 0 is 'B'\n\tThe character at index 1 is 'r'\n\tThe character at index 2 is 'a'\n\tThe character at index 3 is 'v'\n\tThe character at index 4 is 'e'\n\tThe character at index 999 is ''\n\n##Example: Getting whole characters\n\nThe following provides a means of ensuring that going through a string loop always provides a whole character, even if the string contains characters that are not in the Basic Multi-lingual Plane.\n\n\tvar str = 'A \\uD87E\\uDC04 Z'; // We could also use a non-BMP character directly\n\tfor (var i=0, chr; i < str.length; i++) {\n\t  if ((chr = getWholeChar(str, i)) === false) {\n\t    continue;\n\t  } // Adapt this line at the top of each loop, passing in the whole string and\n\t    // the current iteration and returning a variable to represent the \n\t    // individual character\n\n\t  alert(chr);\n\t}\n\n\tfunction getWholeChar (str, i) {\n\t  var code = str.charCodeAt(i);     \n\t \n\t  if (isNaN(code)) {\n\t    return ''; // Position not found\n\t  }\n\t  if (code < 0xD800 || code > 0xDFFF) {\n\t    return str.charAt(i);\n\t  }\n\n\t  // High surrogate (could change last hex to 0xDB7F to treat high private\n\t  // surrogates as single characters)\n\t  if (0xD800 <= code && code <= 0xDBFF) { \n\t    if (str.length <= (i+1))  {\n\t      throw 'High surrogate without following low surrogate';\n\t    }\n\t    var next = str.charCodeAt(i+1);\n\t      if (0xDC00 > next || next > 0xDFFF) {\n\t        throw 'High surrogate without following low surrogate';\n\t      }\n\t      return str.charAt(i)+str.charAt(i+1);\n\t  }\n\t  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n\t  if (i === 0) {\n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  var prev = str.charCodeAt(i-1);\n\t  \n\t  // (could change last hex to 0xDB7F to treat high private\n\t  // surrogates as single characters)\n\t  if (0xD800 > prev || prev > 0xDBFF) { \n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  // We can pass over low surrogates now as the second component\n\t  // in a pair which we have already processed\n\t  return false; \n\t}\n\nIn an exclusive JavaScript 1.7+ environment (such as Firefox) which allows destructured assignment, the following is a more succinct and somewhat more flexible alternative in that it does incrementing for an incrementing variable automatically (if the character warrants it in being a surrogate pair).\n\n\tvar str = 'A\\uD87E\\uDC04Z'; // We could also use a non-BMP character directly\n\tfor (var i=0, chr; i < str.length; i++) {\n\t  [chr, i] = getWholeCharAndI(str, i);\n\t  // Adapt this line at the top of each loop, passing in the whole string and\n\t  // the current iteration and returning an array with the individual character\n\t  // and 'i' value (only changed if a surrogate pair)\n\n\t  alert(chr);\n\t}\n\n\tfunction getWholeCharAndI (str, i) {\n\t  var code = str.charCodeAt(i);\n\n\t  if (isNaN(code)) {\n\t    return ''; // Position not found\n\t  }\n\t  if (code < 0xD800 || code > 0xDFFF) {\n\t    return [str.charAt(i), i]; // Normal character, keeping 'i' the same\n\t  }\n\n\t  // High surrogate (could change last hex to 0xDB7F to treat high private \n\t  // surrogates as single characters)\n\t  if (0xD800 <= code && code <= 0xDBFF) { \n\t    if (str.length <= (i+1))  {\n\t      throw 'High surrogate without following low surrogate';\n\t    }\n\t    var next = str.charCodeAt(i+1);\n\t      if (0xDC00 > next || next > 0xDFFF) {\n\t        throw 'High surrogate without following low surrogate';\n\t      }\n\t      return [str.charAt(i)+str.charAt(i+1), i+1];\n\t  }\n\t  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n\t  if (i === 0) {\n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  var prev = str.charCodeAt(i-1);\n\n\t  // (could change last hex to 0xDB7F to treat high private surrogates\n\t  // as single characters)\n\t  if (0xD800 > prev || prev > 0xDBFF) { \n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  // Return the next character instead (and increment)\n\t  return [str.charAt(i+1), i+1]; \n\t}\n\n\n##Example: Fixing charAt to support non-Basic-Multilingual-Plane (BMP) characters\n\nWhile the example above may be more frequently useful for those wishing to support non-BMP characters (since it does not require the caller to know where any non-BMP character might appear), in the event that one does wish, in choosing a character by index, to treat the surrogate pairs within a string as the single characters they represent, one can use the following:\n\n\tfunction fixedCharAt (str, idx) {\n\t  var ret = '';\n\t  str += '';\n\t  var end = str.length;\n\n\t  var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t  while ((surrogatePairs.exec(str)) != null) {\n\t    var li = surrogatePairs.lastIndex;\n\t    if (li - 2 < idx) {\n\t      idx++;\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\n\t  if (idx >= end || idx < 0) {\n\t    return '';\n\t  }\n\n\t  ret += str.charAt(idx);\n\n\t  if (/[\\uD800-\\uDBFF]/.test(ret) && /[\\uDC00-\\uDFFF]/.test(str.charAt(idx+1))) {\n\t    // Go one further, since one of the \"characters\" is part of a surrogate pair\n\t    ret += str.charAt(idx+1); \n\t  }\n\t  return ret;\n\t}\n\n\n@param {Number} index An integer between 0 and 1-less-than the length of the string.\n@return {String} the specified character from a string.\n\n*/\n\n\n\n\n/*\n@method charCodeAt\n\n#Summary\nThe charCodeAt() method returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000).\n\n#Syntax\n\tstr.charCodeAt(index)\n#Description\nUnicode code points range from 0 to 1,114,111. The first 128 Unicode code points are a direct match of the ASCII character encoding. For information on Unicode, see the JavaScript Guide.\n\nNote that charCodeAt will always return a value that is less than 65,536. This is because the higher code points are represented by a pair of (lower valued) \"surrogate\" pseudo-characters which are used to comprise the real character. Because of this, in order to examine or reproduce the full character for individual characters of value 65,536 and above, for such characters, it is necessary to retrieve not only charCodeAt(i), but also charCodeAt(i+1) (as if examining/reproducing a string with two letters). See example 2 and 3 below.\n\ncharCodeAt returns NaN if the given index is not greater than 0 or is greater than the length of the string.\n\nBackward compatibilty: In historic versions (like JavaScript 1.2) the charCodeAt method returns a number indicating the ISO-Latin-1 codeset value of the character at the given index. The ISO-Latin-1 codeset ranges from 0 to 255. The first 0 to 127 are a direct match of the ASCII character set.\n\n#Examples\n##Example: Using charCodeAt\n\nThe following example returns 65, the Unicode value for A.\n\n\t\"ABC\".charCodeAt(0) // returns 65\n\n#Example: Fixing charCodeAt to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is unknown\n\nThis version might be used in for loops and the like when it is unknown whether non-BMP characters exist before the specified index position.\n\n\tfunction fixedCharCodeAt (str, idx) {\n\t    // ex. fixedCharCodeAt ('\\uD800\\uDC00', 0); // 65536\n\t    // ex. fixedCharCodeAt ('\\uD800\\uDC00', 1); // false\n\t    idx = idx || 0;\n\t    var code = str.charCodeAt(idx);\n\t    var hi, low;\n\t    \n\t    // High surrogate (could change last hex to 0xDB7F to treat high\n\t    // private surrogates as single characters)\n\t    if (0xD800 <= code && code <= 0xDBFF) {\n\t        hi = code;\n\t        low = str.charCodeAt(idx+1);\n\t        if (isNaN(low)) {\n\t            throw 'High surrogate not followed by low surrogate in fixedCharCodeAt()';\n\t        }\n\t        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate\n\t        // We return false to allow loops to skip this iteration since should have\n\t        // already handled high surrogate above in the previous iteration\n\t        return false;\n\t        //hi = str.charCodeAt(idx-1);\n\t        //low = code;\n\t        //return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    return code;\n\t}\n\n##Example: Fixing charCodeAt to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is known\n\n\tfunction knownCharCodeAt (str, idx) {\n\t    str += '';\n\t    var code,\n\t        end = str.length;\n\n\t    var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t    while ((surrogatePairs.exec(str)) != null) {\n\t        var li = surrogatePairs.lastIndex;\n\t        if (li - 2 < idx) {\n\t            idx++;\n\t        }\n\t        else {\n\t            break;\n\t        }\n\t    }\n\n\t    if (idx >= end || idx < 0) {\n\t        return NaN;\n\t    }\n\n\t    code = str.charCodeAt(idx);\n\n\t    var hi, low;\n\t    if (0xD800 <= code && code <= 0xDBFF) {\n\t        hi = code;\n\t        low = str.charCodeAt(idx+1);\n\t        // Go one further, since one of the \"characters\" is part of a surrogate pair\n\t        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    return code;\n\t}\n\n\n@param {Number} index\nAn integer greater than or equal to 0 and less than the length of the string; if it is not a number, it defaults to 0.\n\n@returns {Number}returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000).\n\n*/\n\n\n\n\n\n/*\n@method concat\n\n\n#Summary\nThe concat() method combines the text of two or more strings and returns a new string.\n\n#Syntax\n\tstr.concat(string2, string3[, ..., stringN])\n\n#Description\nThe concat function combines the text from one or more strings and returns a new string. Changes to the text in one string do not affect the other string.\n\n#Examples\n##Example: Using concat\n\nThe following example combines strings into a new string.\n\n\tvar hello = \"Hello, \";\n\tconsole.log(hello.concat(\"Kevin\", \" have a nice day.\")); \n\n\t// Hello, Kevin have a nice day. \n\n#Performance\nIt is strongly recommended that assignment operators (+, +=) are used instead of the concat method. See this perfomance test.\n\n@param string2...stringN Strings to concatenate to this string.\n\n@return {String}\n*/\n\n\n\n\n/*\n@method indexOf\n\n#Summary\nThe indexOf() method returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.\n\n#Syntax\n\tstr.indexOf(searchValue[, fromIndex])\n#Description\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character of a string called stringName is stringName.length - 1.\n\n\t\"Blue Whale\".indexOf(\"Blue\");     // returns  0\n\t\"Blue Whale\".indexOf(\"Blute\");    // returns -1\n\t\"Blue Whale\".indexOf(\"Whale\", 0); // returns  5\n\t\"Blue Whale\".indexOf(\"Whale\", 5); // returns  5\n\t\"Blue Whale\".indexOf(\"\", 9);      // returns  9\n\t\"Blue Whale\".indexOf(\"\", 10);     // returns 10\n\t\"Blue Whale\".indexOf(\"\", 11);     // returns 10\n\n##Case-sensitivity\n\nThe indexOf method is case sensitive. For example, the following expression returns -1:\n\n\"Blue Whale\".indexOf(\"blue\") // returns -1\n##Checking occurrences\n\nNote that '0' doesn't evaluate to true and '-1' doesn't evaluate to false. Therefore, when checking if a specific string exists within another string the correct way to check would be:\n\n\"Blue Whale\".indexOf(\"Blue\") != -1; // true\n\"Blue Whale\".indexOf(\"Bloe\") != -1; // false\n\n#Examples\n##Example: Using indexOf and lastIndexOf\n\nThe following example uses indexOf and lastIndexOf to locate values in the string \"Brave new world\".\n\n\tvar anyString = \"Brave new world\";\n\n\tconsole.log(\"The index of the first w from the beginning is \" + anyString.indexOf(\"w\"));\n\t// Displays 8\n\tconsole.log(\"The index of the first w from the end is \" + anyString.lastIndexOf(\"w\")); \n\t// Displays 10\n\n\tconsole.log(\"The index of 'new' from the beginning is \" + anyString.indexOf(\"new\"));   \n\t// Displays 6\n\tconsole.log(\"The index of 'new' from the end is \" + anyString.lastIndexOf(\"new\"));\n\t// Displays 6\n##Example: indexOf and case-sensitivity\n\nThe following example defines two string variables. The variables contain the same string except that the second string contains uppercase letters. The first log method displays 19. But because the indexOf method is case sensitive, the string \"cheddar\" is not found in myCapString, so the second log method displays -1.\n\n\tvar myString    = \"brie, pepper jack, cheddar\";\n\tvar myCapString = \"Brie, Pepper Jack, Cheddar\";\n\n\tconsole.log('myString.indexOf(\"cheddar\") is ' + myString.indexOf(\"cheddar\"));    \n\t// Displays 19\n\tconsole.log('myCapString.indexOf(\"cheddar\") is ' + myCapString.indexOf(\"cheddar\")); \n\t// Displays -1\n##Example: Using indexOf to count occurrences of a letter in a string\n\nThe following example sets count to the number of occurrences of the letter x in the string str:\n\n\tcount = 0;\n\tpos = str.indexOf(\"x\");\n\n\twhile ( pos != -1 ) {\n\t   count++;\n\t   pos = str.indexOf( \"x\",pos + 1 );\n\t}\n\n\n@param {String} searchValue A string representing the value to search for.\n@param {Number} fromIndex The location within the calling string to start the search from. It can be any integer. The default value is 0. If fromIndex < 0 the entire string is searched (same as passing 0). If fromIndex >= str.length, the method will return -1 unless searchValue is an empty string in which case str.length is returned. \n@optional\n@returns {Number} the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.\n*/\n\n\n//@module Backbone\n\n/*\n@class BackboneEvents\n\nEvents is a module that can be mixed in to any object, giving the object the ability to bind and trigger custom named events. Events do not have to be declared before they are bound, and may take passed arguments. For example:\n\n\tvar object = {};\n\n\t_.extend(object, Backbone.Events);\n\n\tobject.on(\"alert\", function(msg) {\n\t  alert(\"Triggered \" + msg);\n\t});\n\n\tobject.trigger(\"alert\", \"an event\");\n\t\nFor example, to make a handy event dispatcher that can coordinate events among different areas of your application: var dispatcher = _.clone(Backbone.Events)\n\n\n#Catalog of Events \nHere's the complete list of built-in Backbone events, with arguments. You're also free to trigger your own events on Models, Collections and Views as you see fit. The Backbone object itself mixes in Events, and can be used to emit any global events that your application needs.\n\n\t\"add\" (model, collection, options) â€” when a model is added to a collection.\n\t\"remove\" (model, collection, options) â€” when a model is removed from a collection.\n\t\"reset\" (collection, options) â€” when the collection's entire contents have been replaced.\n\t\"sort\" (collection, options) â€” when the collection has been re-sorted.\n\t\"change\" (model, options) â€” when a model's attributes have changed.\n\t\"change:[attribute]\" (model, value, options) â€” when a specific attribute has been updated.\n\t\"destroy\" (model, collection, options) â€” when a model is destroyed.\n\t\"request\" (model_or_collection, xhr, options) â€” when a model or collection has started a request to the server.\n\t\"sync\" (model_or_collection, resp, options) â€” when a model or collection has been successfully synced with the server.\n\t\"error\" (model_or_collection, resp, options) â€” when model's or collection's request to remote server has failed.\n\t\"invalid\" (model, error, options) â€” when a model's validation fails on the client.\n\t\"route:[name]\" (params) â€” Fired by the router when a specific route is matched.\n\t\"route\" (route, params) â€” Fired by the router when any route has been matched.\n\t\"route\" (router, route, params) â€” Fired by history when any route has been matched.\n\t\"all\" â€” this special event fires for any triggered event, passing the event name as the first argument.\nGenerally speaking, when calling a function that emits an event (model.set, collection.add, and so on...), if you'd like to prevent the event from being triggered, you may pass {silent: true} as an option. Note that this is rarely, perhaps even never, a good idea. Passing through a specific flag in the options for your event callback to look at, and choose to ignore, will usually work out better.\n\n\n*/\n\n\n\n/*\n@method bind\n\nAlias on\n\nBind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or \"change:selection\". The event string may also be a space-delimited list of several events...\n\n\tbook.on(\"change:title change:author\", ...);\n\nTo supply a context value for this when the callback is invoked, pass the optional third argument: model.on('change', this.render, this)\n\nCallbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another:\n\n\tproxy.on(\"all\", function(eventName) {\n\t  object.trigger(eventName);\n\t});\nAll Backbone event methods also support an event map syntax, as an alternative to positional arguments:\n\n\tbook.on({\n\t  \"change:title\": titleView.update,\n\t  \"change:author\": authorPane.update,\n\t  \"destroy\": bookView.remove\n\t});\n\n@param {String} event\n@param {Function} callback\n@param {Object} context optional\n*/\n\n\n\n/*\n@method off\nRemove a previously-bound callback function from an object. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed.\n\n\t// Removes just the `onChange` callback.\n\tobject.off(\"change\", onChange);\n\n\t// Removes all \"change\" callbacks.\n\tobject.off(\"change\");\n\n\t// Removes the `onChange` callback for all events.\n\tobject.off(null, onChange);\n\n\t// Removes all callbacks for `context` for all events.\n\tobject.off(null, null, context);\n\n\t// Removes all callbacks on `object`.\n\tobject.off();\nNote that calling model.off(), for example, will indeed remove all events on the model â€” including events that Backbone uses for internal bookkeeping.\n*/\n\n\n\n/*@method trigger\nTrigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be passed along to the event callbacks.\n*/\n\n\n\n/*@method once\nJust like on, but causes the bound callback to only fire once before being removed. Handy for saying \"the next time that X happens, do this\".\n@param {String}event\n@param {Function} callback\n*/\n\n\n/*\n@method listenTo\n\nTell an object to listen to a particular event on an other object. The advantage of using this form, instead of other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can be removed all at once later on. The callback will always be called with object as context.\n\n\tview.listenTo(model, 'change', view.render);\n\n@param {BackboneEvents} other\n@param {String} event\n@param {Function} calback\n*/\n\n\n\n/*\n@method stopListening\n\nTell an object to stop listening to events. Either call stopListening with no arguments to have the object remove all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to on a specific object, or a specific event, or just a specific callback.\n\n\tview.stopListening();\n\n\tview.stopListening(model);\n\n\n@param {BackboneEvents} other optional\n@param {String} event optional\n@param {Function} calback optional\n\n*/\n\n\n/*@method listenToOnce\nJust like listenTo, but causes the bound callback to only fire once before being removed.\n*/\n\n/*\n@module Backbone\n@class BackboneModel \n\n\nModels are the heart of any JavaScript application, containing the interactive data as well as a large part of the logic surrounding it: conversions, validations, computed properties, and access control. You extend Backbone.Model with your domain-specific methods, and Model provides a basic set of functionality for managing changes.\n\nThe following is a contrived example, but it demonstrates defining a model with a custom method, setting an attribute, and firing an event keyed to changes in that specific attribute. After running this code once, sidebar will be available in your browser's console, so you can play around with it.\n\n\tvar Sidebar = Backbone.Model.extend({\n\t  promptColor: function() {\n\t    var cssColor = prompt(\"Please enter a CSS color:\");\n\t    this.set({color: cssColor});\n\t  }\n\t});\n\n\twindow.sidebar = new Sidebar;\n\n\tsidebar.on('change:color', function(model, color) {\n\t  $('#sidebar').css({background: color});\n\t});\n\n\tsidebar.set({color: 'white'});\n\n\tsidebar.promptColor();\n\n@extends BackboneEvents\n\n*/\n\n\n\n\n/*\n@method extend\n\nTo create a Model class of your own, you extend Backbone.Model and provide instance properties, as well as optional classProperties to be attached directly to the constructor function.\n\nextend correctly sets up the prototype chain, so subclasses created with extend can be further extended and subclassed as far as you like.\n\n\tvar Note = Backbone.Model.extend({\n\n\t  initialize: function() { ... },\n\n\t  author: function() { ... },\n\n\t  coordinates: function() { ... },\n\n\t  allowedToEdit: function(account) {\n\t    return true;\n\t  }\n\n\t});\n\n\tvar PrivateNote = Note.extend({\n\n\t  allowedToEdit: function(account) {\n\t    return account.owns(this);\n\t  }\n\n\t});\n\n#super\n\nBrief aside on super: JavaScript does not provide a simple way to call super â€” the function of the same name defined higher on the prototype chain. If you override a core function like set, or save, and you want to invoke the parent object's implementation, you'll have to explicitly call it, along these lines:\n\n\tvar Note = Backbone.Model.extend({\n\t  set: function(attributes, options) {\n\t    Backbone.Model.prototype.set.apply(this, arguments);\n\t    ...\n\t  }\n\t});\n\n\n\n@static\n@param {Object} properties\n@param {Object} classProperties\n*/\n\n\n\n/*\n@method initialize\n\nUse like this:\n\n\tnew Model([attributes], [options]) \n\nWhen creating an instance of a model, you can pass in the initial values of the attributes, which will be set on the model. If you define an initialize function, it will be invoked when the model is created.\n\n\tnew Book({\n\t  title: \"One Thousand and One Nights\",\n\t  author: \"Scheherazade\"\n\t});\nIn rare cases, if you're looking to get fancy, you may want to override constructor, which allows you to replace the actual constructor function for your model.\n\n\tvar Library = Backbone.Model.extend({\n\t  constructor: function() {\n\t    this.books = new Books();\n\t    Backbone.Model.apply(this, arguments);\n\t  },\n\t  parse: function(data, options) {\n\t    this.books.reset(data.books);\n\t    return data.library;\n\t  }\n\t});\nIf you pass a {collection: ...} as the options, the model gains a collection property that will be used to indicate which collection the model belongs to, and is used to help compute the model's url. The model.collection property is normally created automatically when you first add a model to a collection. Note that the reverse is not true, as passing this option to the constructor will not automatically add the model to the collection. Useful, sometimes.\n\nIf {parse: true} is passed as an option, the attributes will first be converted by parse before being set on the model.\n\n*/\n\n\n\n/*@method get\nGet the current value of an attribute from the model. For example: note.get(\"title\")\n@param {String} name the property name to get\n@returns {Any} the value of the property\n*/\n\n\n\n\n/*\n@method set\n\nSet a hash of attributes (one or many) on the model. If any of the attributes change the model's state, a \"change\" event will be triggered on the model. Change events for specific attributes are also triggered, and you can bind to those as well, for example: change:title, and change:content. You may also pass individual keys and values.\n\n\tnote.set({title: \"March 20\", content: \"In his eyes she eclipses...\"});\n\n\tbook.set(\"title\", \"A Scandal in Bohemia\");\n\n@param {String} name\n@param {Any} value\n@param {Object} options Optional\n*/\n\n\n\n\n/*\n@method escape\n\nSimilar to get, but returns the HTML-escaped version of a model's attribute. If you're interpolating data from the model into HTML, using escape to retrieve attributes will prevent XSS attacks.\n\n\tvar hacker = new Backbone.Model({\n\t  name: \"<script>alert('xss')</script>\"\n\t});\n\n\talert(hacker.escape('name'));\n*/\n\n\n/*\n@method has\nReturns true if the attribute is set to a non-null or non-undefined value.\n\n\tif (note.has(\"title\")) {\n\t  ...\n\t}\n\n@param {String} name\n*/\n\n\n/*\n@method unset\nRemove an attribute by deleting it from the internal attributes hash. Fires a \"change\" event unless silent is passed as an option.\n@param {String}attribute\n@param {Object} options Optional\n*/\n\n\n\n\n/*\n@method clear\n\nRemoves all attributes from the model, including the id attribute. Fires a \"change\" event unless silent is passed as an option.\n\n@param {Object} options Optional\n*/\n\n\n/*\n@property {String} id \n\nA special property of models, the id is an arbitrary string (integer id or UUID). If you set the id in the attributes hash, it will be copied onto the model as a direct property. Models can be retrieved by id from collections, and the id is used to generate model URLs by default.\n*/\n\n\n\n/*\n@property {String} idAttribute\nA model's unique identifier is stored under the id attribute. If you're directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Model's idAttribute to transparently map from that key to id.\n\n\tvar Meal = Backbone.Model.extend({\n\t  idAttribute: \"_id\"\n\t});\n\n\tvar cake = new Meal({ _id: 1, name: \"Cake\" });\n\talert(\"Cake id: \" + cake.id);\n*/\n\n\n\n/*\n@property {String} cid \n\nA special property of models, the cid or client id is a unique identifier automatically assigned to all models when they're first created. Client ids are handy when the model has not yet been saved to the server, and does not yet have its eventual true id, but already needs to be visible in the UI.\n*/\n\n\n\n/*@property {Object}attributes\nThe attributes property is the internal hash containing the model's state â€” usually (but not necessarily) a form of the JSON object representing the model data on the server. It's often a straightforward serialization of a row from the database, but it could also be client-side computed state.\n\nPlease use set to update the attributes instead of modifying them directly. If you'd like to retrieve and munge a copy of the model's attributes, use _.clone(model.attributes) instead.\n\nDue to the fact that Events accepts space separated lists of events, attribute names should not include spaces.\n*/\n\n\n\n\n\n/*\n@property{Object}changed\nThe changed property is the internal hash containing all the attributes that have changed since the last set. Please do not update changed directly since its state is internally maintained by set. A copy of changed can be acquired from changedAttributes.\n*/\n\n\n\n/*\n@property{Object}defaults\nThe defaults hash (or function) can be used to specify the default attributes for your model. When creating an instance of the model, any unspecified attributes will be set to their default value.\n\n\tvar Meal = Backbone.Model.extend({\n\t  defaults: {\n\t    \"appetizer\":  \"caesar salad\",\n\t    \"entree\":     \"ravioli\",\n\t    \"dessert\":    \"cheesecake\"\n\t  }\n\t});\n\n\talert(\"Dessert will be \" + (new Meal).get('dessert'));\nRemember that in JavaScript, objects are passed by reference, so if you include an object as a default value, it will be shared among all instances. Instead, define defaults as a function.\n*/\n\n\n\n\n\n\n\n/*\n@method toJSON \nReturn a shallow copy of the model's attributes for JSON stringification. This can be used for persistence, serialization, or for augmentation before being sent to the server. The name of this method is a bit confusing, as it doesn't actually return a JSON string â€” but I'm afraid that it's the way that the JavaScript API for JSON.stringify works.\n\n\tvar artist = new Backbone.Model({\n\t  firstName: \"Wassily\",\n\t  lastName: \"Kandinsky\"\n\t});\n\n\tartist.set({birthday: \"December 16, 1866\"});\n\n\talert(JSON.stringify(artist));\n\n@param {Object} options Optional\n@return {String}\n*/\n\n\n\n\n/*\n@method sync\nUses Backbone.sync to persist the state of a model to the server. Can be overridden for custom behavior.\n@param {String} method\n@param {BackboneModel} model\n@param {Object} options Optional\n@static\n*/\n\n\n\n\n/*\n@method fetch\n\nResets the model's state from the server by delegating to Backbone.sync. Returns a jqXHR. Useful if the model has never been populated with data, or if you'd like to ensure that you have the latest server state. A \"change\" event will be triggered if the server's state differs from the current attributes. Accepts success and error callbacks in the options hash, which are both passed (model, response, options) as arguments.\n\n\t// Poll every 10 seconds to keep the channel model up-to-date.\n\tsetInterval(function() {\n\t  channel.fetch();\n\t}, 10000);\n\n@param {Object} options Optional\n*/\n\n\n\n\n/*\n@method\n*/\n\n/*\n@module Backbone\n\n#About\nBackbone.js gives structure to web applications by providing models with key-value binding and custom events, collections with a rich API of enumerable functions, views with declarative event handling, and connects it all to your existing API over a RESTful JSON interface.\n\nThe project is hosted on GitHub, and the annotated source code is available, as well as an online test suite, an example application, a list of tutorials and a long list of real-world projects that use Backbone. Backbone is available for use under the MIT software license.\n\nYou can report bugs and discuss features on the GitHub issues page, on Freenode IRC in the #documentcloud channel, post questions to the Google Group, add pages to the wiki or send tweets to @documentcloud.\n\nBackbone is an open-source component of DocumentCloud.\n\n#Dependencies\nBackbone's only hard dependency is Underscore.js ( >= 1.5.0). For RESTful persistence, history support via Backbone.Router and DOM manipulation with Backbone.View, include jQuery, and json2.js for older Internet Explorer support. (Mimics of the Underscore and jQuery APIs, such as Lo-Dash and Zepto, will also tend to work, with varying degrees of compatibility.)\n\n#Introduction\n\nWhen working on a web application that involves a lot of JavaScript, one of the first things you learn is to stop tying your data to the DOM. It's all too easy to create JavaScript applications that end up as tangled piles of jQuery selectors and callbacks, all trying frantically to keep data in sync between the HTML UI, your JavaScript logic, and the database on your server. For rich client-side applications, a more structured approach is often helpful.\n\nWith Backbone, you represent your data as Models, which can be created, validated, destroyed, and saved to the server. Whenever a UI action causes an attribute of a model to change, the model triggers a \"change\" event; all the Views that display the model's state can be notified of the change, so that they are able to respond accordingly, re-rendering themselves with the new information. In a finished Backbone app, you don't have to write the glue code that looks into the DOM to find an element with a specific id, and update the HTML manually â€” when the model changes, the views simply update themselves.\n\nPhilosophically, Backbone is an attempt to discover the minimal set of data-structuring (models and collections) and user interface (views and URLs) primitives that are generally useful when building web applications with JavaScript. In an ecosystem where overarching, decides-everything-for-you frameworks are commonplace, and many libraries require your site to be reorganized to suit their look, feel, and default behavior â€” Backbone should continue to be a tool that gives you the freedom to design the full experience of your web application.\n\nIf you're new here, and aren't yet quite sure what Backbone is for, start by browsing the list of Backbone-based projects.\n\n*/\n\n//@class BackboneView\n//@property {jQuery} $el\n//@property {jQuery} $\n//@property {HTMLElement} el\n//@method render\n\n//@class BackboneRouter\n//@class BackboneModel\n\n/*@module html \n\n\n@class HTMLElement @extends XMLNode\n\n#Events \n\nTaken from http://www.w3schools.com/tags/ref_eventattributes.asp\n\nHTML 4 added the ability to let events trigger actions in a browser, like starting a JavaScript when a user clicks on an element.\n\n\n\n\n\n@event onafterprint\t\tScript to be run after the document is printed\n\n@event onbeforeprint\tScript to be run before the document is printed. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onbeforeunload\t\tScript to be run when the document is about to be unloaded. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onerror\t\tScript to be run when an error occur. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onhashchange\t\tScript to be run when there has been changes to the anchor part of the a URL. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onload\t\tFires after the page is finished loading. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onmessage\t\tScript to be run when the message is triggered. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onoffline\t\tScript to be run when the browser starts to work offline. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event ononline\t\tScript to be run when the browser starts to work online. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onpagehide\t\tScript to be run when a user navigates away from a page. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onpageshow\t\tScript to be run when a user navigates to a page. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onpopstate\t\tScript to be run when the window's history changes. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onresize\t\tFires when the browser window is resized. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onstorage\t\tScript to be run when a Web Storage area is updated. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n@event onunload\t\tFires once a page has unloaded (or the browser window has been closed). Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5\n\n\n\n\n\n\n\n@event onblur\tFires the moment that the element loses focus. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n@event onchange\tFires the moment when the value of the element is changed. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n@event oncontextmenu\t\tScript to be run when a context menu is triggered. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n@event onfocus\t\tFires the moment when the element gets focus. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n@event oninput\t\tScript to be run when an element gets user input. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n@event oninvalid\t\tScript to be run when an element is invalid. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n@event onreset\t\tFires when the Reset button in a form is clicked. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n@event onsearch\t\tFires when the user writes something in a search field (for <input=\"search\">). Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n@event onselect\t\tFires after some text has been selected in an element. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n@event onsubmit\tscript\tFires when a form is submitted. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)\n\n\n\n\n\n\n@event onkeydown\t\tFires when a user is pressing a key. This is a Keyboard Event\n@event onkeypress\t\tFires when a user presses a key. This is a Keyboard Event\n@event onkeyup\t\tFires when a user releases a key. This is a Keyboard Event\n\n\n\n\n\n\n\n\n@event onclick\tscript\tFires on a mouse click on the element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event ondblclick\tscript\tFires on a mouse double-click on the element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event ondrag\tscript\tScript to be run when an element is dragged. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event ondragend\tscript\tScript to be run at the end of a drag operation. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event ondragenter\tscript\tScript to be run when an element has been dragged to a valid drop target. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event ondragleave\tscript\tScript to be run when an element leaves a valid drop target. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event ondragover\tscript\tScript to be run when an element is being dragged over a valid drop target. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event ondragstart\tscript\tScript to be run at the start of a drag operation. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event ondrop\tscript\tScript to be run when dragged element is being dropped. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event onmousedown\tscript\tFires when a mouse button is pressed down on an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event onmousemove\tscript\tFires when the mouse pointer is moving while it is over an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event onmouseout\tscript\tFires when the mouse pointer moves out of an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event onmouseover\tscript\tFires when the mouse pointer moves over an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event onmouseup\tscript\tFires when a mouse button is released over an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event onmousewheel\tscript\tDeprecated. Use the onwheel attribute instead. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event onscroll\tscript\tScript to be run when an element's scrollbar is being scrolled. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n@event onwheel\tscript\tFires when the mouse wheel rolls up or down over an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions\n\n*/\n\n/*\n@module jquery\n\n@class jQueryDeferred\n\nThe Deferred object, introduced in jQuery 1.5, is a chainable utility object created by calling the jQuery.Deferred() method. It can register multiple callbacks into callback queues, invoke callback queues, and relay the success or failure state of any synchronous or asynchronous function.\n\nThe Deferred object is chainable, similar to the way a jQuery object is chainable, but it has its own methods. After creating a Deferred object, you can use any of the methods below by either chaining directly from the object creation or saving the object in a variable and invoking one or more methods on that variable.\n\n*/\n\n/*\n@constructor jQuery.Deferred\n\n##Description\n\nA constructor function that returns a chainable utility object with methods to register multiple callbacks into callback queues, invoke callback queues, and relay the success or failure state of any synchronous or asynchronous function.\n\nThe jQuery.Deferred method can be passed an optional function, which is called just before the constructor returns and is passed the constructed deferred object as both the this object and as the first argument to the function. The called function can attach callbacks using deferred.then(), for example.\n\nA Deferred object starts in the pending state. Any callbacks added to the object with deferred.then(), deferred.always(), deferred.done(), or deferred.fail() are queued to be executed later. Calling deferred.resolve() or deferred.resolveWith() transitions the Deferred into the resolved state and immediately executes any doneCallbacks that are set. Calling deferred.reject() or deferred.rejectWith() transitions the Deferred into the rejected state and immediately executes any failCallbacks that are set. Once the object has entered the resolved or rejected state, it stays in that state. Callbacks can still be added to the resolved or rejected Deferred â€” they will execute immediately.\n\n##Enhanced Callbacks with jQuery Deferred\n\nIn JavaScript it is common to invoke functions that optionally accept callbacks that are called within that function. For example, in versions prior to jQuery 1.5, asynchronous processes such as jQuery.ajax() accept callbacks to be invoked some time in the near-future upon success, error, and completion of the ajax request.\n\njQuery.Deferred() introduces several enhancements to the way callbacks are managed and invoked. In particular, jQuery.Deferred() provides flexible ways to provide multiple callbacks, and these callbacks can be invoked regardless of whether the original callback dispatch has already occurred. jQuery Deferred is based on the CommonJS Promises/A design.\n\nOne model for understanding Deferred is to think of it as a chain-aware function wrapper. The deferred.then(), deferred.always(), deferred.done(), and deferred.fail() methods specify the functions to be called and the deferred.resolve(args) or deferred.reject(args) methods \"call\" the functions with the arguments you supply. Once the Deferred has been resolved or rejected it stays in that state; a second call to deferred.resolve(), for example, is ignored. If more functions are added by deferred.then(), for example, after the Deferred is resolved, they are called immediately with the arguments previously provided.\n\nIn most cases where a jQuery API call returns a Deferred or Promise-compatible object, such as jQuery.ajax() or jQuery.when(), you will only want to use the deferred.then(), deferred.done(), and deferred.fail() methods to add callbacks to the Deferred's queues. The internals of the API call or code that created the Deferred will invoke deferred.resolve() or deferred.reject() on the deferred at some point, causing the appropriate callbacks to run.\n\n\n@param {Function}beforeStart Optional\nType: Function( Deferred deferred )\nA function that is called just before the constructor returns.\nThe jQuery.Deferred() constructor creates a new Deferred object. The new operator is optional.\n\n*/\n\n\n\n\n\n/*\n@method always\n\nUsage:\n\tdeferred.always( alwaysCallbacks [, alwaysCallbacks ] )\n\nDescription: Add handlers to be called when the Deferred object is either resolved or rejected.\n\nThe argument can be either a single function or an array of functions. When the Deferred is resolved or rejected, the alwaysCallbacks are called. Since deferred.always() returns the Deferred object, other methods of the Deferred object can be chained to this one, including additional .always() methods. When the Deferred is resolved or rejected, callbacks are executed in the order they were added, using the arguments provided to the resolve, reject, resolveWith or rejectWith method calls. For more information, see the documentation for Deferred object.\n\nExample:\nSince the jQuery.get() method returns a jqXHR object, which is derived from a Deferred object, we can attach a callback for both success and error using the deferred.always() method.\n\n\t$.get( \"test.php\" ).always(function() {\n\t  alert( \"$.get completed with success or error callback arguments\" );\n\t})\n\n@param {Function|Array<Function>} alwaysCallbacks A function, or array of functions, that is called when the Deferred is resolved or rejected.\n\n*/\n\n/*\n@module jquery\n@class jQuery\n*/\n\n\n\n/*@module xml.dom\n@class XMLDocument\n\nXML DOM - The Document Object\n\nThe Document object represents the entire XML document.\n\nThe Document object is the root of a document tree, and gives us the primary access to the document's data.\n\nSince element nodes, text nodes, comments, processing instructions, etc. cannot exist outside the document, the Document object also contains methods to create these objects. The Node objects have a ownerDocument property which associates them with the Document where they were created.\n\n\n\n\n\n@property async\tSpecifies whether downloading of an XML file should be handled asynchronously or not\n@property childNodes\tReturns a NodeList of child nodes for the document\n@property doctype\tReturns the Document Type Declaration associated with the document\n@property documentElement\tReturns the root node of the document\n@property documentURI\tSets or returns the location of the document\n@property domConfig\tReturns the configuration used when normalizeDocument() is invoked\n@property firstChild\tReturns the first child node of the document\n@property implementation\tReturns the DOMImplementation object that handles this document\n@property inputEncoding\tReturns the encoding used for the document (when parsing)\n@property lastChild\tReturns the last child node of the document\n@property nodeName\tReturns the name of a node (depending on its type)\n@property nodeType\tReturns the node type of a node\n@property nodeValue\tSets or returns the value of a node (depending on its type)\n@property strictErrorChecking\tSets or returns whether error-checking is enforced or not\n@property xmlEncoding\tReturns the XML encoding of the document\n@property xmlStandalone\tSets or returns whether the document is standalone\n@property xmlVersion\tSets or returns the XML version of the document\n\n\n@method adoptNode(sourcenode)\tAdopts a node from another document to this document, and returns the adopted node\n@method createAttribute(name)\tCreates an attribute node with the specified name, and returns the new Attr object\n@method createAttributeNS(uri,name)\tCreates an attribute node with the specified name and namespace, and returns the new Attr object\n@method createCDATASection()\tCreates a CDATA section node\n@method createComment()\tCreates a comment node\n@method createDocumentFragment()\tCreates an empty DocumentFragment object, and returns it\n@method createElement()\tCreates an element node\n@method createElementNS()\tCreates an element node with a specified namespace\n@method createEntityReference(name)\tCreates an EntityReference object, and returns it\n@method createProcessingInstruction(target,data)\tCreates a ProcessingInstruction object, and returns it\n@method createTextNode()\tCreates a text node\n@method getElementById(id)\tReturns the element that has an ID attribute with the given value. If no such element exists, it returns null\n@method getElementsByTagName()\tReturns a NodeList of all elements with a specified name\n@method getElementsByTagNameNS()\tReturns a NodeList of all elements with a specified name and namespace\n@method importNode(nodetoimport,deep)\tImports a node from another document to this document. This method creates a new copy of the source node. If the deep parameter is set to true, it imports all children of the specified node. If set to false, it imports only the node itself. This method returns the imported node\n@method normalizeDocument()\t \n@method renameNode()\tRenames an element or attribute node\n\n\n\n*/\n\n\n\n\n\n/*\n@class XMLDocumentType\n\nThe DocumentType object. \nEach document has a DOCTYPE attribute that whose value is either null or a DocumentType object.\n\nThe DocumentType object provides an interface to the entities defined for an XML document.\n\n@property entities\tReturns a NamedNodeMap containing the entities declared in the DTD\n@property internalSubset\tReturns the internal DTD as a string\n@property name\tReturns the name of the DTD\n@property notations\tReturns a NamedNodeMap containing the notations declared in\tthe DTD\n@property systemId\tReturns the system identifier of the external DTD\n*/\n\n/*\n@class XMLElement\n\nXML DOM - The Element Object\n\nThe Element object represents an element in an XML document. Elements may contain attributes, other elements, or text. If an element contains text, the text is represented in a text-node.\n\nIMPORTANT! Text is always stored in text nodes. A common error in DOM processing is to navigate to an element node and expect it to contain the text. However, even the simplest element node has a text node under it. For example, in <year>2005</year>, there is an element node (year), and a text node under it, which contains the text (2005).\n\nBecause the Element object is also a Node, it inherits the Node object's properties and methods.\n\n@extends XMLNode\n\n\n\n@property attributes\tReturns a NamedNodeMap of attributes for the element\n@property baseURI\tReturns the absolute base URI of the element\n@property childNodes\tReturns a NodeList of child nodes for the element\n@property firstChild\tReturns the first child of the element\n@property lastChild\tReturns the last child of the element\n@property localName\tReturns the local part of the name of the element\n@property namespaceURI\tReturns the namespace URI of the element\n@property nextSibling\tReturns the node immediately following the element\n@property nodeName\tReturns the name of the node, depending on its type\n@property nodeType\tReturns the type of the node\n@property ownerDocument\tReturns the root element (document object) for an element\n@property parentNode\tReturns the parent node of the element\n@property prefix\tSets or returns the namespace prefix of the element\n@property previousSibling\tReturns the node immediately before the element\n@property schemaTypeInfo\tReturns the type information associated with the element\n@property tagName\tReturns the name of the element\n@property textContent\tSets or returns the text content of the element and its descendants\n\n\n\n\n\n@method appendChild()\tAdds a new child node to the end of the list of children of the node\n@method cloneNode()\tClones a  node\n@method compareDocumentPosition()\tCompares the document position of two nodes\n@method getAttribute()\tReturns the value of an attribute\n@method getAttributeNS()\tReturns the value of an attribute (with a namespace)\n@method getAttributeNode()\tReturns an attribute node as an Attribute object\n@method getAttributeNodeNS()\tReturns an attribute node (with a namespace) as an Attribute object\n@method getElementsByTagName()\tReturns a NodeList of matching element nodes, and their children\n@method getElementsByTagNameNS()\tReturns a NodeList of matching element nodes (with a namespace), and their children\n@method getFeature(feature,version)\tReturns a DOM object which implements the specialized APIs of the specified feature and version\n@method getUserData(key)\tReturns the object associated to a key on a this node. The object must first have been set to this node by calling setUserData with the same key\n@method hasAttribute()\tReturns whether an element has any attributes matching a specified name\n@method hasAttributeNS()\tReturns whether an element has any attributes matching a specified name and namespace\n@method hasAttributes()\tReturns whether the element has any attributes\n@method hasChildNodes()\tReturns whether the element has any child nodes\n@method insertBefore()\tInserts a new child node before an existing child node\n@method isDefaultNamespace(URI)\tReturns whether the specified namespaceURI is the default\n@method isEqualNode()\tChecks if two nodes are equal\n@method isSameNode()\tChecks if two nodes are the same node\n@method isSupported(feature,version)\tReturns whether a specified feature is supported on the element\n@method lookupNamespaceURI()\tReturns the namespace URI matching a specified prefix\n@method lookupPrefix()\tReturns the prefix matching a specified namespace URI\n@method normalize()\tPuts all text nodes underneath this element (including attributes) into a \"normal\" form where only structure (e.g., elements, comments, processing instructions, CDATA sections, and entity references) separates Text nodes, i.e., there are neither adjacent Text nodes nor empty Text nodes\n@method removeAttribute()\tRemoves a specified attribute\n@method removeAttributeNS()\tRemoves a specified attribute (with a namespace)\n@method removeAttributeNode()\tRemoves a specified attribute node\n@method removeChild()\tRemoves a child node\n@method replaceChild()\tReplaces a child node\n@method setUserData(key,data,handler)\tAssociates an object to a key on the element\n@method setAttribute()\tAdds a new attribute\n@method setAttributeNS()\tAdds a new attribute (with a namespace)\n@method setAttributeNode()\tAdds a new attribute node\n@method setAttributeNodeNS(attrnode)\tAdds a new attribute node (with a namespace)\n@method setIdAttribute(name,isId)\tIf the isId property of the Attribute object is true, this method declares the specified attribute to be a user-determined ID attribute\n@method setIdAttributeNS(uri,name,isId)\tIf the isId property of the Attribute object is true, this method declares the specified attribute (with a namespace) to be a user-determined ID attribute\n@method setIdAttributeNode(idAttr,isId)\tIf the isId property of the Attribute object is true, this method declares the specified attribute to be a user-determined ID attribute\n\n*/\n\n/*\n@module xml.dom\n\n@class XMLNode\n\n(from http://www.w3schools.com/dom/dom_node.asp)\n\nXML DOM - The Node Object\n\nThe Node object represents a single node in the document tree.\n\nA node can be an element node, an attribute node, a text node, or any other of the node types explained in the Node Types chapter.\n\nNotice that while all objects inherits the Node properties / methods for dealing with parents and children, not all objects can have parents or children. For example, Text nodes may not have children, and adding children to such nodes results in a DOM error.\n\n*/\n\n\n\n/*\n\n@property {Object} attributes\tA NamedNodeMap containing the attributes of this node (if it is an Element)\n@property {String} baseURI\tReturns the absolute base URI of a node\n\n\n\n@property {XMLNodeList} childNodes\tReturns a NodeList of child nodes for a node\n\n##Definition and Usage\nThe childNodes property returns a NodeList of child nodes for the specified node.\n\nTip: You can use the length property to determine the number of child nodes, then you can loop through all child nodes and extract the info you want.\n\n##Browser Support\nInternet Explorer Firefox Opera Google Chrome Safari\n\nThe childNodes property is supported in all major browsers.\n\n##Return Value:\t\nA NodeList object representing a collection of nodes\nDOM Version\tCore Level 1\n\n##Example\nThe following code fragment loads \"books.xml\" into xmlDoc using loadXMLDoc() and displays the child nodes of the XML document:\n\n\txmlDoc = loadXMLDoc(\"books.xml\");\n\n\tx = xmlDoc.childNodes;\n\tfor (i=0; i<x.length; i++)\n\t  {\n\t  document.write(\"Nodename: \" + x[i].nodeName);\n\t  document.write(\" (nodetype: \" + x[i].nodeType + \")<br>\");\n\t  }\n\nOutput IE:\n\n\tNodename: xml (nodetype: 7)\n\tNodename: #comment (nodetype: 8)\n\tNodename: bookstore (nodetype: 1)\n\nOutput Firefox, Opera, Chrome, and Safari :\n\n\tNodename: #comment (nodetype: 8)\n\tNodename: bookstore (nodetype: 1)\n\n\n\n\n\n\n\n\n\n\n\n\n@property firstChild\tReturns the first child of a node\n@property lastChild\tReturns the last child of a node\n@property localName\tReturns the local part of the name of a node\n@property namespaceURI\tReturns the namespace URI of a node\n@property nextSibling\tReturns the node immediately following a node\n@property nodeName\tReturns the name of a node, depending on its type\n@property nodeType\tReturns the type of a node\n@property nodeValue\tSets or returns the value of a node, depending on its type\n@property ownerDocument\tReturns the root element (document object) for a node\n@property parentNode\tReturns the parent node of a node\n@property prefix\tSets or returns the namespace prefix of a node\n@property previousSibling\tReturns the node immediately before a node\n@property textContent\tSets or returns the textual content of a node and its descendants\n\n*/\n\n\n\n\n/*\n\n@method appendChild\tAppends a new child node to the end of the list of children of a node\n@method cloneNode\tClones a node\n@method compareDocumentPosition\tCompares the placement of two nodes in the DOM hierarchy (document)\n@method getFeature(feature,version)\tReturns a DOM object which implements the specialized APIs of the specified feature and version\n@method getUserData(key)\tReturns the object associated to a key on a this node. The object must first have been set to this node by calling setUserData with the same key\n@method hasAttributes\tReturns true if the specified node has any attributes, otherwise false\n@method hasChildNodes\tReturns true if the specified node has any child nodes, otherwise false\n@method insertBefore\tInserts a new child node before an existing child node\n@method isDefaultNamespace(URI)\tReturns whether the specified namespaceURI is the default\n@method isEqualNode\tTests whether two nodes are equal\n@method isSameNode\tTests whether the two nodes are the same node\n@method isSupported\tTests whether the DOM implementation supports a specific feature and that the feature is supported by the specified node\n@method lookupNamespaceURI\tReturns the namespace URI associated with a given prefix\n@method lookupPrefix\tReturns the prefix associated with a given namespace URI\n@method normalize\tPuts all Text nodes underneath a node (including attribute nodes) into a \"normal\" form where only structure (e.g., elements, comments, processing instructions, CDATA sections, and entity references) separates Text nodes, i.e., there are neither adjacent Text nodes nor empty Text nodes\n@method removeChild\tRemoves a specified child node from the current node\n@method replaceChild\tReplaces a child node with a new node\n@method setUserData(key,data,handler)\tAssociates an object to a key on a node\n*/\n\n\n\n/*\n\n@module xml.dom\n\n@class XMLNodeList\n\nXML DOM - The NodeList Object\n\nThe NodeList object represents an ordered list of nodes.\n\nThe nodes in the node list can be accessed through their index number (starting from 0).\n\nThe node list keeps itself up-to-date. If an element is deleted or added, in the node list or the XML document, the list is automatically updated.\n\nNote: In a node list, the nodes are returned in the order in which they are specified in the XML document.\n\n@property length_ Returns the number of nodes in a node list k\n\n@method item @param {Number} i @return {XMLNode}Returns the node at the specified index in a node list \n\n*/\n\n//@module ideal\n//@class BaseObject \nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n//@property {Date} creationDate\n//@property {String} name\n//@property {String} description\n//@property {Object<String,User>} owners the owners, a map by owner id\nfunction BaseObject(){};\n\n//@class ObjectPool\nfunction ObjectPool(){};\n//@method loadObjects @param {Array<String>} objects_ids @return {Object<String,BaseObject>}\nObjectPool.prototype.getOwners = function(objects_ids){return null;}\n\n// @param {Array<String>} objects_ids\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n\n//@method getOwners this method is useful for *blabla* blabla _blabla_ bab\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n// @method getState get's the current state of this pool\n// @returns {#obj(id:String,objectDic:Object<String>)} bla bla bla\nvar getState=function(){};\n\n// @event objectCreated event fired when an object is created in this pool.\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n\n//@class Thing @extends BaseObject\n//@property {Number} importance\n\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n\n/** @class Action @extends BaseObject */\n\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n//@method extract @param {String|BaseObject|Array<BaseObject>} what\n\n// @module ideasAndProblems67\n\n// @class Idea\n\n// @class Problem @extends Idea\n\n// @param {Number} complexity\n\n// @class IdealProblem @extends Problem\n\n// @class MathProblem @extends IdealProblem\n\n// @property {Object<String,Equation>} equations\n\n\n\n// @class Equation\n\n// @method resolve invoke this method to solve the equation \n\n// @throws {EquationError} kja shkdj ahsd\n\n//@event afterThatHappens triggered when you-know-who comes the handler must be a ....\n// @returns {Solution} because we are very practical\n// @class Solution\n\n// @class EquationError @extends Error\n\n//@module life\n//@class Living @extends Thing\n//@method breath @param {Number} size\n\n//@class Animal @extends Living\n//@method eat @param {Array<Food>} food @return {Array<Energy>}\n\n//@class Person @extends Animal\n//@method walk @return {Action}\n/*@method crossStreet\n\nThis try to be a markdown [text](http://google.com)\n\nAnother paragraph \n\n\tvar someMarkup = {\n\t\ta: 1\n\t,\tn: 2\n\t,\tg: function (e)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t};\n\nand some final text with a list\n\n1. First ordered list item\n2. Another item\n  * Unordered sub-list.\n1. Actual numbers don't matter, just that it's a number\n  1. Ordered sub-list\n  2. hello\n4. And another item.\n*/\n\n\n// @module problem1 This is a description of planet earth city from the point of view of an alien observing us from a space ship.\n//@class TerranObject\n// @class Person @extends TerranObject\n\n//@class List This is just a semantic alias for javascript Array. @extends Array\n//@class Map This is just a semantic alias for javascript Object. @extends Object\n\n/*@class Building @extends TerranObject */\n\n//@class Hospital @extends Building\n//@constructor Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit... \n//@param {Number} availableBeds\n//Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...\n//@method getActiveDoctors @returns {List<Doctor>} the currently active doctors in this hospital\n//@property {Array<Person>} todayIngresedPatients all the patiens that entered this hospital today\n\n// @class Doctor @extend Person\n// @property {Map<String,MedicalTopic>} skills\n\n/*\n\n@class MedicalTopic\nLorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum\n\n\n@method beUsed \n\nLorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum\n\n@throws {MedicalException} if there is any medical issue stuff...\n@param {Number} amount Excepteur sint occaecat *cupidatat* \n\n@return {Array<MedicalTopic>}\n\n\n\n\n@class MedicalException @extends Error\n*/","classes":{"javascript.Boolean":{"annotation":"class","name":"Boolean","text":"#Summary\nThe Boolean object is an object wrapper for a boolean value.\n\n#Constructor\n\tnew Boolean(value)\n\n#Description\nThe value passed as the first parameter is converted to a boolean value, if necessary. If value is omitted or is 0, -0, null, false, NaN, undefined, or the empty string (\"\"), the object has an initial value of false. All other values, including any object or the string \"false\", create an object with an initial value of true.\n\nDo not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.\n\nAny object whose value is not undefined or null, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement. For example, the condition in the following if statement evaluates to true:\n\n\tx = new Boolean(false);\n\tif (x) {\n\t  // . . . this code is executed\n\t}\n\tThis behavior does not apply to Boolean primitives. For example, the condition in the following if statement evaluates to false:\n\n\tx = false;\n\tif (x) {\n\t  // . . . this code is not executed\n\t}\nDo not use a Boolean object to convert a non-boolean value to a boolean value. Instead, use Boolean as a function to perform this task:\n\n\tx = Boolean(expression);     // preferred\n\tx = new Boolean(expression); // don't use\n\tIf you specify any object, including a Boolean object whose value is false, as the initial value of a Boolean object, the new Boolean object has a value of true.\n\n\tmyFalse = new Boolean(false);   // initial value of false\n\tg = new Boolean(myFalse);       // initial value of true\n\tmyString = new String(\"Hello\"); // string object\n\ts = new Boolean(myString);      // initial value of true\n\tDo not use a Boolean object in place of a Boolean primitive.\n\n#Properties\nFor properties available on Boolean instances, see Properties of Boolean instances.\n\nBoolean.length\nLength property whose value is 1.\nBoolean.prototype\nRepresents the prototype for the Boolean constructor.\n#Properties inherited from Function:\narity, caller, constructor, length, name\n##Methods\nFor methods available on Boolean instances, see Methods of Boolean instances.\n\nThe global Boolean object contains no methods of its own, however, it does inherit some methods through the prototype chain:\n\n#Methods inherited from Function:\napply, call, toSource, toString\n\n#Boolean instances\nAll Boolean instances inherit from Boolean.prototype. As with all constructors, the prototype object dictates instances' inherited properties and methods.\n\n#Properties\n\nBoolean.prototype.constructor\nReturns the function that created an instance's prototype. This is the Boolean function by default.\nProperties inherited from Object:\n__parent__, __proto__\n#Methods\n\nBoolean.prototype.toSource() \nReturns a string containing the source of the Boolean object; you can use this string to create an equivalent object. Overrides the Object.prototype.toSource() method.\nBoolean.prototype.toString()\nReturns a string of either \"true\" or \"false\" depending upon the value of the object. Overrides the Object.prototype.toString() method.\nBoolean.prototype.valueOf()\nReturns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.\n\n\n#Examples\nCreating Boolean objects with an initial value of false\n\n\tvar bNoParam = new Boolean();\n\tvar bZero = new Boolean(0);\n\tvar bNull = new Boolean(null);\n\tvar bEmptyString = new Boolean(\"\");\n\tvar bfalse = new Boolean(false);\n\tCreating Boolean objects with an initial value of true\n\n\tvar btrue = new Boolean(true);\n\tvar btrueString = new Boolean(\"true\");\n\tvar bfalseString = new Boolean(\"false\");\n\tvar bSuLin = new Boolean(\"Su Lin\");","commentRange":[0,3668],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[0,3668],"fileName":"ALL.js"},"absoluteName":"javascript.Boolean","methods":{"valueOf":{"annotation":"method","name":"valueOf","text":"#Summary\nThe valueOf() method returns the primitive value of a Boolean object.\n\n#Syntax\n\tbool.valueOf()\n\n#Description\nThe valueOf method of Boolean returns the primitive value of a Boolean object or literal Boolean as a Boolean data type.\n\nThis method is usually called internally by JavaScript and not explicitly in code.\n\n#Examples\n##Example: Using valueOf\n\n\tx = new Boolean();\n\tmyVar = x.valueOf()      // assigns false to myVar","commentRange":[3671,4124],"fileName":"ALL.js"}}},"javascript.Error":{"annotation":"class","name":"Error","text":"#Summary\nThe Error constructor creates an error object. Instances of Error objects are thrown when runtime errors occur. The Error object can also be used as a base objects for user-defined exceptions. See below for standard built-in error types.\n\n#Syntax\n\tnew Error([message[, fileName[,lineNumber]]])\n#Description\nRuntime errors result in new Error objects being created and thrown.\n\nThis page documents the use of the Error object itself and its use as a constructor function. For a list of properties and methods inherited by Error instances, see Error.prototype.\n\n#Error types\n\nBesides the generic Error constructor, there are six other core error constructors in JavaScript. For client-side exceptions, see Exception Handling Statements.\n\n\tEvalError\n\tCreates an instance representing an error that occurs regarding the global function eval().\n\tInternalError \n\tCreates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. \"too much recursion\".\n\tRangeError\n\tCreates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.\n\tReferenceError\n\tCreates an instance representing an error that occurs when de-referencing an invalid reference.\n\tSyntaxError\n\tCreates an instance representing a syntax error that occurs while parsing code in eval().\n\tTypeError\n\tCreates an instance representing an error that occurs when a variable or parameter is not of a valid type.\n\tURIError\n\tCreates an instance representing an error that occurs when encodeURI() or decodeURl() are passed invalid parameters.\n\n#Properties\nError.prototype\nAllows the addition of properties to Error instances.\n#Methods\nThe global Error object contains no methods of its own, however, it does inherit some methods through the prototype chain.\n\n#Error instances\nAll Error instances and instances of non-generic errors inherit from Error.prototype. As with all constructor functions, you can use the prototype of the constructor to add properties or methods to all instances created with that constructor.\n\n#Properties\n\n##Standard properties\n\nError.prototype.constructor\nSpecifies the function that created an instance's prototype.\n\tError.prototype.message\n\tError message.\n\tError.prototype.name\n\tError name.\n\n\n#Vendor-specific extensions\n\n##Non-standard\nThis feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.\n##Microsoft\n\n\tError.prototype.description\n\tError description. Similar to message.\n\tError.prototype.number\n\tError number.\n##Mozilla\n\n\tError.prototype.fileName\n\tPath to file that raised this error.\n\tError.prototype.lineNumber\n\tLine number in file that raised this error.\n\tError.prototype.columnNumber\n\tColumn number in line that raised this error.\n\tError.prototype.stack\n\tStack trace.\n\n#Examples\n##Example: Throwing a generic error\n\nUsually you create an Error object with the intention of raising it using the throw keyword. You can handle the error using the try...catch construct:\n\n\ttry {\n\t  throw new Error(\"Whoops!\");\n\t} catch (e) {\n\t  alert(e.name + \": \" + e.message);\n\t}\n\tExample: Handling a specific error\n\n\tYou can choose to handle only specific error types by testing the error type with the error's constructor property or, if you're writing for modern JavaScript engines, instanceof keyword:\n\n\ttry {\n\t  foo.bar();\n\t} catch (e) {\n\t  if (e instanceof EvalError) {\n\t    alert(e.name + \": \" + e.message);\n\t  } else if (e instanceof RangeError) {\n\t    alert(e.name + \": \" + e.message);\n\t  }\n\t  // ... etc\n\t}\n##Custom Error Types\n\nYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. The common way to do this is demonstrated below.\n\nNote that the thrown MyError will report incorrect lineNumber and fileName at least in Firefox.\nSee also the \"What's a good way to extend Error in JavaScript?\" discussion on Stackoverflow.\n\n\t// Create a new object, that prototypally inherits from the Error constructor.\n\tfunction MyError(message) {\n\t  this.name = \"MyError\";\n\t  this.message = message || \"Default Message\";\n\t}\n\tMyError.prototype = new Error();\n\tMyError.prototype.constructor = MyError;\n\n\ttry {\n\t  throw new MyError();\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"Default Message\"\n\t}\n\n\ttry {\n\t  throw new MyError(\"custom message\");\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"custom message\"\n\t}","commentRange":[4126,8860],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[4126,8860],"fileName":"ALL.js"},"absoluteName":"javascript.Error","constructors":[{"annotation":"constructor","name":"n","text":"Boolean","children":[{"annotation":"param","type":"{String}","name":"message","text":"Human-readable description of the error","theRestString":"@param {String} fileName The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.\n@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."},{"annotation":"param","type":"{String}","name":"fileName","text":"The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.","theRestString":"@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."},{"annotation":"param","type":"{Number}","name":"lineNumber","text":"The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation.","theRestString":""}],"commentRange":[8862,9302],"fileName":"ALL.js","params":[{"annotation":"param","type":"{String}","name":"message","text":"Human-readable description of the error","theRestString":"@param {String} fileName The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.\n@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."},{"annotation":"param","type":"{String}","name":"fileName","text":"The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.","theRestString":"@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."},{"annotation":"param","type":"{Number}","name":"lineNumber","text":"The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation.","theRestString":""}],"throws":[]}],"properties":{"message":{"annotation":"property","type":"{String}","name":"message","text":"#Summary\nThe message property is a human-readable description of the error.\n\n#Description\nThis property contains a brief description of the error if one is available or has been set. SpiderMonkey makes extensive use of the message property for exceptions. The message property combined with the name property is used by the Error.prototype.toString() method to create a string representation of the Error.\n\nBy default, the message property is an empty string, but this behavior can be overridden for an instance by specifying a message as the first argument to the Error constructor.\n\n#Examples\n##Example: Throwing a custom error\n\n\tvar e = new Error(\"Could not parse input\"); // e.message is \"Could not parse input\"\n\tthrow e;","commentRange":[9306,10065],"fileName":"ALL.js"},"name":{"annotation":"property","type":"{String}","name":"name","text":"#Summary\nThe name property represents a name for the type of error. The initial value is \"Error\".\n\n#Description\nBy default, Error instances are given the name \"Error\". The name property, in addition to the message property, is used by the Error.prototype.toString() method to create a string representation of the error.\n\n#Examples\n##Example: Throwing a custom error\n\n\tvar e = new Error(\"Malformed input\"); // e.name is \"Error\"\n\n\te.name = \"ParseError\"; \n\tthrow e;\n\t// e.toString() would return \"ParseError: Malformed input\"","commentRange":[10071,10625],"fileName":"ALL.js"}}},"javascript.EvalError":{"annotation":"class","name":"EvalError","text":"","children":[{"annotation":"extends","name":"Error","text":"The EvalError object indicates an error regarding the global eval() function.","theRestString":""}],"commentRange":[10630,10745],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[4126,8860],"fileName":"ALL.js"},"absoluteName":"javascript.EvalError"},"javascript.RangeError":{"annotation":"class","name":"RangeError","text":"","children":[{"annotation":"extends","name":"Error","text":"The RangeError object indicates an error when a value is not in the set or range of allowed values.\n\nA RangeError is thrown when trying to pass a number as an argument to a function that does not allow a range that includes that number. This can be encountered when to create an array of an illegal length with the Array constructor, or when passing bad values to the numeric methods Number.toExponential(), Number.toFixed() or Number.toPrecision().","theRestString":""}],"commentRange":[10747,11236],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[4126,8860],"fileName":"ALL.js"},"absoluteName":"javascript.RangeError"},"javascript.ReferenceError":{"annotation":"class","name":"ReferenceError","text":"","children":[{"annotation":"extends","name":"Error","text":"#Summary\nThe ReferenceError object represents an error when a non-existent variable is referenced.\n\n#Description\nA ReferenceError is thrown when trying to dereference a variable that has not been declared.","theRestString":""}],"commentRange":[11239,11487],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[4126,8860],"fileName":"ALL.js"},"absoluteName":"javascript.ReferenceError"},"javascript.SyntaxError":{"annotation":"class","name":"SyntaxError","text":"","children":[{"annotation":"extends","name":"Error","text":"#Summary\nThe SyntaxError object represents an error when trying to interpret syntactically invalid code.\n\n#Description\nA SyntaxError is thrown when the JavaScript engine encounters tokens or token order that does not conform to the syntax of the language when parsing code.","theRestString":""}],"commentRange":[11491,11805],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[4126,8860],"fileName":"ALL.js"},"absoluteName":"javascript.SyntaxError"},"javascript.TypeError":{"annotation":"class","name":"TypeError","text":"","children":[{"annotation":"extends","name":"Error","text":"The TypeError object represents an error when a value is not of the expected type.","theRestString":""}],"commentRange":[11808,11928],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[4126,8860],"fileName":"ALL.js"},"absoluteName":"javascript.TypeError"},"javascript.URIError":{"annotation":"class","name":"URIError","text":"","children":[{"annotation":"extends","name":"Error","text":"The URIError object represents an error when a global URI handling function was used in a wrong way.","theRestString":""}],"commentRange":[11930,12068],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[4126,8860],"fileName":"ALL.js"},"absoluteName":"javascript.URIError"},"javascript.Function":{"annotation":"class","name":"Function","text":"#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.","commentRange":[12071,12300],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[12071,12300],"fileName":"ALL.js"},"absoluteName":"javascript.Function","properties":{"length":{"annotation":"property","type":"{Number}","name":"length","text":"#Summary\nThe length property specifies the number of arguments expected by the function.\n\n#Description\nlength is a property of a function object, and indicates how many arguments the function expects, i.e. the number of formal parameters. This number does not include the rest parameter. By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.\n\nData property of the Function constructor\n\nThe Function constructor is itself a Function object. It's length data property has a value of 1. The property attributes are: Writable: false, Enumerable: false, Configurable: true.\n\nProperty of the Function prototype object\n\nThe length property of the Function prototype object has a value of 0.\n\n#Examples\n\tconsole.log ( Function.length ); //1\n\n\tconsole.log( (function ()        {}).length ); //0\n\tconsole.log( (function (a)       {}).length ); //1\n\tconsole.log( (function (a, b)    {}).length ); //2 etc. \n\tconsole.log( (function (...args) {}).length ); //0, rest parameter is no","commentRange":[12303,13375],"fileName":"ALL.js"},"prototype":{"annotation":"property","type":"{FunctionPrototype}","name":"prototype","text":"#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.","commentRange":[13378,13610],"fileName":"ALL.js"}},"methods":{"apply":{"annotation":"method","name":"apply","text":"The apply() method calls a function with a given this value and arguments provided as an array (or an array-like object).\n\nNote: While the syntax of this function is almost identical to that of call(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.apply(thisArg, [argsArray])\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object. With apply, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\napply is very similar to call(), except for the type of arguments it supports. You can use an arguments array instead of a named set of parameters. With apply, you can use an array literal, for example, fun.apply(this, ['eat', 'bananas']), or an Array object, for example, fun.apply(this, new Array('eat', 'bananas')).\n\nYou can also use arguments for the argsArray parameter. arguments is a local variable of a function. It can be used for all unspecified arguments of the called object. Thus, you do not have to know the arguments of the called object when you use the apply method. You can use arguments to pass all the arguments to the called object. The called object is then responsible for handling the arguments.\n\nSince ECMAScript 5th Edition you can also use any kind of object which is array-like, so in practice this means it's going to have a property length and integer properties in the range [0...length). As an example you can now use a NodeList or a own custom object like {'length': 2, '0': 'eat', '1': 'bananas'}.\n\nNote: Most browsers, including Chrome 14 and Internet Explorer 9, still do not accept array-like objects and will throw an exception.\n#Examples\nUsing apply to chain constructors\n\nYou can use apply to chain constructors for an object, similar to Java. In the following example we will create a global Function method called construct, which will make you able to use an array-like object with a constructor instead of an arguments list.\n\n\tFunction.prototype.construct = function (aArgs) {\n\t    var fConstructor = this, fNewConstr = function () { fConstructor.apply(this, aArgs); };\n\t    fNewConstr.prototype = fConstructor.prototype;\n\t    return new fNewConstr();\n\t};\n\nExample usage:\n\n\tfunction MyConstructor () {\n\t    for (var nProp = 0; nProp < arguments.length; nProp++) {\n\t        this[\"property\" + nProp] = arguments[nProp];\n\t    }\n\t}\n\n\tvar myArray = [4, \"Hello world!\", false];\n\tvar myInstance = MyConstructor.construct(myArray);\n\n\talert(myInstance.property1); // alerts \"Hello world!\"\n\talert(myInstance instanceof MyConstructor); // alerts \"true\"\n\talert(myInstance.constructor); // alerts \"MyConstructor\"\n\nNote: This non-native Function.construct method will not work with some native constructors (like Date, for example). In these cases you have to use the Function.bind method (for example, imagine to have an array like the following, to be used with Date constructor: [2012, 11, 4]; in this case you have to write something like: new (Function.prototype.bind.apply(Date, [null].concat([2012, 11, 4])))() â€“ anyhow this is not the best way to do things and probably should not be used in any production environment).\nUsing apply and built-in functions\n\nClever usage of apply allows you to use built-ins functions for some tasks that otherwise probably would have been written by looping over the array values. As an example here we are going to use Math.max/Math.min to find out the maximum/minimum value in an array.\n\n\t//min/max number in an array \n\tvar numbers = [5, 6, 2, 3, 7];\n\n\t//using Math.min/Math.max apply \n\tvar max = Math.max.apply(null, numbers); // This about equal to Math.max(numbers[0], ...) or Math.max(5, 6, ..) \n\tvar min = Math.min.apply(null, numbers);\n\n\t/ vs. simple loop based algorithm \n\tmax = -Infinity, min = +Infinity;\n\n\tfor (var i = 0; i < numbers.length; i++) {\n\t  if (numbers[i] > max)\n\t    max = numbers[i];\n\t  if (numbers[i] < min) \n\t    min = numbers[i];\n\t}\n\nBut beware: in using apply this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (think more than tens of thousands of arguments) vary across engines (JavaScriptCore has hard-coded argument limit of 65536), because the limit (indeed even the nature of any excessively-large-stack behavior) is unspecified. Some engines will throw an exception. More perniciously, others will arbitrarily limit the number of arguments actually passed to the applied function. (To illustrate this latter case: if such an engine had a limit of four arguments [actual limits are of course significantly higher], it would be as if the arguments 5, 6, 2, 3 had been passed to apply in the examples above, rather than the full array.) If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:\n\n\tfunction minOfArray(arr) {\n\t  var min = Infinity;\n\t  var QUANTUM = 32768;\n\n\t  for (var i = 0, len = arr.length; i < len; i += QUANTUM) {\n\t    var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len)));\n\t    min = Math.min(submin, min);\n\t  }\n\n\t  return min;\n\t}\n\n\tvar min = minOfArray([5, 6, 2, 3, 7]);\nUsing apply in \"monkey-patching\"\n\nApply can be the best way to monkey-patch a builtin function of Firefox, or JS libraries. Given someobject.foo function, you can modify the function in a somewhat hacky way, like so:\n\n\tvar originalfoo = someobject.foo;\n\tsomeobject.foo = function() {\n\t  //Do stuff before calling function\n\t  console.log(arguments);\n\t  //Call the function as it would have been called normally:\n\t  originalfoo.apply(this,arguments);\n\t  //Run stuff after, here.\n\t}\n\nThis method is especially handy where you want to debug events, or interface with something that has no API like the various .on([event]... events, such as those usable on the Devtools Inspector).","children":[{"annotation":"param","type":"{Object}","name":"thisArg","text":"The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.","theRestString":"@param {Array} argsArray An array-like object, specifying the arguments with which fun should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.\n\n@returns the result of evaluating this function with given context and parameters"},{"annotation":"param","type":"{Array}","name":"argsArray","text":"An array-like object, specifying the arguments with which fun should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.","theRestString":"@returns the result of evaluating this function with given context and parameters"},{"annotation":"returns","name":"the","text":"result of evaluating this function with given context and parameters","theRestString":""}],"commentRange":[13614,20344],"fileName":"ALL.js"},"bind":{"annotation":"method","name":"bind","text":"#Summary\nThe bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.\n\n#Syntax\n\tfun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nThe bind() function creates a new function (a bound function) with the same function body (internal call property in ECMAScript 5 terms) as the function it is being called on (the bound function's target function) with the this value bound to the first argument of bind(), which cannot be overridden. bind() also accepts leading default arguments to provide to the target function when the bound function is called. A bound function may also be constructed using the new operator: doing so acts as though the target function had instead been constructed. The provided this value is ignored, while prepended arguments are provided to the emulated function.\n\n#Examples\nCreating a bound function\n\nThe simplest use of bind() is to make a function that, no matter how it is called, is called with a particular this value. A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g. by using that method in callback-based code). Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:\n\n\tthis.x = 9; \n\tvar module = {\n\t  x: 81,\n\t  getX: function() { return this.x; }\n\t};\n\n\tmodule.getX(); // 81\n\n\tvar getX = module.getX;\n\tgetX(); // 9, because in this case, \"this\" refers to the global object\n\n\t// create a new function with 'this' bound to module\n\tvar boundGetX = getX.bind(module);\n\tboundGetX(); // 81\n\n##Partial Functions\n\nThe next simplest use of bind() is to make a function with pre-specified initial arguments. These arguments (if any) follow the provided this value and are then inserted at the start of the arguments passed to the target function, followed by the arguments passed to the bound function, whenever the bound function is called.\n\n\tfunction list() {\n\t  return Array.prototype.slice.call(arguments);\n\t}\n\n\tvar list1 = list(1, 2, 3); // [1, 2, 3]\n\n\t//  Create a function with a preset leading argument\n\tvar leadingThirtysevenList = list.bind(undefined, 37);\n\n\tvar list2 = leadingThirtysevenList(); // [37]\n\tvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n##With setTimeout\n\nBy default within window.setTimeout(), the this keyword will be set to the window (or global) object. When working with class methods that require this to refer to class instances, you may explicitly bind this to the callback function, in order to maintain the instance.\n\n\tfunction LateBloomer() {\n\t  this.petalCount = Math.ceil( Math.random() * 12 ) + 1;\n\t}\n\n\t// declare bloom after a delay of 1 second\n\tLateBloomer.prototype.bloom = function() {\n\t  window.setTimeout( this.declare.bind( this ), 1000 );\n\t};\n\n\tLateBloomer.prototype.declare = function() {\n\t  console.log('I am a beautiful flower with ' + \n\t    this.petalCount + ' petals!');\n\t};\n\n##Bound functions used as constructors\n\nWarning: This section demonstrates JavaScript capabilities and documents some edge cases of the bind() method. The methods shown below are not the best way to do things and probably should not be used in any production environment.\nBound functions are automatically suitable for use with the new operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided this is ignored. However, provided arguments are still prepended to the constructor call:\n\n\tfunction Point(x, y) {\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\n\tPoint.prototype.toString = function() { \n\t  return this.x + \",\" + this.y; \n\t};\n\n\tvar p = new Point(1, 2);\n\tp.toString(); // \"1,2\"\n\n\n\tvar emptyObj = {};\n\tvar YAxisPoint = Point.bind(emptyObj, 0);\n\t// not supported in the polyfill below, works fine with native bind:\n\tvar YAxisPoint = Point.bind(null,0 );\n\n\tvar axisPoint = new YAxisPoint(5);\n\taxisPoint.toString(); //  \"0,5\"\n\n\taxisPoint instanceof Point; // true\n\taxisPoint instanceof YAxisPoint; // true\n\tnew Point(17, 42) instanceof YAxisPoint; // false\nNote that you need do nothing special to create a bound function for use with new. The corollary is that you need do nothing special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using new.\n\n\t// Example can be run directly in your JavaScript console\n\t// ...continuing from above\n\n\t// Can still be called as a normal function \n\t// (although usually this is undesired)\n\tYAxisPoint(13);\n\n\temptyObj.x + \",\" + emptyObj.y;\n\t// >  \"0,13\"\nIf you wish to support use of a bound function only using new, or only by calling it, the target function must enforce that restriction.\n\n##Creating shortcuts\n\nbind() is also helpful in cases where you want to create a shortcut to a function which requires a specific this value.\n\nTake Array.prototype.slice, for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:\n\n\tvar slice = Array.prototype.slice;\n\n\t// ...\n\n\tslice.call(arguments);\n\tWith bind(), this can be simplified. In the following piece of code, slice is a bound function to the call() function of Function.prototype, with the this value set to the slice() function of Array.prototype. This means that additional call() calls can be eliminated:\n\n\t// same as \"slice\" in the previous example\n\tvar unboundSlice = Array.prototype.slice;\n\tvar slice = Function.prototype.call.bind(unboundSlice);\n\n\t// ...\n\n\tslice(arguments);\n#Polyfill\nThe bind function is a recent addition to ECMA-262, 5th edition; as such it may not be present in all browsers. You can partially work around this by inserting the following code at the beginning of your scripts, allowing use of much of the functionality of bind() in implementations that do not natively support it.\n\n\tif (!Function.prototype.bind) {\n\t  Function.prototype.bind = function (oThis) {\n\t    if (typeof this !== \"function\") {\n\t      // closest thing possible to the ECMAScript 5\n\t      // internal IsCallable function\n\t      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\t    }\n\n\t    var aArgs = Array.prototype.slice.call(arguments, 1), \n\t        fToBind = this, \n\t        fNOP = function () {},\n\t        fBound = function () {\n\t          return fToBind.apply(this instanceof fNOP && oThis\n\t                 ? this\n\t                 : oThis,\n\t                 aArgs.concat(Array.prototype.slice.call(arguments)));\n\t        };\n\n\t    fNOP.prototype = this.prototype;\n\t    fBound.prototype = new fNOP();\n\n\t    return fBound;\n\t  };\n\t}\n\nSome of the many differences (there may well be others, as this list does not seriously attempt to be exhaustive) between this algorithm and the specified algorithm are:\n\nThe partial implementation relies Array.prototype.slice, Array.prototype.concat, Function.prototype.call and Function.prototype.apply, built-in methods to have their original values.\nThe partial implementation creates functions that do not have immutable \"poison pill\" caller and arguments properties that throw a TypeError upon get, set, or deletion. (This could be added if the implementation supports Object.defineProperty, or partially implemented [without throw-on-delete behavior] if the implementation supports the __defineGetter__ and __defineSetter__ extensions.)\nThe partial implementation creates functions that have a prototype property. (Proper bound functions have none.)\nThe partial implementation creates bound functions whose length property does not agree with that mandated by ECMA-262: it creates functions with length 0, while a full implementation, depending on the length of the target function and the number of pre-specified arguments, may return a non-zero length.\nIf you choose to use this partial implementation, you must not rely on those cases where behavior deviates from ECMA-262, 5th edition! With some care, however (and perhaps with additional modification to suit specific needs), this partial implementation may be a reasonable bridge to the time when bind() is widely implemented according to the specification.","children":[{"annotation":"param","name":"thisArg","text":"The value to be passed as the this parameter to the target function when the bound function is called. The value is ignored if the bound function is constructed using the new operator.","theRestString":"@param args Arguments to prepend to arguments provided to the bound function when invoking the target function."},{"annotation":"param","name":"args","text":"Arguments to prepend to arguments provided to the bound function when invoking the target function.","theRestString":""}],"commentRange":[20352,29036],"fileName":"ALL.js"},"call":{"annotation":"method","name":"call","text":"#Summary\nThe call() method calls a function with a given this value and arguments provided individually.\n\nNOTE: While the syntax of this function is almost identical to that of apply(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.call(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object.\n\nWith call, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\n#Examples\n##Using call to chain constructors for an object\n\nYou can use call to chain constructors for an object, similar to Java. In the following example, the constructor for the Product object is defined with two parameters, name and price. Two other functions Food and Toy invoke Product passing this and name and price. Product initializes the properties name and price, both specialized functions define the category.\n\n\tfunction Product(name, price) {\n\t  this.name = name;\n\t  this.price = price;\n\n\t  if (price < 0) {\n\t    throw RangeError('Cannot create product ' +\n\t                      this.name + ' with a negative price');\n\t  }\n\n\t  return this;\n\t}\n\n\tfunction Food(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'food';\n\t}\n\n\tFood.prototype = Object.create(Product.prototype);\n\n\tfunction Toy(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'toy';\n\t}\n\n\tToy.prototype = Object.create(Product.prototype);\n\n\tvar cheese = new Food('feta', 5);\n\tvar fun = new Toy('robot', 40);\n \n##Using call to invoke an anonymous function\n\nIn this purely constructed example, we create anonymous function and use call to invoke it on every object in an array. The main purpose of the anonymous function here is to add a print function to every object, which is able to print the right index of the object in the array. Passing the object as this value was not strictly necessary, but is done for explanatory purpose.\n\n\tvar animals = [\n\t  {species: 'Lion', name: 'King'},\n\t  {species: 'Whale', name: 'Fail'}\n\t];\n\n\tfor (var i = 0; i < animals.length; i++) {\n\t  (function (i) { \n\t    this.print = function () { \n\t      console.log('#' + i  + ' ' + this.species \n\t                  + ': ' + this.name); \n\t    } \n\t    this.print();\n\t  }).call(animals[i], i);\n\t}","children":[{"annotation":"param","name":"thisArg","text":"The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.","theRestString":"@param arg1,arg2,... Arguments for the object."},{"annotation":"param","name":"arg1","text":",arg2,... Arguments for the object.","theRestString":""}],"commentRange":[29043,31812],"fileName":"ALL.js"},"toString":{"annotation":"method","name":"toString","text":"#Summary\nThe toString() method returns a string representing the source code of the function.\n\n#Syntax\n\tfunction.toString(indentation)\n#Description\nThe Function object overrides the toString method inherited from Object; it does not inherit Object.prototype.toString. For Function objects, the toString method returns a string representation of the object in the form of a function declaration. That is, toString decompiles the function, and the string returned includes the function keyword, the argument list, curly braces, and the source of the function body.\n\nJavaScript calls the toString method automatically when a Function is to be represented as a text value, e.g. when a function is concatenated with a string.","children":[{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[31817,32578],"fileName":"ALL.js"}}},"javascript.Number":{"annotation":"class","name":"Number","text":"#Summary\nThe Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor.\n\n#Constructor\n\tnew Number(value);\n\n#Description\nThe primary uses for the Number object are:\n\nIf the argument cannot be converted into a number, it returns NaN.\nIn a non-constructor context (i.e., without the new operator, Number can be used to perform a type conversion.\n\n\n#Examples\n##Example: Using the Number object to assign values to numeric variables\n\nThe following example uses the Number object's properties to assign values to several numeric variables:\n\n\tvar biggestNum = Number.MAX_VALUE;\n\tvar smallestNum = Number.MIN_VALUE;\n\tvar infiniteNum = Number.POSITIVE_INFINITY;\n\tvar negInfiniteNum = Number.NEGATIVE_INFINITY;\n\tvar notANum = Number.NaN;\n##Example: Integer range for Number\n\nThe following example shows minimum and maximum integer values that can be represented as Number object (for details, refer to EcmaScript standard, chapter 8.5 The Number Type):\n\n\tvar biggestInt = 9007199254740992;\n\tvar smallestInt = -9007199254740992;\n\nWhen parsing data that has been serialized to JSON, integer values falling out of this range can be expected to become corrupted when JSON parser coerces them to Number type. Using String instead is a possible workaround.\n\n##Example: Using Number to convert a Date object\n\nThe following example converts the Date object to a numerical value using Number as a function:\n\n\tvar d = new Date(\"December 17, 1995 03:24:00\");\n\tprint(Number(d));\n\nThis displays \"819199440000\".","commentRange":[32580,34197],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[32580,34197],"fileName":"ALL.js"},"absoluteName":"javascript.Number","constructors":[{"annotation":"constructor","name":"n","text":"Number","children":[{"annotation":"param","type":"{Any}","name":"value","text":"The numeric value of the object being created.","theRestString":""}],"commentRange":[34199,34289],"fileName":"ALL.js","params":[{"annotation":"param","type":"{Any}","name":"value","text":"The numeric value of the object being created.","theRestString":""}],"throws":[]}],"properties":{"MAX_VALUE":{"annotation":"property","type":"{Number}","name":"MAX_VALUE","text":"#Summary\nThe Number.MAX_VALUE property represents the maximum numeric value representable in JavaScript.\n\n#Description\nThe MAX_VALUE property has a value of approximately 1.79E+308. Values larger than MAX_VALUE are represented as \"Infinity\".\n\nBecause MAX_VALUE is a static property of Number, you always use it as Number.MAX_VALUE, rather than as a property of a Number object you created.\n\n#Examples\n##Example: Using MAX_VALUE\n\n\tThe following code multiplies two numeric values. If the result is less than or equal to MAX_VALUE, the func1 function is called; otherwise, the func2 function is called.\n\n\tif (num1 * num2 <= Number.MAX_VALUE) {\n\t   func1();\n\t} else {\n\t   func2();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[34296,35022],"fileName":"ALL.js"},"MIN_VALUE":{"annotation":"property","type":"{Number}","name":"MIN_VALUE","text":"#Summary\nThe Number.MIN_VALUE property represents the smallest positive numeric value representable in JavaScript.\n\n#Description\nThe MIN_VALUE property is the number closest to 0, not the most negative number, that JavaScript can represent.\n\nMIN_VALUE has a value of approximately 5e-324. Values smaller than MIN_VALUE (\"underflow values\") are converted to 0.\n\nBecause MIN_VALUE is a static property of Number, you always use it as Number.MIN_VALUE, rather than as a property of a Number object you created.\n\n#Examples\n##Example: Using MIN_VALUE\n\nThe following code divides two numeric values. If the result is greater than or equal to MIN_VALUE, the func1 function is called; otherwise, the func2 function is called.\n\n\tif (num1 / num2 >= Number.MIN_VALUE) {\n\t    func1();\n\t} else {\n\t    func2();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[35026,35870],"fileName":"ALL.js"},"NEGATIVE_INFINITY":{"annotation":"property","type":"{Number}","name":"NEGATIVE_INFINITY","text":"#Summary\nThe Number.NEGATIVE_INFINITY property represents the negative Infinity value.\n\nYou do not have to create a Number object to access this static property (use Number.NEGATIVE_INFINITY).\n\n#Description\nThe value of Number.NEGATIVE_INFINITY is the same as the negative value of the global object's Infinity property.\n\nThis value behaves slightly differently than mathematical infinity:\n\n* Any positive value, including POSITIVE_INFINITY, multiplied by NEGATIVE_INFINITY is NEGATIVE_INFINITY.\n* Any negative value, including NEGATIVE_INFINITY, multiplied by NEGATIVE_INFINITY is POSITIVE_INFINITY.\n* Zero multiplied by NEGATIVE_INFINITY is NaN.\n* NaN multiplied by NEGATIVE_INFINITY is NaN.\n* NEGATIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is POSITIVE_INFINITY.\n* NEGATIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is NEGATIVE_INFINITY.\n* NEGATIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\n* Any number divided by NEGATIVE_INFINITY is zero.\n\nYou might use the Number.NEGATIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that isFinite would be more appropriate in such a case.\n\n#Example\nIn the following example, the variable smallNumber is assigned a value that is smaller than the minimum value. When the if statement executes, smallNumber has the value \"-Infinity\", so smallNumber is set to a more manageable value before continuing.\n\n\tvar smallNumber = (-Number.MAX_VALUE) * 2\n\n\tif (smallNumber == Number.NEGATIVE_INFINITY) {\n\t smallNumber = returnFinite();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[35875,37548],"fileName":"ALL.js"},"NaN":{"annotation":"property","type":"{Number}","name":"NaN","text":"#Summary\nThe Number.NaN property represents Not-A-Number. Equivalent of NaN.\n\nYou do not have to create a Number object to access this static property (use Number.NaN).","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[37552,37757],"fileName":"ALL.js"},"POSITIVE_INFINITY":{"annotation":"property","type":"{Number}","name":"POSITIVE_INFINITY","text":"#Summary\nThe Number.POSITIVE_INFINITY property represents the positive Infinity value.\n\nYou do not have to create a Number object to access this static property (use Number.POSITIVE_INFINITY).\n\n#Description\nThe value of Number.POSITIVE_INFINITY is the same as the value of the global object's Infinity property.\n\nThis value behaves slightly differently than mathematical infinity:\n\n* Any positive value, including POSITIVE_INFINITY, multiplied by POSITIVE_INFINITY is POSITIVE_INFINITY.\n* Any negative value, including NEGATIVE_INFINITY, multiplied by POSITIVE_INFINITY is NEGATIVE_INFINITY.\n* Zero multiplied by POSITIVE_INFINITY is NaN.\n* NaN multiplied by POSITIVE_INFINITY is NaN.\n* POSITIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is NEGATIVE_INFINITY.\n* POSITIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is POSITIVE_INFINITY.\n* POSITIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\n* Any number divided by POSITIVE_INFINITY is Zero.\n* You might use the Number.POSITIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that isFinite would be more appropriate in such a case.\n\n#Example\nIn the following example, the variable bigNumber is assigned a value that is larger than the maximum value. When the if statement executes, bigNumber has the value \"Infinity\", so bigNumber is set to a more manageable value before continuing.\n\n\tvar bigNumber = Number.MAX_VALUE * 2\n\tif (bigNumber == Number.POSITIVE_INFINITY) {\n\t bigNumber = returnFinite();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[37761,39409],"fileName":"ALL.js"}}},"javascript.Object":{"annotation":"class","name":"Object","text":"Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n\n#Description\nThe Object constructor creates an object wrapper for the given value. If the value is null or undefined, it will create and return an empty object, otherwise, it will return an object of a Type that corresponds to the given value. If the value is an object already, it will return the value.\n\nWhen called in a non-constructor context, Object behaves identically to new Object().\n\n#Object instances and Object prototype object\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden. For example, other constructors' prototypes override the constructor property and provide their own toString methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.\n\n#Examples\n##Example: Using Object given undefined and null types\n\nThe following examples store an empty Object object in o:\n\n\tvar o = new Object();\n\tvar o = new Object(undefined);\n\tvar o = new Object(null);\n##Example: Using Object to create Boolean objects\n\nThe following examples store Boolean objects in o:\n\n\t// equivalent to o = new Boolean(true);\n\tvar o = new Object(true);\n\t// equivalent to o = new Boolean(false);\n\tvar o = new Object(Boolean());","commentRange":[39411,40943],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[39411,40943],"fileName":"ALL.js"},"absoluteName":"javascript.Object","properties":{"prototype":{"annotation":"property","type":"{ObjectPrototype}","name":"prototype","text":"","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[39411,40943],"fileName":"ALL.js"}},"constructors":[{"annotation":"constructor","name":"n","text":"bla bla\n\n\t// Object initialiser or literal \n\t{ [ nameValuePair1 [, nameValuePair2 [, ...nameValuePairN] ] ] }  \n\t// Called as a constructor \n\tnew Object( [ value ] )","children":[{"annotation":"param","name":"nameValuePair1","text":",nameValuePair2,...nameValuePairN Pairs of names (strings) and values (any value) where the name is separated from the value by a colon.","theRestString":"@param value Any value."},{"annotation":"param","name":"value","text":"Any value.","theRestString":""}],"commentRange":[40945,41312],"fileName":"ALL.js","params":[{"annotation":"param","name":"nameValuePair1","text":",nameValuePair2,...nameValuePairN Pairs of names (strings) and values (any value) where the name is separated from the value by a colon.","theRestString":"@param value Any value."},{"annotation":"param","name":"value","text":"Any value.","theRestString":""}],"throws":[]}],"methods":{"__defineGetter__":{"annotation":"method","name":"__defineGetter__","text":"()  \nAssociates a function with a property that, when accessed, executes that function and returns its return value.","commentRange":[41328,41474],"fileName":"ALL.js"},"hasOwnProperty":{"annotation":"method","name":"hasOwnProperty","text":"#Summary\nThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n#Syntax\n\tobj.hasOwnProperty(prop)\n\n#Description\nEvery object descended from Object inherits the hasOwnProperty method. This method can be used to determine whether an object has the specified property as a direct property of that object; unlike the in operator, this method does not check down the object's prototype chain.\n\n#Examples\n##Example: Using hasOwnProperty to test for a property's existence\n\nThe following example determines whether the o object contains a property named prop:\n\n\to = new Object();\n\to.prop = 'exists';\n\n\tfunction changeO() {\n\t  o.newprop = o.prop;\n\t  delete o.prop;\n\t}\n\n\to.hasOwnProperty('prop');   // returns true\n\tchangeO();\n\to.hasOwnProperty('prop');   // returns false\n\tExample: Direct versus inherited properties\n\n\tThe following example differentiates between direct properties and properties inherited through the prototype chain:\n\n\to = new Object();\n\to.prop = 'exists';\n\to.hasOwnProperty('prop');             // returns true\n\to.hasOwnProperty('toString');         // returns false\n\to.hasOwnProperty('hasOwnProperty');   // returns false\n##Example: Iterating over the properties of an object\n\nThe following example shows how to iterate over the properties of an object without executing on inherit properties. Note that the for...in loop is already only iterating enumerable items, so one should not assume based on the lack of non-enumerable properties shown in the loop that hasOwnProperty itself is confined strictly to enumerable items (as with Object.getOwnPropertyNames()).\n\n\tvar buz = {\n\t  fog: 'stack'\n\t};\n\n\tfor (var name in buz) {\n\t  if (buz.hasOwnProperty(name)) {\n\t    alert('this is fog (' + name + ') for sure. Value: ' + buz[name]);\n\t  }\n\t  else {\n\t    alert(name); // toString or something else\n\t  }\n\t}\n##Example: hasOwnProperty as a property\n\nJavaScript does not protect the property name hasOwnProperty; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an external hasOwnProperty to get correct results:\n\n\tvar foo = {\n\t  hasOwnProperty: function() {\n\t    return false;\n\t  },\n\t  bar: 'Here be dragons'\n\t};\n\n\tfoo.hasOwnProperty('bar'); // always returns false\n\n\t// Use another Object's hasOwnProperty and call it with 'this' set to foo\n\t({}).hasOwnProperty.call(foo, 'bar'); // true\n\n\t// It's also possible to use the hasOwnProperty property from the Object prototype for this purpose\n\tObject.prototype.hasOwnProperty.call(foo, 'bar'); // true\nNote that in the last case there are no newly created objects.","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {String}prop The name of the property to test."},{"annotation":"param","type":"{String}","name":"prop","text":"The name of the property to test.","theRestString":""}],"commentRange":[88204,90926],"fileName":"ALL.js"},"isPrototypeOf":{"annotation":"method","name":"isPrototypeOf","text":"#Summary\nThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\nNote: isPrototypeOf differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n#Syntax\n\tprototypeObj.isPrototypeOf(obj)\n#Description\nThe isPrototypeOf method allows you to check whether or not an object exists within another object's prototype chain.\n\nFor example, consider the following prototype chain:\n\n\tfunction Fee() {\n\t  // ...\n\t}\n\n\tfunction Fi() {\n\t  // ...\n\t}\n\tFi.prototype = new Fee();\n\n\tfunction Fo() {\n\t  // ...\n\t}\n\tFo.prototype = new Fi();\n\n\tfunction Fum() {\n\t  // ...\n\t}\n\tFum.prototype = new Fo();\nLater on down the road, if you instantiate Fum and need to check if Fi's prototype exists within the Fum prototype chain, you could do this:\n\n\tvar fum = new Fum();\n\t// ...\n\n\tif (Fi.prototype.isPrototypeOf(fum)) {\n\t  // do something safe\n\t}\nThis, along with the instanceof operator particularly comes in handy if you have code that can only function when dealing with objects descended from a specific prototype chain, e.g., to guarantee that certain methods or properties will be present on that object.","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} prototypeObj An object to be tested against each link in the prototype chain of the object argument.\n@param {Object}object The object whose prototype chain will be searched.\n@returns {boolean}"},{"annotation":"param","type":"{Object}","name":"prototypeObj","text":"An object to be tested against each link in the prototype chain of the object argument.","theRestString":"@param {Object}object The object whose prototype chain will be searched.\n@returns {boolean}"},{"annotation":"param","type":"{Object}","name":"object","text":"The object whose prototype chain will be searched.","theRestString":"@returns {boolean}"},{"annotation":"returns","type":"{boolean}","text":"","theRestString":""}],"commentRange":[90934,92418],"fileName":"ALL.js"},"propertyIsEnumerable":{"annotation":"method","name":"propertyIsEnumerable","text":"#Summary\nThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n#Syntax\n\tobj.propertyIsEnumerable(prop)\n\n#Description\nEvery object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.\n\n#Examples\n##Example: A basic use of propertyIsEnumerable\n\nThe following example shows the use of propertyIsEnumerable on objects and arrays:\n\n\tvar o = {};\n\tvar a = [];\n\to.prop = 'is enumerable';\n\ta[0] = 'is enumerable';\n\n\to.propertyIsEnumerable('prop');   // returns true\n\ta.propertyIsEnumerable(0);        // returns true\n##Example: User-defined versus built-in objects\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n\tvar a = ['is enumerable'];\n\n\ta.propertyIsEnumerable(0);          // returns true\n\ta.propertyIsEnumerable('length');   // returns false\n\n\tMath.propertyIsEnumerable('random');   // returns false\n\tthis.propertyIsEnumerable('Math');     // returns false\n##Example: Direct versus inherited properties\n\n\tvar a = [];\n\ta.propertyIsEnumerable('constructor');         // returns false\n\n\tfunction firstConstructor() {\n\t  this.property = 'is not enumerable';\n\t}\n\n\tfirstConstructor.prototype.firstMethod = function() {};\n\n\tfunction secondConstructor() {\n\t  this.method = function method() { return 'is enumerable'; };\n\t}\n\n\tsecondConstructor.prototype = new firstConstructor;\n\tsecondConstructor.prototype.constructor = secondConstructor;\n\n\tvar o = new secondConstructor();\n\to.arbitraryProperty = 'is enumerable';\n\n\to.propertyIsEnumerable('arbitraryProperty');   // returns true\n\to.propertyIsEnumerable('method');              // returns true\n\to.propertyIsEnumerable('property');            // returns false\n\n\to.property = 'is enumerable';\n\n\to.propertyIsEnumerable('property');            // returns true\n\n\t// These return false as they are on the prototype which \n\t// propertyIsEnumerable does not consider (even though the last two\n\t// are iteratable with for-in)\n\to.propertyIsEnumerable('prototype');   // returns false (as of JS 1.8.1/FF3.6)\n\to.propertyIsEnumerable('constructor'); // returns false\n\to.propertyIsEnumerable('firstMethod'); // returns false","children":[{"annotation":"param","type":"{String}","name":"prop","text":"The name of the property to test.","theRestString":"@return {boolean}"},{"annotation":"return","type":"{boolean}","text":"","theRestString":""}],"commentRange":[92425,94932],"fileName":"ALL.js"},"toLocaleString":{"annotation":"method","name":"toLocaleString","text":"#Summary\nThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n#Syntax\n\tobj.toLocaleString();\n#Description\nObject's toLocaleString returns the result of calling toString().\n\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. See the list below.\n\nObjects overriding toLocaleString\n\n\tArray: Array.prototype.toLocaleString()\n\tNumber: Number.prototype.toLocaleString()\n\tDate: Date.prototype.toLocaleString()","commentRange":[94936,95527],"fileName":"ALL.js"},"toString":{"annotation":"method","name":"toString","text":"#Summary\nThe toString() method returns a string representing object.\n\n#Syntax\n\tobj.toString()\n#Description\nEvery object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected. By default, the toString() method is inherited by every object descended from Object. If this method is not overridden in a custom object, toString() returns \"[object type]\", where type is the object type. The following code illustrates this:\n\n\tvar o = new Object();\n\to.toString();           // returns [object Object]\nNote: Starting in JavaScript 1.8.5 toString() called on null returns [object Null], and undefined returns [object Undefined], as defined in the 5th Edition of ECMAScript and a subsequent Errata. See Using toString to detect object type.\n#Examples\n##Example: Overriding the default toString method\n\nYou can create a function to be called in place of the default toString() method. The toString() method takes no arguments and should return a string. The toString() method you create can be any value you want, but it will be most useful if it carries information about the object.\n\nThe following code defines the Dog object type and creates theDog, an object of type Dog:\n\n\tfunction Dog(name, breed, color, sex) {\n\t  this.name = name;\n\t  this.breed = breed;\n\t  this.color = color;\n\t  this.sex = sex;\n\t}\n\n\ttheDog = new Dog('Gabby', 'Lab', 'chocolate', 'female');\nIf you call the toString() method on this custom object, it returns the default value inherited from Object:\n\n\ttheDog.toString(); // returns [object Object]\nThe following code creates and assigns dogToString() to override the default toString() method. This function generates a string containing the name, breed, color, and sex of the object, in the form \"property = value;\".\n\n\tDog.prototype.toString = function dogToString() {\n\t  var ret = 'Dog ' + this.name + ' is a ' + this.sex + ' ' + this.color + ' ' + this.breed;\n\t  return ret;\n\t}\n\nWith the preceding code in place, any time theDog is used in a string context, JavaScript automatically calls the dogToString() function, which returns the following string:\n\n\tDog Gabby is a female chocolate Lab\n\n##Example: Using toString() to detect object class\n\ntoString() can be used with every object and allows you to get its class. To use the Object.prototype.toString() with every object, you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter called thisArg.\n\n\tvar toString = Object.prototype.toString;\n\n\ttoString.call(new Date);    // [object Date]\n\ttoString.call(new String);  // [object String]\n\ttoString.call(Math);        // [object Math]\n\n\t// Since JavaScript 1.8.5\n\ttoString.call(undefined);   // [object Undefined]\n\ttoString.call(null);        // [object Null]","children":[{"annotation":"return","type":"{String}","name":"returns","text":"a string representing object.","theRestString":""}],"commentRange":[95531,98496],"fileName":"ALL.js"},"create":{"annotation":"method","name":"create","text":"#Summary\nThe Object.create() method creates a new object with the specified prototype object and properties.\n\n#Syntax\n\tObject.create(proto[, propertiesObject])\n\n#Examples\n\n##Example: Classical inheritance with Object.create\n\nBelow is an example of how to use Object.create to achieve classical inheritance. This is for single inheritance, which is all that Javascript supports.\n\n\t// Shape - superclass\n\tfunction Shape() {\n\t  this.x = 0;\n\t  this.y = 0;\n\t}\n\n\t// superclass method\n\tShape.prototype.move = function(x, y) {\n\t  this.x += x;\n\t  this.y += y;\n\t  console.info('Shape moved.');\n\t};\n\n\t// Rectangle - subclass\n\tfunction Rectangle() {\n\t  Shape.call(this); // call super constructor.\n\t}\n\n\t// subclass extends superclass\n\tRectangle.prototype = Object.create(Shape.prototype);\n\tRectangle.prototype.constructor = Rectangle;\n\n\tvar rect = new Rectangle();\n\n\trect instanceof Rectangle; // true\n\trect instanceof Shape; // true\n\n\trect.move(1, 1); // Outputs, 'Shape moved.'\n\tIf you wish to inherit from multiple objects, then mixins are a possibility.\n\n\tfunction MyClass() {\n\t  SuperClass.call(this);\n\t  OtherSuperClass.call(this);\n\t}\n\n\tMyClass.prototype = Object.create(SuperClass.prototype); // inherit\n\tmixin(MyClass.prototype, OtherSuperClass.prototype); // mixin\n\n\tMyClass.prototype.myMethod = function() {\n\t  // do a thing\n\t};\n\nThe mixin function would copy the functions from the superclass prototype to the subclass prototype, the mixin function needs to be supplied by the user. An example of a mixin like function would be jQuery.extend.\n\n##Example: Using propertiesObject argument with Object.create\n\n\tvar o;\n\n\t// create an object with null as prototype\n\to = Object.create(null);\n\n\n\to = {};\n\t// is equivalent to:\n\to = Object.create(Object.prototype);\n\n\n\t// Example where we create an object with a couple of sample properties.\n\t// (Note that the second parameter maps keys to *property descriptors*.)\n\to = Object.create(Object.prototype, {\n\t  // foo is a regular 'value property'\n\t  foo: { writable: true, configurable: true, value: 'hello' },\n\t  // bar is a getter-and-setter (accessor) property\n\t  bar: {\n\t    configurable: false,\n\t    get: function() { return 10; },\n\t    set: function(value) { console.log('Setting `o.bar` to', value); }\n\t  }\n\t});\n\n\n\tfunction Constructor() {}\n\to = new Constructor();\n\t// is equivalent to:\n\to = Object.create(Constructor.prototype);\n\t// Of course, if there is actual initialization code in the\n\t// Constructor function, the Object.create cannot reflect it\n\n\n\t// create a new object whose prototype is a new, empty object\n\t// and a adding single property 'p', with value 42\n\to = Object.create({}, { p: { value: 42 } });\n\n\t// by default properties ARE NOT writable, enumerable or configurable:\n\to.p = 24;\n\to.p;\n\t// 42\n\n\to.q = 12;\n\tfor (var prop in o) {\n\t  console.log(prop);\n\t}\n\t// 'q'\n\n\tdelete o.p;\n\t// false\n\n\t// to specify an ES3 property\n\to2 = Object.create({}, {\n\t  p: {\n\t    value: 42,\n\t    writable: true,\n\t    enumerable: true,\n\t    configurable: true\n\t  }\n\t});\n\n##Polyfill\nThis polyfill covers the main use case which is creating a new object for which the prototype has been chosen but doesn't take the second argument into account.\n\n\tif (typeof Object.create != 'function') {\n\t  Object.create = (function() {\n\t    var Object = function() {};\n\t    return function (prototype) {\n\t      if (arguments.length > 1) {\n\t        throw Error('Second argument not supported');\n\t      }\n\t      if (typeof prototype != 'object') {\n\t        throw TypeError('Argument must be an object');\n\t      }\n\t      Object.prototype = prototype;\n\t      var result = new Object();\n\t      Object.prototype = null;\n\t      return result;\n\t    };\n\t  })();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} proto The object which should be the prototype of the newly-created object.\n\n@param {Object} propertiesObject If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). @optional dummy @throws Throws a TypeError exception if the proto parameter isn't null or an object."},{"annotation":"param","type":"{Object}","name":"proto","text":"The object which should be the prototype of the newly-created object.","theRestString":"@param {Object} propertiesObject If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). @optional dummy @throws Throws a TypeError exception if the proto parameter isn't null or an object."},{"annotation":"param","type":"{Object}","name":"propertiesObject","text":"If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties().","theRestString":"@optional dummy @throws Throws a TypeError exception if the proto parameter isn't null or an object."},{"annotation":"optional","name":"dummy","text":"","theRestString":"@throws Throws a TypeError exception if the proto parameter isn't null or an object."},{"annotation":"throws","name":"Throws","text":"a TypeError exception if the proto parameter isn't null or an object.","theRestString":""}],"commentRange":[51152,55454],"fileName":"ALL.js"},"defineProperties":{"annotation":"method","name":"defineProperties","text":"#Summary\nThe Object.defineProperties() method defines new or modifies existing properties directly on an object, returning the object.\n\n#Syntax\n\tObject.defineProperties(obj, props)\n\n#Description\nObject.defineProperties, in essence, defines all properties corresponding to the enumerable own properties of props on the object obj object.\n\n#Example\n\n\tObject.defineProperties(obj, {\n\t  \"property1\": {\n\t    value: true,\n\t    writable: true\n\t  },\n\t  \"property2\": {\n\t    value: \"Hello\",\n\t    writable: false\n\t  }\n\t  // etc. etc.\n\t});\n\n\n# Polyfill\n\nAssuming a pristine execution environment with all names and properties referring to their initial values, Object.defineProperties is almost completely equivalent (note the comment in isCallable) to the following reimplementation in JavaScript:\n\n\tfunction defineProperties(obj, properties) {\n\t  function convertToDescriptor(desc) {\n\t    function hasProperty(obj, prop) {\n\t      return Object.prototype.hasOwnProperty.call(obj, prop);\n\t    }\n\n\t    function isCallable(v) {\n\t      // NB: modify as necessary if other values than functions are callable.\n\t      return typeof v === \"function\";\n\t    }\n\n\t    if (typeof desc !== \"object\" || desc === null)\n\t      throw new TypeError(\"bad desc\");\n\n\t    var d = {};\n\n\t    if (hasProperty(desc, \"enumerable\"))\n\t      d.enumerable = !!obj.enumerable;\n\t    if (hasProperty(desc, \"configurable\"))\n\t      d.configurable = !!obj.configurable;\n\t    if (hasProperty(desc, \"value\"))\n\t      d.value = obj.value;\n\t    if (hasProperty(desc, \"writable\"))\n\t      d.writable = !!desc.writable;\n\t    if (hasProperty(desc, \"get\")) {\n\t      var g = desc.get;\n\n\t      if (!isCallable(g) && typeof g !== \"undefined\")\n\t        throw new TypeError(\"bad get\");\n\t      d.get = g;\n\t    }\n\t    if (hasProperty(desc, \"set\")) {\n\t      var s = desc.set;\n\t      if (!isCallable(s) && typeof s !== \"undefined\")\n\t        throw new TypeError(\"bad set\");\n\t      d.set = s;\n\t    }\n\n\t    if ((\"get\" in d || \"set\" in d) && (\"value\" in d || \"writable\" in d))\n\t      throw new TypeError(\"identity-confused descriptor\");\n\n\t    return d;\n\t  }\n\n\t  if (typeof obj !== \"object\" || obj === null)\n\t    throw new TypeError(\"bad obj\");\n\n\t  properties = Object(properties);\n\n\t  var keys = Object.keys(properties);\n\t  var descs = [];\n\n\t  for (var i = 0; i < keys.length; i++)\n\t    descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);\n\n\t  for (var i = 0; i < descs.length; i++)\n\t    Object.defineProperty(obj, descs[i][0], descs[i][1]);\n\n\t  return obj;\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object on which to define or modify properties.\n@param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object on which to define or modify properties.","theRestString":"@param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified."},{"annotation":"param","type":"{Object}","name":"props","text":"An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.","theRestString":""}],"commentRange":[55463,58215],"fileName":"ALL.js"},"defineProperty":{"annotation":"method","name":"defineProperty","text":"#Summary\nThe Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\n\n#Syntax\nObject.defineProperty(obj, prop, descriptor)\n\n#Description\nThis method allows precise addition to or modification of a property on an object. Normal property addition through assignment creates properties which show up during property enumeration (for...in loop or Object.keys method), whose values may be changed, and which may be deleted. This method allows these extra details to be changed from their defaults.\n\nProperty descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both.\n\nBoth data and accessor descriptors are objects. They share the following optional keys:\n\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\nDefaults to false.\n\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\nDefaults to false.\nA data descriptor also has the following optional keys:\n\n###value\nThe value associated with the property. Can be any valid JavaScript value (number, object, function, etc).\nDefaults to undefined.\nwritable\ntrue if and only if the value associated with the property may be changed with an assignment operator.\nDefaults to false.\nAn accessor descriptor also has the following optional keys:\n\n###get\nA function which serves as a getter for the property, or undefined if there is no getter. The function return will be used as the value of property.\nDefaults to undefined.\n\n###set\nA function which serves as a setter for the property, or undefined if there is no setter. The function will receive as only argument the new value being assigned to the property.\nDefaults to undefined.\nBear in mind that these options are not necessarily own properties so, if inherited, will be considered too. In order to ensure these defaults are preserved you might freeze the Object.prototype upfront, specify all options explicitly, or point to null as __proto__ property.\n\n\t// using __proto__\n\tObject.defineProperty(obj, 'key', {\n\t  __proto__: null, // no inherited properties\n\t  value: 'static'  // not enumerable\n\t                   // not configurable\n\t                   // not writable\n\t                   // as defaults\n\t});\n\n\t// being explicit\n\tObject.defineProperty(obj, 'key', {\n\t  enumerable: false,\n\t  configurable: false,\n\t  writable: false,\n\t  value: 'static'\n\t});\n\n\t// recycling same object\n\tfunction withValue(value) {\n\t  var d = withValue.d || (\n\t    withValue.d = {\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false,\n\t      value: null\n\t    }\n\t  );\n\t  d.value = value;\n\t  return d;\n\t}\n\t// ... and ...\n\tObject.defineProperty(obj, 'key', withValue('static'));\n\n\t// if freeze is available, prevents the code to add\n\t// value, get, set, enumerable, writable, configurable\n\t// to the Object prototype\n\t(Object.freeze || Object)(Object.prototype);\n\n#Examples\n\nIf you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see additional examples.\n\n##Example: Creating a property\n\nWhen the property specified doesn't exist in the object, Object.defineProperty() creates a new property as described. Fields may be omitted from the descriptor, and default values for those fields are imputed. All of the Boolean-valued fields default to false. The value, get, and set fields default to undefined. A property which is defined without get/set/value/writable is called â€œgenericâ€ and is â€œtypedâ€ as a data descriptor.\n\n\tvar o = {}; // Creates a new object\n\n\t// Example of an object property added with defineProperty with a data property descriptor\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: true,\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\t// 'a' property exists in the o object and its value is 37\n\n\t// Example of an object property added with defineProperty with an accessor property descriptor\n\tvar bValue = 38;\n\tObject.defineProperty(o, 'b', {\n\t  get: function() { return bValue; },\n\t  set: function(newValue) { bValue = newValue; },\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\to.b; // 38\n\t// 'b' property exists in the o object and its value is 38\n\t// The value of o.b is now always identical to bValue, unless o.b is redefined\n\n\t// You cannot try to mix both:\n\tObject.defineProperty(o, 'conflict', {\n\t  value: 0x9f91102,\n\t  get: function() { return 0xdeadbeef; }\n\t});\n\t// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors\n\n##Example: Modifying a property\n\nWhen the property already exists, Object.defineProperty() attempts to modify the property according to the values in the descriptor and the object's current configuration. If the old descriptor had its configurable attribute set to false (the property is said to be â€œnon-configurableâ€), then no attribute besides writable can be changed. In that case, it is also not possible to switch back and forth between the data and accessor property types.\n\nIf a property is non-configurable, its writable attribute can only be changed to false.\n\nA TypeError is thrown when attempts are made to change non-configurable property attributes (besides the writable attribute) unless the current and new values are the same.\n\n##Writable attribute\n\nWhen the writable property attribute is set to false, the property is said to be â€œnon-writableâ€. It cannot be reassigned.\n\n\tvar o = {}; // Creates a new object\n\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: false\n\t});\n\n\tconsole.log(o.a); // logs 37\n\to.a = 25; // No error thrown (it would throw in strict mode, even if the value had been the same)\n\tconsole.log(o.a); // logs 37. The assignment didn't work.\n\nAs seen in the example, trying to write into the non-writable property doesn't change it but doesn't throw an error either.\n\n##Enumerable attribute\n\nThe enumerable property attribute defines whether the property shows up in a for...in loop and Object.keys() or not.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', { value: 1, enumerable: true });\n\tObject.defineProperty(o, 'b', { value: 2, enumerable: false });\n\tObject.defineProperty(o, 'c', { value: 3 }); // enumerable defaults to false\n\to.d = 4; // enumerable defaults to true when creating a property by setting it\n\n\tfor (var i in o) {\n\t  console.log(i);\n\t}\n\t// logs 'a' and 'd' (in undefined order)\n\n\tObject.keys(o); // ['a', 'd']\n\n\to.propertyIsEnumerable('a'); // true\n\to.propertyIsEnumerable('b'); // false\n\to.propertyIsEnumerable('c'); // false\n\tConfigurable attribute\n\n\tThe configurable attribute controls at the same time whether the property can be deleted from the object and whether its attributes (other than writable) can be changed.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', {\n\t  get: function() { return 1; },\n\t  configurable: false\n\t});\n\n\tObject.defineProperty(o, 'a', { configurable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { enumerable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { set: function() {} }); // throws a TypeError (set was undefined previously)\n\tObject.defineProperty(o, 'a', { get: function() { return 1; } }); // throws a TypeError (even though the new get does exactly the same thing)\n\tObject.defineProperty(o, 'a', { value: 12 }); // throws a TypeError\n\n\tconsole.log(o.a); // logs 1\n\tdelete o.a; // Nothing happens\n\tconsole.log(o.a); // logs 1\n\n\nIf the configurable attribute of o.a had been true, none of the errors would be thrown and the property would be deleted at the end.\n\n##Example: Adding properties and default values\n\nIt's important to consider the way default values of attributes are applied. There is often a difference between simply using dot notation to assign a value and using Object.defineProperty(), as shown in the example below.\n\n\tvar o = {};\n\n\to.a = 1;\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: true,\n\t  configurable: true,\n\t  enumerable: true\n\t});\n\n\n\t// On the other hand,\n\tObject.defineProperty(o, 'a', { value: 1 });\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: false,\n\t  configurable: false,\n\t  enumerable: false\n\t});\n\n\n##Example: Custom Setters and Getters\n\nExample below shows how to implement a self-archiving object. When temperature property is set, the archive array gets a log entry.\n\n\tfunction Archiver() {\n\t  var temperature = null;\n\t  var archive = [];\n\n\t  Object.defineProperty(this, 'temperature', {\n\t    get: function() {\n\t      console.log('get!');\n\t      return temperature;\n\t    },\n\t    set: function(value) {\n\t      temperature = value;\n\t      archive.push({ val: temperature });\n\t    }\n\t  });\n\n\t  this.getArchive = function() { return archive; };\n\t}\n\n\tvar arc = new Archiver();\n\tarc.temperature; // 'get!'\n\tarc.temperature = 11;\n\tarc.temperature = 13;\n\tarc.getArchive(); // [{ val: 11 }, { val: 13 }]","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object on which to define the property.\n@param {String} prop The name of the property to be defined or modified.\n@param {Object} descriptor The descriptor for the property being defined or modified."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object on which to define the property.","theRestString":"@param {String} prop The name of the property to be defined or modified.\n@param {Object} descriptor The descriptor for the property being defined or modified."},{"annotation":"param","type":"{String}","name":"prop","text":"The name of the property to be defined or modified.","theRestString":"@param {Object} descriptor The descriptor for the property being defined or modified."},{"annotation":"param","type":"{Object}","name":"descriptor","text":"The descriptor for the property being defined or modified.","theRestString":""}],"commentRange":[58227,67721],"fileName":"ALL.js"},"freeze":{"annotation":"method","name":"freeze","text":"#Summary\nThe Object.freeze() method freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen.\n\n#Syntax\nObject.freeze(obj)\n\n#Description\nNothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail, either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode).\n\nValues cannot be changed for data properties. Accessor properties (getters and setters) work the same (and still give the illusion that you are changing the value). Note that values that are objects can still be modified, unless they are also frozen.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.freeze(obj);\n\n\tassert(Object.isFrozen(obj) === true);\n\n\t// Now any changes will fail\n\tobj.foo = 'quux'; // silently does nothing\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors\n\tfunction fail(){\n\t  'use strict';\n\t  obj.foo = 'sparky'; // throws a TypeError\n\t  delete obj.quaxxor; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\n\tfail();\n\n\t// Attempted changes through Object.defineProperty will also throw\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // throws a TypeError\n\tThe following example shows that object values in a frozen object can be mutated (freeze is shallow).\n\n\tobj = {\n\t  internal: {}\n\t};\n\n\tObject.freeze(obj);\n\tobj.internal.a = 'aValue';\n\n\tobj.internal.a // 'aValue'\n\n\t// To make obj fully immutable, freeze each object in obj.\n\t// To do so, we use this function.\n\n\tfunction deepFreeze(o) {\n\t  var prop, propKey;\n\t  Object.freeze(o); // First freeze the object.\n\t  for (propKey in o) {\n\t    prop = o[propKey];\n\t    if (!o.hasOwnProperty(propKey) || !(typeof prop === 'object') || Object.isFrozen(prop)) {\n\t      // If the object is on the prototype, not an object, or is already frozen,\n\t      // skip it. Note that this might leave an unfrozen reference somewhere in the\n\t      // object if there is an already frozen object containing an unfrozen object.\n\t      continue;\n\t    }\n\n\t    deepFreeze(prop); // Recursively call deepFreeze.\n\t  }\n\t}\n\n\tobj2 = {\n\t  internal: {}\n\t};\n\n\tdeepFreeze(obj2);\n\tobj2.internal.a = 'anotherValue';\n\tobj2.internal.a; // undefined","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param obj The object to freeze."},{"annotation":"param","name":"obj","text":"The object to freeze.","theRestString":""}],"commentRange":[67732,70578],"fileName":"ALL.js"},"getOwnPropertyDescriptor":{"annotation":"method","name":"getOwnPropertyDescriptor","text":"#Summary\nThe Object.getOwnPropertyDescriptor() method returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object.\n\n#Syntax\n\tObject.getOwnPropertyDescriptor(obj, prop)\n\n#Description\nThis method permits examination of the precise description of a property. A property in JavaScript consists of a string-valued name and a property descriptor. Further information about property descriptor types and their attributes can be found in Object.defineProperty().\n\nA property descriptor is a record with some of the following attributes:\n\n###value\nThe value associated with the property (data descriptors only).\n###writable\ntrue if and only if the value associated with the property may be changed (data descriptors only).\n###get\nA function which serves as a getter for the property, or undefined if there is no getter (accessor descriptors only).\n###set\nA function which serves as a setter for the property, or undefined if there is no setter (accessor descriptors only).\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\n\n#Examples\n\n\tvar o, d;\n\n\to = { get foo() { return 17; } };\n\td = Object.getOwnPropertyDescriptor(o, 'foo');\n\t// d is { configurable: true, enumerable: true, get: , set: undefined }\n\n\to = { bar: 42 };\n\td = Object.getOwnPropertyDescriptor(o, 'bar');\n\t// d is { configurable: true, enumerable: true, value: 42, writable: true }\n\n\to = {};\n\tObject.defineProperty(o, 'baz', { value: 8675309, writable: false, enumerable: false });\n\td = Object.getOwnPropertyDescriptor(o, 'baz');\n\t// d is { value: 8675309, writable: false, enumerable: false, configurable: false }","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object}obj The object in which to look for the property.\n@param {String}prop The name of the property whose description is to be retrieved.\n@returns A property descriptor of the given property if it exists on the object, undefined otherwise."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object in which to look for the property.","theRestString":"@param {String}prop The name of the property whose description is to be retrieved.\n@returns A property descriptor of the given property if it exists on the object, undefined otherwise."},{"annotation":"param","type":"{String}","name":"prop","text":"The name of the property whose description is to be retrieved.","theRestString":"@returns A property descriptor of the given property if it exists on the object, undefined otherwise."},{"annotation":"returns","name":"A","text":"property descriptor of the given property if it exists on the object, undefined otherwise.","theRestString":""}],"commentRange":[70589,72804],"fileName":"ALL.js"},"getOwnPropertyNames":{"annotation":"method","name":"getOwnPropertyNames","text":"#Summary\nThe Object.getOwnPropertyNames() method returns an array of all properties (enumerable or not) found directly upon a given object.\n\n#Syntax\nObject.getOwnPropertyNames(obj)\n\n#Description\nObject.getOwnPropertyNames returns an array whose elements are strings corresponding to the enumerable and non-enumerable properties found directly upon obj. The ordering of the enumerable properties in the array is consistent with the ordering exposed by a for...in loop (or by Object.keys) over the properties of the object. The ordering of the non-enumerable properties in the array, and among the enumerable properties, is not defined.\n\n#Examples\n##Example: Using getOwnPropertyNames\n\n\tvar arr = ['a', 'b', 'c'];\n\tprint(Object.getOwnPropertyNames(arr).sort()); // prints '0,1,2,length'\n\n\t// Array-like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tprint(Object.getOwnPropertyNames(obj).sort()); // prints '0,1,2'\n\n\t// Printing property names and values using Array.forEach\n\tObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n\t  print(val + ' -> ' + obj[val]);\n\t});\n\t// prints\n\t// 0 -> a\n\t// 1 -> b\n\t// 2 -> c\n\n\t// non-enumerable property\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: false } });\n\tmy_obj.foo = 1;\n\n\tprint(Object.getOwnPropertyNames(my_obj).sort()); // prints 'foo,getFoo'\n\nIf you want only the enumerable properties, see Object.keys() or use a for...in loop (although note that this will return enumerable properties not found directly upon that object but also along the prototype chain for the object unless the latter is filtered with hasOwnProperty()).\n\nItems on the prototype chain are not listed:\n\n\tfunction ParentClass() {}\n\tParentClass.prototype.inheritedMethod = function() {};\n\n\tfunction ChildClass() {\n\t  this.prop = 5;\n\t  this.method = function() {};\n\t}\n\tChildClass.prototype = new ParentClass;\n\tChildClass.prototype.prototypeMethod = function() {};\n\n\talert(\n\t  Object.getOwnPropertyNames(\n\t    new ChildClass() // ['prop', 'method']\n\t  )\n\t);\n\n##Example: Get Non-Enumerable Only\n\nThis uses the Array.prototype.filter() function to remove the enumerable keys (obtained with Object.keys()) from a list of all keys (obtained with Object.getOwnPropertyNames) leaving only the non-enumerable keys.\n\n\tvar target = myObject;\n\tvar enum_and_nonenum = Object.getOwnPropertyNames(target);\n\tvar enum_only = Object.keys(target);\n\tvar nonenum_only = enum_and_nonenum.filter(function(key) {\n\t  var indexInEnum = enum_only.indexOf(key);\n\t  if (indexInEnum == -1) {\n\t    // not found in enum_only keys mean the key is non-enumerable,\n\t    // so return true so we keep this in the filter\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t});\n\n\tconsole.log(nonenum_only);","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object whose enumerable and non-enumerable own properties are to be returned."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object whose enumerable and non-enumerable own properties are to be returned.","theRestString":""}],"commentRange":[72815,75714],"fileName":"ALL.js"},"isExtensible":{"annotation":"method","name":"isExtensible","text":"#Summary\nThe Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it).\n\n#Syntax\n\tObject.isExtensible(obj)\n\n#Description\nObjects are extensible by default: they can have new properties added to them, and (in engines that support __proto__  their __proto__ property) can be modified. An object can be marked as non-extensible using Object.preventExtensions(), Object.seal(), or Object.freeze().\n\n#Examples\n\t// New objects are extensible.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Sealed objects are by definition non-extensible.\n\tvar sealed = Object.seal({});\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// Frozen objects are also by definition non-extensible.\n\tvar frozen = Object.freeze({});\n\tassert(Object.isExtensible(frozen) === false);\n\tNotes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n\n\t> Object.isExtensible(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isExtensible(1)\n\tfalse","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object which should be checked.\n@return {boolean}"},{"annotation":"param","type":"{Object}","name":"obj","text":"The object which should be checked.","theRestString":"@return {boolean}"},{"annotation":"return","type":"{boolean}","text":"","theRestString":""}],"commentRange":[75725,77126],"fileName":"ALL.js"},"isFrozen":{"annotation":"method","name":"isFrozen","text":"#Summary\nThe Object.isFrozen() determines if an object is frozen.\n\n#Syntax\n\tObject.isFrozen(obj)\n\n#Description\nAn object is frozen if and only if it is not extensible, all its properties are non-configurable, and all its data properties (that is, properties which are not accessor properties with getter or setter components) are non-writable.\n\n#Examples\n\t// A new object is extensible, so it is not frozen.\n\tassert(Object.isFrozen({}) === false);\n\n\t// An empty object which is not extensible is vacuously frozen.\n\tvar vacuouslyFrozen = Object.preventExtensions({});\n\tassert(Object.isFrozen(vacuouslyFrozen) === true);\n\n\t// A new object with one property is also extensible, ergo not frozen.\n\tvar oneProp = { p: 42 };\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// Preventing extensions to the object still doesn't make it frozen,\n\t// because the property is still configurable (and writable).\n\tObject.preventExtensions(oneProp);\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// ...but then deleting that property makes the object vacuously frozen.\n\tdelete oneProp.p;\n\tassert(Object.isFrozen(oneProp) === true);\n\n\t// A non-extensible object with a non-writable but still configurable property is not frozen.\n\tvar nonWritable = { e: 'plep' };\n\tObject.preventExtensions(nonWritable);\n\tObject.defineProperty(nonWritable, 'e', { writable: false }); // make non-writable\n\tassert(Object.isFrozen(nonWritable) === false);\n\n\t// Changing that property to non-configurable then makes the object frozen.\n\tObject.defineProperty(nonWritable, 'e', { configurable: false }); // make non-configurable\n\tassert(Object.isFrozen(nonWritable) === true);\n\n\t// A non-extensible object with a non-configurable but still writable property also isn't frozen.\n\tvar nonConfigurable = { release: 'the kraken!' };\n\tObject.preventExtensions(nonConfigurable);\n\tObject.defineProperty(nonConfigurable, 'release', { configurable: false });\n\tassert(Object.isFrozen(nonConfigurable) === false);\n\n\t// Changing that property to non-writable then makes the object frozen.\n\tObject.defineProperty(nonConfigurable, 'release', { writable: false });\n\tassert(Object.isFrozen(nonConfigurable) === true);\n\n\t// A non-extensible object with a configurable accessor property isn't frozen.\n\tvar accessor = { get food() { return 'yum'; } };\n\tObject.preventExtensions(accessor);\n\tassert(Object.isFrozen(accessor) === false);\n\n\t// ...but make that property non-configurable and it becomes frozen.\n\tObject.defineProperty(accessor, 'food', { configurable: false });\n\tassert(Object.isFrozen(accessor) === true);\n\n\t// But the easiest way for an object to be frozen is if Object.freeze has been called on it.\n\tvar frozen = { 1: 81 };\n\tassert(Object.isFrozen(frozen) === false);\n\tObject.freeze(frozen);\n\tassert(Object.isFrozen(frozen) === true);\n\n\t// By definition, a frozen object is non-extensible.\n\tassert(Object.isExtensible(frozen) === false);\n\n\t// Also by definition, a frozen object is sealed.\n\tassert(Object.isSealed(frozen) === true);\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n\n\t> Object.isFrozen(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isFrozen(1)\n\ttrue                          // ES6 code","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object}obj The object which should be checked.\n@returns boolean"},{"annotation":"param","type":"{Object}","name":"obj","text":"The object which should be checked.","theRestString":"@returns boolean"},{"annotation":"returns","name":"boolean","text":"","theRestString":""}],"commentRange":[77131,80571],"fileName":"ALL.js"},"isSealed":{"annotation":"method","name":"isSealed","text":"#Summary\nThe Object.isSealed() method determines if an object is sealed.\n\n#Syntax\n\tObject.isSealed(obj)\n#Description\nReturns true if the object is sealed, otherwise false. An object is sealed if it is not extensible and if all its properties are non-configurable and therefore not removable (but not necessarily non-writable).\n\n#Examples\n\t// Objects aren't sealed by default.\n\tvar empty = {};\n\tassert(Object.isSealed(empty) === false);\n\n\t// If you make an empty object non-extensible, it is vacuously sealed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isSealed(empty) === true);\n\n\t// The same is not true of a non-empty object, unless its properties are all non-configurable.\n\tvar hasProp = { fee: 'fie foe fum' };\n\tObject.preventExtensions(hasProp);\n\tassert(Object.isSealed(hasProp) === false);\n\n\t// But make them all non-configurable and the object becomes sealed.\n\tObject.defineProperty(hasProp, 'fee', { configurable: false });\n\tassert(Object.isSealed(hasProp) === true);\n\n\t// The easiest way to seal an object, of course, is Object.seal.\n\tvar sealed = {};\n\tObject.seal(sealed);\n\tassert(Object.isSealed(sealed) === true);\n\n\t// A sealed object is, by definition, non-extensible.\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// A sealed object might be frozen, but it doesn't have to be.\n\tassert(Object.isFrozen(sealed) === true); // all properties also non-writable\n\n\tvar s2 = Object.seal({ p: 3 });\n\tassert(Object.isFrozen(s2) === false); // 'p' is still writable\n\n\tvar s3 = Object.seal({ get p() { return 0; } });\n\tassert(Object.isFrozen(s3) === true); // only configurability matters for accessor properties\n\n#Notes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n\n\t> Object.isSealed(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isSealed(1)\n\ttrue                          // ES6 code","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object which should be checked.\n@returns {boolean}"},{"annotation":"param","type":"{Object}","name":"obj","text":"The object which should be checked.","theRestString":"@returns {boolean}"},{"annotation":"returns","type":"{boolean}","text":"","theRestString":""}],"commentRange":[80577,82659],"fileName":"ALL.js"},"keys":{"annotation":"method","name":"keys","text":"#Summary\nThe Object.keys() method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n#Syntax\n\tObject.keys(obj)\n\n#Examples\n\tvar arr = ['a', 'b', 'c'];\n\tconsole.log(Object.keys(arr)); // console: ['0', '1', '2']\n\n\t// array like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tconsole.log(Object.keys(obj)); // console: ['0', '1', '2']\n\n\t// array like object with random key ordering\n\tvar an_obj = { 100: 'a', 2: 'b', 7: 'c' };\n\tconsole.log(Object.keys(an_obj)); // console: ['2', '7', '100']\n\n\t// getFoo is property which isn't enumerable\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\n\tmy_obj.foo = 1;\n\n\tconsole.log(Object.keys(my_obj)); // console: ['foo']\nIf you want all properties, even not enumerables, see Object.getOwnPropertyNames().\n\n#Polyfill\nTo add compatible Object.keys support in older environments that do not natively support it, copy the following snippet:\n\n\t// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n\tif (!Object.keys) {\n\t  Object.keys = (function() {\n\t    'use strict';\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty,\n\t        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n\t        dontEnums = [\n\t          'toString',\n\t          'toLocaleString',\n\t          'valueOf',\n\t          'hasOwnProperty',\n\t          'isPrototypeOf',\n\t          'propertyIsEnumerable',\n\t          'constructor'\n\t        ],\n\t        dontEnumsLength = dontEnums.length;\n\n\t    return function(obj) {\n\t      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n\t        throw new TypeError('Object.keys called on non-object');\n\t      }\n\n\t      var result = [], prop, i;\n\n\t      for (prop in obj) {\n\t        if (hasOwnProperty.call(obj, prop)) {\n\t          result.push(prop);\n\t        }\n\t      }\n\n\t      if (hasDontEnumBug) {\n\t        for (i = 0; i < dontEnumsLength; i++) {\n\t          if (hasOwnProperty.call(obj, dontEnums[i])) {\n\t            result.push(dontEnums[i]);\n\t          }\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t  }());\n\t}\nPlease note that the above code includes non-enumerable keys in IE7 (and maybe IE8), when passing in an object from a different window.\n\nFor a simple browser polyfill, see Javascript - Object.keys Browser Compatibility.","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object whose enumerable own properties are to be returned.\n@returns {Array<String>} method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object whose enumerable own properties are to be returned.","theRestString":"@returns {Array<String>} method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."},{"annotation":"returns","type":"{Array<String>}","name":"method","text":"returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).","theRestString":""}],"commentRange":[82667,85507],"fileName":"ALL.js"},"preventExtensions":{"annotation":"method","name":"preventExtensions","text":"#Summary\nThe Object.preventExtensions() method prevents new properties from ever being added to an object (i.e. prevents future extensions to the object).\n\n#Syntax\n\tObject.preventExtensions(obj)\n\n#Description\nAn object is extensible if new properties can be added to it. Object.preventExtensions() marks an object as no longer extensible, so that it will never have properties beyond the ones it had at the time it was marked as non-extensible. Note that the properties of a non-extensible object, in general, may still be deleted. Attempting to add new properties to a non-extensible object will fail, either silently or by throwing a TypeError (most commonly, but not exclusively, when in strict mode).\n\nObject.preventExtensions() only prevents addition of own properties. Properties can still be added to the object prototype. However, calling Object.preventExtensions() on an object will also prevent extensions on its __proto__  property.\n\nIf there is a way to turn an extensible object to a non-extensible one, there is no way to do the opposite in ECMAScript 5.\n\n#Examples\n\t// Object.preventExtensions returns the object being made non-extensible.\n\tvar obj = {};\n\tvar obj2 = Object.preventExtensions(obj);\n\tassert(obj === obj2);\n\n\t// Objects are extensible by default.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Object.defineProperty throws when adding a new property to a non-extensible object.\n\tvar nonExtensible = { removable: true };\n\tObject.preventExtensions(nonExtensible);\n\tObject.defineProperty(nonExtensible, 'new', { value: 8675309 }); // throws a TypeError\n\n\t// In strict mode, attempting to add new properties to a non-extensible object throws a TypeError.\n\tfunction fail() {\n\t  'use strict';\n\t  nonExtensible.newProperty = 'FAIL'; // throws a TypeError\n\t}\n\tfail();\n\n\t// EXTENSION (only works in engines supporting __proto__\n\t// (which is deprecated. Use Object.getPrototypeOf instead)):\n\t// A non-extensible object's prototype is immutable.\n\tvar fixed = Object.preventExtensions({});\n\tfixed.__proto__ = { oh: 'hai' }; // throws a TypeError\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return it.\n\n\t> Object.preventExtensions(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.preventExtensions(1)\n\t1                             // ES6 code","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object}obj The object which should be made non-extensible."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object which should be made non-extensible.","theRestString":""}],"commentRange":[85516,88196],"fileName":"ALL.js"},"valueOf":{"annotation":"method","name":"valueOf","text":"#Summary\nThe valueOf() method returns the primitive value of the specified object.\n\n#Syntax\n\tobject.valueOf()\n#Description\nJavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\n\nBy default, the valueOf method is inherited by every object descended from Object. Every built-in core object overrides this method to return an appropriate value. If an object has no primitive value, valueOf returns the object itself, which is displayed as:\n\n\t[object Object]\nYou can use valueOf within your own code to convert a built-in object into a primitive value. When you create a custom object, you can override Object.prototype.valueOf() to call a custom method instead of the default Object method.\n\n##Overriding valueOf for custom objects\n\nYou can create a function to be called in place of the default valueOf method. Your function must take no arguments.\n\nSuppose you have an object type myNumberType and you want to create a valueOf method for it. The following code assigns a user-defined function to the object's valueOf method:\n\n\tmyNumberType.prototype.valueOf = function() { return customPrimitiveValue; };\nWith the preceding code in place, any time an object of type myNumberType is used in a context where it is to be represented as a primitive value, JavaScript automatically calls the function defined in the preceding code.\n\nAn object's valueOf method is usually invoked by JavaScript, but you can invoke it yourself as follows:\n\n\tmyNumber.valueOf()\nNote: Objects in string contexts convert via the toString() method, which is different from String objects converting to string primitives using valueOf. All objects have a string conversion, if only \"[object type]\". But many objects do not convert to number, boolean, or function.\n#Examples\n##Example: Using valueOf\n\n\to = new Object();\n\tmyVar = o.valueOf();      // [object Object]","commentRange":[98502,100539],"fileName":"ALL.js"},"seal":{"annotation":"method","name":"seal","text":"#Summary\nThe Object.seal() method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.\n\n#Syntax\n\tObject.seal(obj)\n\n#Description\nBy default, objects are extensible (new properties can be added to them). Sealing an object prevents new properties from being added and marks all existing properties as non-configurable. This has the effect of making the set of properties on the object fixed and immutable. Making all properties non-configurable also prevents them from being converted from data properties to accessor properties and vice versa, but it does not prevent the values of data properties from being changed. Attempting to delete or add properties to a sealed object, or to convert a data property to accessor or vice versa, will fail, either silently or by throwing a TypeError (most commonly, although not exclusively, when in strict mode code).\n\nThe prototype chain remains untouched. However, the __proto__  property is sealed as well.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed.\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.seal(obj);\n\n\tassert(o === obj);\n\tassert(Object.isSealed(obj) === true);\n\n\t// Changing property values on a sealed object still works.\n\tobj.foo = 'quux';\n\n\t// But you can't convert data properties to accessors, or vice versa.\n\tObject.defineProperty(obj, 'foo', { get: function() { return 'g'; } }); // throws a TypeError\n\n\t// Now any changes, other than to property values, will fail.\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\tdelete obj.foo; // silently doesn't delete the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors.\n\tfunction fail() {\n\t  'use strict';\n\t  delete obj.foo; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\tfail();\n\n\t// Attempted additions through Object.defineProperty will also throw.\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // changes existing property value","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param  obj The object which should be sealed."},{"annotation":"param","name":"obj","text":"The object which should be sealed.","theRestString":""}],"commentRange":[100544,102885],"fileName":"ALL.js"}}},"javascript.Any":{"annotation":"class","name":"Any","text":"This is an artificial type that means 'any value is valid here'","commentRange":[102891,102971],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[39411,40943],"fileName":"ALL.js"},"absoluteName":"javascript.Any"},"javascript.ObjectPrototype":{"annotation":"class","name":"ObjectPrototype","text":"Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\n\n#Description\nThe Object.prototype property represents the Object prototype object.\n\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden (except an Object with a null prototype, i.e. Object.create(null)). For example, other constructors' prototypes override the constructor property and provide their own toString() methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.\n\n#Examples\nSince Javascript doesn't exactly have sub-class objects, prototype is a useful workaround to make a â€œbase classâ€ object of certain functions that act as objects. For example:\n\n\tvar Person = function() {\n\t  this.canTalk = true;\n\t  this.greet = function() {\n\t    if (this.canTalk) {\n\t      console.log('Hi, I'm ' + this.name);\n\t    }\n\t  };\n\t};\n\n\tvar Employee = function(name, title) {\n\t  this.name = name;\n\t  this.title = title;\n\t  this.greet = function() {\n\t    if (this.canTalk) {\n\t      console.log(\"Hi, I'm \" + this.name + \", the \" + this.title);\n\t    }\n\t  };\n\t};\n\tEmployee.prototype = new Person();\n\n\tvar Customer = function(name) {\n\t  this.name = name;\n\t};\n\tCustomer.prototype = new Person();\n\n\tvar Mime = function(name) {\n\t  this.name = name;\n\t  this.canTalk = false;\n\t};\n\tMime.prototype = new Person();\n\n\tvar bob = new Employee('Bob', 'Builder');\n\tvar joe = new Customer('Joe');\n\tvar rg = new Employee('Red Green', 'Handyman');\n\tvar mike = new Customer('Mike');\n\tvar mime = new Mime('Mime');\n\tbob.greet();\n\tjoe.greet();\n\trg.greet();\n\tmike.greet();\n\tmime.greet();\n\nThis will output:\n\n\tHi, I'm Bob, the Builder\n\tHi, I'm Joe\n\tHi, I'm Red Green, the Handyman\n\tHi, I'm Mike","commentRange":[102973,104926],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[102973,104926],"fileName":"ALL.js"},"absoluteName":"javascript.ObjectPrototype","properties":{"constructor":{"annotation":"property","type":"{Function}","name":"constructor","text":"Specifies the function that creates an object's prototype.\n\n##Summary\nReturns a reference to the Object function that created the instance's prototype. Note that the value of this property is a reference to the function itself, not a string containing the function's name. The value is only read-only for primitive values such as 1, true and \"test\".\n\n##Description\n\nAll objects inherit a constructor property from their prototype:\n\n\tvar o = {};\n\to.constructor === Object; // true\n\n\tvar a = [];\n\ta.constructor === Array; // true\n\n\tvar n = new Number(3);\n\tn.constructor === Number; // true\n\n##Examples\n\n###Example: Displaying the constructor of an object\n\nThe following example creates a prototype, Tree, and an object of that type, theTree. The example then displays the constructor property for the object theTree.\n\n\tfunction Tree(name) {\n\t  this.name = name;\n\t}\n\n\tvar theTree = new Tree('Redwood');\n\tconsole.log('theTree.constructor is ' + theTree.constructor);\n\tThis example displays the following output:\n\n\ttheTree.constructor is function Tree(name) {\n\t  this.name = name;\n\t}\n\n###Example: Changing the constructor of an object\n\nThe following example shows how to modify constructor value of generic objects. Only true, 1 and \"test\" will not be affected as they have read-only native constructors. This example shows that it is not always safe to rely on the constructor property of an object.\n\n\tfunction Type () {}\n\n\tvar types = [\n\t  new Array(),\n\t  [],\n\t  new Boolean(),\n\t  true,             // remains unchanged\n\t  new Date(),\n\t  new Error(),\n\t  new Function(),\n\t  function () {},\n\t  Math,\n\t  new Number(),\n\t  1,                // remains unchanged\n\t  new Object(),\n\t  {},\n\t  new RegExp(),\n\t  /(?:)/,\n\t  new String(),\n\t  'test'            // remains unchanged\n\t];\n\tfor (var i = 0; i < types.length; i++) {\n\t  types[i].constructor = Type;\n\t  types[i] = [types[i].constructor, types[i] instanceof Type, types[i].toString()];\n\t}\n\tconsole.log(types.join('\\n'));\n\tThis example displays the following output:\n\n\tfunction Type() {},false,\n\tfunction Type() {},false,\n\tfunction Type() {},false,false\n\tfunction Boolean() {\n\t    [native code]\n\t},false,true\n\tfunction Type() {},false,Mon Sep 01 2014 16:03:49 GMT+0600\n\tfunction Type() {},false,Error\n\tfunction Type() {},false,function anonymous() {\n\n\t}\n\tfunction Type() {},false,function () {}\n\tfunction Type() {},false,[object Math]\n\tfunction Type() {},false,0\n\tfunction Number() {\n\t    [native code]\n\t},false,1\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,\n\tfunction String() {\n\t    [native code]\n\t},false,Ñ‚ÐµÑÑ‚","commentRange":[104930,107658],"fileName":"ALL.js"},"__noSuchMethod__":{"annotation":"property","type":"{Function}","name":"__noSuchMethod__","text":"Allows a function to be defined that will be executed when an undefined object member is called as a method.","commentRange":[107666,107933],"fileName":"ALL.js"}}},"javascript.String":{"annotation":"class","name":"String","text":"#Summary\nThe String global object is a constructor for strings, or a sequence of characters.\n\n#Syntax\nString literals take the forms:\n\n\t'string text' \"string text\" \"ä¸­æ–‡ espaÃ±ol English à¤¹à¤¿à¤¨à¥à¤¦à¥€ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© portuguÃªs à¦¬à¦¾à¦‚à¦²à¦¾ Ñ€ÑƒÑÑÐºÐ¸Ð¹ æ—¥æœ¬èªž à¨ªà©°à¨œà¨¾à¨¬à©€ í•œêµ­ì–´\"\n\nBeside regular, printable characters, special characters can be encoded using escape notation:\n\n\tCode\tOutput\n\t\\0\tthe NUL character\n\t\\'\tsingle quote\n\t\\\"\tdouble quote\n\t\\\\\tbackslash\n\t\\n\tnew line\n\t\\r\tcarriage return\n\t\\v\tvertical tab\n\t\\t\ttab\n\t\\b\tbackspace\n\t\\f\tform feed\n\t\\uXXXX\tunicode codepoint\n\t\\xXX\tthe Latin-1 character\n\nOr, using the String global object directly:\n\n\tString(thing) new String(thing)\n\n#Description\nStrings are useful for holding data that can be represented in text form. Some of the most-used operations on strings are to check their length, to build and concatenate them using the + and += string operators, checking for the existence or location of substrings with the indexOf method, or extracting substrings with the substring method.\n\n##Character access\n\nThere are two ways to access an individual character in a string. The first is the charAt method:\n\n\treturn 'cat'.charAt(1); // returns \"a\"\n\nThe other way (introduced in ECMAScript 5) is to treat the string as an array-like object, where individual characters correspond to a numerical index:\n\n\treturn 'cat'[1]; // returns \"a\"\n\nFor character access using bracket notation, attempting to delete or assign a value to these properties will not succeed. The properties involved are neither writable nor configurable. (See Object.defineProperty for more information.)\n\n##Comparing strings\n\nC developers have the strcmp() function for comparing strings. In JavaScript, you just use the less-than and greater-than operators:\n\n\tvar a = \"a\";\n\tvar b = \"b\";\n\tif (a < b) // true\n\t  print(a + \" is less than \" + b);\n\telse if (a > b)\n\t  print(a + \" is greater than \" + b);\n\telse\n\t  print(a + \" and \" + b + \" are equal.\");\n\nA similar result can be achieved using the localeCompare method inherited by String instances.\n\n##Distinction between string primitives and String objects\n\nNote that JavaScript distinguishes between String objects and primitive string values. (The same is true of Boolean and Numbers.)\n\nString literals (denoted by double or single quotes) and strings returned from String calls in a non-constructor context (i.e., without using the new keyword) are primitive strings. JavaScript automatically converts primitives to String objects, so that it's possible to use String object methods for primitive strings. In contexts where a method is to be invoked on a primitive string or a property lookup occurs, JavaScript will automatically wrap the string primitive and call the method or perform the property lookup.\n\n\tvar s_prim = \"foo\";\n\tvar s_obj = new String(s_prim);\n\n\tconsole.log(typeof s_prim); // Logs \"string\"\n\tconsole.log(typeof s_obj);  // Logs \"object\"\n\tString primitives and String objects also give different results when using eval. Primitives passed to eval are treated as source code; String objects are treated as all other objects are, by returning the object. For example:\n\n\ts1 = \"2 + 2\";               // creates a string primitive\n\ts2 = new String(\"2 + 2\");   // creates a String object\n\tconsole.log(eval(s1));      // returns the number 4\n\tconsole.log(eval(s2));      // returns the string \"2 + 2\"\n\nFor these reasons, code may break when it encounters String objects when it expects a primitive string instead, although generally authors need not worry about the distinction.\n\nA String object can always be converted to its primitive counterpart with the valueOf method.\n\n\tconsole.log(eval(s2.valueOf())); // returns the number 4\n\nNote: For another possible approach to strings in JavaScript, please read the article about StringView â€“ a C-like representation of strings based on typed arrays.\n\n\n#String generic methods\nThe String instance methods are also available in Firefox as of JavaScript 1.6 (though not part of the ECMAScript standard) on the String object for applying String methods to any object:\n\n\tvar num = 15;\n\talert(String.replace(num, /5/, '2'));\n\nGenerics are also available on Array methods.\n\nThe following is a shim to provide support to non-supporting browsers:\n\n\t//globals define\n\t// Assumes all supplied String instance methods already present\n\t// (one may use shims for these if not available)\n\t(function () {\n\t    'use strict';\n\n\t    var i,\n\t        // We could also build the array of methods with the following, but the\n\t        //   getOwnPropertyNames() method is non-shimable:\n\t        // Object.getOwnPropertyNames(String).filter(function (methodName)\n\t        //  {return typeof String[methodName] === 'function'});\n\t        methods = [\n\t            'quote', 'substring', 'toLowerCase', 'toUpperCase', 'charAt',\n\t            'charCodeAt', 'indexOf', 'lastIndexOf', 'startsWith', 'endsWith',\n\t            'trim', 'trimLeft', 'trimRight', 'toLocaleLowerCase',\n\t            'toLocaleUpperCase', 'localeCompare', 'match', 'search',\n\t            'replace', 'split', 'substr', 'concat', 'slice'\n\t        ],\n\t        methodCount = methods.length,\n\t        assignStringGeneric = function (methodName) {\n\t            var method = String.prototype[methodName];\n\t            String[methodName] = function (arg1) {\n\t                return method.apply(arg1, Array.prototype.slice.call(arguments, 1));\n\t            };\n\t        };\n\n\t    for (i = 0; i < methodCount; i++) {\n\t        assignStringGeneric(methods[i]);\n\t    }\n\t}());\n\n#Examples\n##String conversion\n\nIt's possible to use String as a \"safer\" toString alternative, as although it still normally calls the underlying toString, it also works for null and undefined. For example:\n\n\tvar outputStrings = [];\n\tfor (let i = 0, n = inputValues.length; i < n; ++i) {\n\t  outputStrings.push(String(inputValues[i]));\n\t}","commentRange":[107937,113803],"fileName":"ALL.js","module":{"annotation":"module","name":"javascript","text":"","commentRange":[107937,113803],"fileName":"ALL.js"},"absoluteName":"javascript.String","properties":{"length":{"annotation":"property","type":"{Number}","name":"length","text":"#Summary\nThe length property represents the length of a string.\n\n#Syntax\n\n\tstr.length\n\n#Description\n\nThis property returns the number of code units in the string. UTF-16, the string format used by JavaScript, uses a single 16-bit code unit to represent the most common characters, but needs to use two code units for less commonly-used characters, so it's possible for the value returned by length to not match the actual number of characters in the string.\n\nFor an empty string, length is 0.\n\nThe static property String.length returns the value 1.\n\n#Examples\n\n\tvar x = \"Mozilla\";\n\tvar empty = \"\";\n\n\tconsole.log(\"Mozilla is \" + x.length + \" code units long\");\n\t// \"Mozilla is 7 code units long\" \n\n\tconsole.log(\"The empty string is has a length of \" + empty.length);\n\t // \"The empty string is has a length of 0\"","commentRange":[113810,114655],"fileName":"ALL.js"}},"methods":{"fromCharCode":{"annotation":"method","name":"fromCharCode","text":"#Summary\nThe static String.fromCharCode() method returns a string created by using the specified sequence of Unicode values.\n\n#Syntax\nString.fromCharCode(num1, ..., numN)\n#Description\nThis method returns a string and not a String object.\n\nBecause fromCharCode is a static method of String, you always use it as String.fromCharCode(), rather than as a method of a String object you created.\n\n#Examples\nExample: Using fromCharCode\n\nThe following example returns the string \"ABC\".\n\n\tString.fromCharCode(65,66,67)\n\n#Getting it to work with higher values\nAlthough most common Unicode values can be represented with one 16-bit number (as expected early on during JavaScript standardization) and fromCharCode() can be used to return a single character for the most common values (i.e., UCS-2 values which are the subset of UTF-16 with the most common characters), in order to deal with ALL legal Unicode values (up to 21 bits), fromCharCode() alone is inadequate. Since the higher code point characters use two (lower value) \"surrogate\" numbers to form a single character, String.fromCodePoint() (part of the ES6 draft) can be used to return such a pair and thus adequately represent these higher valued characters.","children":[{"annotation":"return","type":"{String}","name":"returns","text":"a string created by using the specified sequence of Unicode values.}","theRestString":"@param p1,...pn A sequence of numbers that are Unicode values"},{"annotation":"param","name":"p1","text":",...pn A sequence of numbers that are Unicode values","theRestString":""}],"commentRange":[114660,116056],"fileName":"ALL.js"},"charAt":{"annotation":"method","name":"charAt","text":"#Summary\nThe charAt() method returns the specified character from a string.\n\n#Syntax\n\tstr.charAt(index)\n#Description\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string called stringName is stringName.length - 1. If the index you supply is out of range, JavaScript returns an empty string.\n\n#Examples\n##Example: Displaying characters at different locations in a string\n\nThe following example displays characters at different locations in the string \"Brave new world\":\n\n\tvar anyString = \"Brave new world\";\n\n\tconsole.log(\"The character at index 0   is '\" + anyString.charAt(0)   + \"'\");\n\tconsole.log(\"The character at index 1   is '\" + anyString.charAt(1)   + \"'\");\n\tconsole.log(\"The character at index 2   is '\" + anyString.charAt(2)   + \"'\");\n\tconsole.log(\"The character at index 3   is '\" + anyString.charAt(3)   + \"'\");\n\tconsole.log(\"The character at index 4   is '\" + anyString.charAt(4)   + \"'\");\n\tconsole.log(\"The character at index 999 is '\" + anyString.charAt(999) + \"'\");\n\nThese lines display the following:\n\n\tThe character at index 0 is 'B'\n\tThe character at index 1 is 'r'\n\tThe character at index 2 is 'a'\n\tThe character at index 3 is 'v'\n\tThe character at index 4 is 'e'\n\tThe character at index 999 is ''\n\n##Example: Getting whole characters\n\nThe following provides a means of ensuring that going through a string loop always provides a whole character, even if the string contains characters that are not in the Basic Multi-lingual Plane.\n\n\tvar str = 'A \\uD87E\\uDC04 Z'; // We could also use a non-BMP character directly\n\tfor (var i=0, chr; i < str.length; i++) {\n\t  if ((chr = getWholeChar(str, i)) === false) {\n\t    continue;\n\t  } // Adapt this line at the top of each loop, passing in the whole string and\n\t    // the current iteration and returning a variable to represent the \n\t    // individual character\n\n\t  alert(chr);\n\t}\n\n\tfunction getWholeChar (str, i) {\n\t  var code = str.charCodeAt(i);     \n\t \n\t  if (isNaN(code)) {\n\t    return ''; // Position not found\n\t  }\n\t  if (code < 0xD800 || code > 0xDFFF) {\n\t    return str.charAt(i);\n\t  }\n\n\t  // High surrogate (could change last hex to 0xDB7F to treat high private\n\t  // surrogates as single characters)\n\t  if (0xD800 <= code && code <= 0xDBFF) { \n\t    if (str.length <= (i+1))  {\n\t      throw 'High surrogate without following low surrogate';\n\t    }\n\t    var next = str.charCodeAt(i+1);\n\t      if (0xDC00 > next || next > 0xDFFF) {\n\t        throw 'High surrogate without following low surrogate';\n\t      }\n\t      return str.charAt(i)+str.charAt(i+1);\n\t  }\n\t  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n\t  if (i === 0) {\n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  var prev = str.charCodeAt(i-1);\n\t  \n\t  // (could change last hex to 0xDB7F to treat high private\n\t  // surrogates as single characters)\n\t  if (0xD800 > prev || prev > 0xDBFF) { \n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  // We can pass over low surrogates now as the second component\n\t  // in a pair which we have already processed\n\t  return false; \n\t}\n\nIn an exclusive JavaScript 1.7+ environment (such as Firefox) which allows destructured assignment, the following is a more succinct and somewhat more flexible alternative in that it does incrementing for an incrementing variable automatically (if the character warrants it in being a surrogate pair).\n\n\tvar str = 'A\\uD87E\\uDC04Z'; // We could also use a non-BMP character directly\n\tfor (var i=0, chr; i < str.length; i++) {\n\t  [chr, i] = getWholeCharAndI(str, i);\n\t  // Adapt this line at the top of each loop, passing in the whole string and\n\t  // the current iteration and returning an array with the individual character\n\t  // and 'i' value (only changed if a surrogate pair)\n\n\t  alert(chr);\n\t}\n\n\tfunction getWholeCharAndI (str, i) {\n\t  var code = str.charCodeAt(i);\n\n\t  if (isNaN(code)) {\n\t    return ''; // Position not found\n\t  }\n\t  if (code < 0xD800 || code > 0xDFFF) {\n\t    return [str.charAt(i), i]; // Normal character, keeping 'i' the same\n\t  }\n\n\t  // High surrogate (could change last hex to 0xDB7F to treat high private \n\t  // surrogates as single characters)\n\t  if (0xD800 <= code && code <= 0xDBFF) { \n\t    if (str.length <= (i+1))  {\n\t      throw 'High surrogate without following low surrogate';\n\t    }\n\t    var next = str.charCodeAt(i+1);\n\t      if (0xDC00 > next || next > 0xDFFF) {\n\t        throw 'High surrogate without following low surrogate';\n\t      }\n\t      return [str.charAt(i)+str.charAt(i+1), i+1];\n\t  }\n\t  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n\t  if (i === 0) {\n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  var prev = str.charCodeAt(i-1);\n\n\t  // (could change last hex to 0xDB7F to treat high private surrogates\n\t  // as single characters)\n\t  if (0xD800 > prev || prev > 0xDBFF) { \n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  // Return the next character instead (and increment)\n\t  return [str.charAt(i+1), i+1]; \n\t}\n\n\n##Example: Fixing charAt to support non-Basic-Multilingual-Plane (BMP) characters\n\nWhile the example above may be more frequently useful for those wishing to support non-BMP characters (since it does not require the caller to know where any non-BMP character might appear), in the event that one does wish, in choosing a character by index, to treat the surrogate pairs within a string as the single characters they represent, one can use the following:\n\n\tfunction fixedCharAt (str, idx) {\n\t  var ret = '';\n\t  str += '';\n\t  var end = str.length;\n\n\t  var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t  while ((surrogatePairs.exec(str)) != null) {\n\t    var li = surrogatePairs.lastIndex;\n\t    if (li - 2 < idx) {\n\t      idx++;\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\n\t  if (idx >= end || idx < 0) {\n\t    return '';\n\t  }\n\n\t  ret += str.charAt(idx);\n\n\t  if (/[\\uD800-\\uDBFF]/.test(ret) && /[\\uDC00-\\uDFFF]/.test(str.charAt(idx+1))) {\n\t    // Go one further, since one of the \"characters\" is part of a surrogate pair\n\t    ret += str.charAt(idx+1); \n\t  }\n\t  return ret;\n\t}","children":[{"annotation":"param","type":"{Number}","name":"index","text":"An integer between 0 and 1-less-than the length of the string.","theRestString":"@return {String} the specified character from a string."},{"annotation":"return","type":"{String}","name":"the","text":"specified character from a string.","theRestString":""}],"commentRange":[116064,122356],"fileName":"ALL.js"},"charCodeAt":{"annotation":"method","name":"charCodeAt","text":"#Summary\nThe charCodeAt() method returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000).\n\n#Syntax\n\tstr.charCodeAt(index)\n#Description\nUnicode code points range from 0 to 1,114,111. The first 128 Unicode code points are a direct match of the ASCII character encoding. For information on Unicode, see the JavaScript Guide.\n\nNote that charCodeAt will always return a value that is less than 65,536. This is because the higher code points are represented by a pair of (lower valued) \"surrogate\" pseudo-characters which are used to comprise the real character. Because of this, in order to examine or reproduce the full character for individual characters of value 65,536 and above, for such characters, it is necessary to retrieve not only charCodeAt(i), but also charCodeAt(i+1) (as if examining/reproducing a string with two letters). See example 2 and 3 below.\n\ncharCodeAt returns NaN if the given index is not greater than 0 or is greater than the length of the string.\n\nBackward compatibilty: In historic versions (like JavaScript 1.2) the charCodeAt method returns a number indicating the ISO-Latin-1 codeset value of the character at the given index. The ISO-Latin-1 codeset ranges from 0 to 255. The first 0 to 127 are a direct match of the ASCII character set.\n\n#Examples\n##Example: Using charCodeAt\n\nThe following example returns 65, the Unicode value for A.\n\n\t\"ABC\".charCodeAt(0) // returns 65\n\n#Example: Fixing charCodeAt to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is unknown\n\nThis version might be used in for loops and the like when it is unknown whether non-BMP characters exist before the specified index position.\n\n\tfunction fixedCharCodeAt (str, idx) {\n\t    // ex. fixedCharCodeAt ('\\uD800\\uDC00', 0); // 65536\n\t    // ex. fixedCharCodeAt ('\\uD800\\uDC00', 1); // false\n\t    idx = idx || 0;\n\t    var code = str.charCodeAt(idx);\n\t    var hi, low;\n\t    \n\t    // High surrogate (could change last hex to 0xDB7F to treat high\n\t    // private surrogates as single characters)\n\t    if (0xD800 <= code && code <= 0xDBFF) {\n\t        hi = code;\n\t        low = str.charCodeAt(idx+1);\n\t        if (isNaN(low)) {\n\t            throw 'High surrogate not followed by low surrogate in fixedCharCodeAt()';\n\t        }\n\t        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate\n\t        // We return false to allow loops to skip this iteration since should have\n\t        // already handled high surrogate above in the previous iteration\n\t        return false;\n\t        //hi = str.charCodeAt(idx-1);\n\t        //low = code;\n\t        //return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    return code;\n\t}\n\n##Example: Fixing charCodeAt to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is known\n\n\tfunction knownCharCodeAt (str, idx) {\n\t    str += '';\n\t    var code,\n\t        end = str.length;\n\n\t    var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t    while ((surrogatePairs.exec(str)) != null) {\n\t        var li = surrogatePairs.lastIndex;\n\t        if (li - 2 < idx) {\n\t            idx++;\n\t        }\n\t        else {\n\t            break;\n\t        }\n\t    }\n\n\t    if (idx >= end || idx < 0) {\n\t        return NaN;\n\t    }\n\n\t    code = str.charCodeAt(idx);\n\n\t    var hi, low;\n\t    if (0xD800 <= code && code <= 0xDBFF) {\n\t        hi = code;\n\t        low = str.charCodeAt(idx+1);\n\t        // Go one further, since one of the \"characters\" is part of a surrogate pair\n\t        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    return code;\n\t}","children":[{"annotation":"param","type":"{Number}","name":"index","text":"An integer greater than or equal to 0 and less than the length of the string; if it is not a number, it defaults to 0.","theRestString":"@returns {Number}returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000)."},{"annotation":"returns","type":"{Number}","name":"returns","text":"the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000).","theRestString":""}],"commentRange":[122361,126355],"fileName":"ALL.js"},"concat":{"annotation":"method","name":"concat","text":"#Summary\nThe concat() method combines the text of two or more strings and returns a new string.\n\n#Syntax\n\tstr.concat(string2, string3[, ..., stringN])\n\n#Description\nThe concat function combines the text from one or more strings and returns a new string. Changes to the text in one string do not affect the other string.\n\n#Examples\n##Example: Using concat\n\nThe following example combines strings into a new string.\n\n\tvar hello = \"Hello, \";\n\tconsole.log(hello.concat(\"Kevin\", \" have a nice day.\")); \n\n\t// Hello, Kevin have a nice day. \n\n#Performance\nIt is strongly recommended that assignment operators (+, +=) are used instead of the concat method. See this perfomance test.","children":[{"annotation":"param","name":"string2...stringN","text":"Strings to concatenate to this string.","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[126361,127140],"fileName":"ALL.js"},"indexOf":{"annotation":"method","name":"indexOf","text":"#Summary\nThe indexOf() method returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.\n\n#Syntax\n\tstr.indexOf(searchValue[, fromIndex])\n#Description\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character of a string called stringName is stringName.length - 1.\n\n\t\"Blue Whale\".indexOf(\"Blue\");     // returns  0\n\t\"Blue Whale\".indexOf(\"Blute\");    // returns -1\n\t\"Blue Whale\".indexOf(\"Whale\", 0); // returns  5\n\t\"Blue Whale\".indexOf(\"Whale\", 5); // returns  5\n\t\"Blue Whale\".indexOf(\"\", 9);      // returns  9\n\t\"Blue Whale\".indexOf(\"\", 10);     // returns 10\n\t\"Blue Whale\".indexOf(\"\", 11);     // returns 10\n\n##Case-sensitivity\n\nThe indexOf method is case sensitive. For example, the following expression returns -1:\n\n\"Blue Whale\".indexOf(\"blue\") // returns -1\n##Checking occurrences\n\nNote that '0' doesn't evaluate to true and '-1' doesn't evaluate to false. Therefore, when checking if a specific string exists within another string the correct way to check would be:\n\n\"Blue Whale\".indexOf(\"Blue\") != -1; // true\n\"Blue Whale\".indexOf(\"Bloe\") != -1; // false\n\n#Examples\n##Example: Using indexOf and lastIndexOf\n\nThe following example uses indexOf and lastIndexOf to locate values in the string \"Brave new world\".\n\n\tvar anyString = \"Brave new world\";\n\n\tconsole.log(\"The index of the first w from the beginning is \" + anyString.indexOf(\"w\"));\n\t// Displays 8\n\tconsole.log(\"The index of the first w from the end is \" + anyString.lastIndexOf(\"w\")); \n\t// Displays 10\n\n\tconsole.log(\"The index of 'new' from the beginning is \" + anyString.indexOf(\"new\"));   \n\t// Displays 6\n\tconsole.log(\"The index of 'new' from the end is \" + anyString.lastIndexOf(\"new\"));\n\t// Displays 6\n##Example: indexOf and case-sensitivity\n\nThe following example defines two string variables. The variables contain the same string except that the second string contains uppercase letters. The first log method displays 19. But because the indexOf method is case sensitive, the string \"cheddar\" is not found in myCapString, so the second log method displays -1.\n\n\tvar myString    = \"brie, pepper jack, cheddar\";\n\tvar myCapString = \"Brie, Pepper Jack, Cheddar\";\n\n\tconsole.log('myString.indexOf(\"cheddar\") is ' + myString.indexOf(\"cheddar\"));    \n\t// Displays 19\n\tconsole.log('myCapString.indexOf(\"cheddar\") is ' + myCapString.indexOf(\"cheddar\")); \n\t// Displays -1\n##Example: Using indexOf to count occurrences of a letter in a string\n\nThe following example sets count to the number of occurrences of the letter x in the string str:\n\n\tcount = 0;\n\tpos = str.indexOf(\"x\");\n\n\twhile ( pos != -1 ) {\n\t   count++;\n\t   pos = str.indexOf( \"x\",pos + 1 );\n\t}","children":[{"annotation":"param","type":"{String}","name":"searchValue","text":"A string representing the value to search for.","theRestString":"@param {Number} fromIndex The location within the calling string to start the search from. It can be any integer. The default value is 0. If fromIndex < 0 the entire string is searched (same as passing 0). If fromIndex >= str.length, the method will return -1 unless searchValue is an empty string in which case str.length is returned. \n@optional dummy @returns {Number} the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found."},{"annotation":"param","type":"{Number}","name":"fromIndex","text":"The location within the calling string to start the search from. It can be any integer. The default value is 0. If fromIndex < 0 the entire string is searched (same as passing 0). If fromIndex >= str.length, the method will return -1 unless searchValue is an empty string in which case str.length is returned.","theRestString":"@optional dummy @returns {Number} the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found."},{"annotation":"optional","name":"dummy","text":"","theRestString":"@returns {Number} the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found."},{"annotation":"returns","type":"{Number}","name":"the","text":"index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.","theRestString":""}],"commentRange":[127145,130568],"fileName":"ALL.js"}}},"Backbone.BackboneEvents":{"annotation":"class","name":"BackboneEvents","text":"Events is a module that can be mixed in to any object, giving the object the ability to bind and trigger custom named events. Events do not have to be declared before they are bound, and may take passed arguments. For example:\n\n\tvar object = {};\n\n\t_.extend(object, Backbone.Events);\n\n\tobject.on(\"alert\", function(msg) {\n\t  alert(\"Triggered \" + msg);\n\t});\n\n\tobject.trigger(\"alert\", \"an event\");\n\t\nFor example, to make a handy event dispatcher that can coordinate events among different areas of your application: var dispatcher = _.clone(Backbone.Events)\n\n\n#Catalog of Events \nHere's the complete list of built-in Backbone events, with arguments. You're also free to trigger your own events on Models, Collections and Views as you see fit. The Backbone object itself mixes in Events, and can be used to emit any global events that your application needs.\n\n\t\"add\" (model, collection, options) â€” when a model is added to a collection.\n\t\"remove\" (model, collection, options) â€” when a model is removed from a collection.\n\t\"reset\" (collection, options) â€” when the collection's entire contents have been replaced.\n\t\"sort\" (collection, options) â€” when the collection has been re-sorted.\n\t\"change\" (model, options) â€” when a model's attributes have changed.\n\t\"change:[attribute]\" (model, value, options) â€” when a specific attribute has been updated.\n\t\"destroy\" (model, collection, options) â€” when a model is destroyed.\n\t\"request\" (model_or_collection, xhr, options) â€” when a model or collection has started a request to the server.\n\t\"sync\" (model_or_collection, resp, options) â€” when a model or collection has been successfully synced with the server.\n\t\"error\" (model_or_collection, resp, options) â€” when model's or collection's request to remote server has failed.\n\t\"invalid\" (model, error, options) â€” when a model's validation fails on the client.\n\t\"route:[name]\" (params) â€” Fired by the router when a specific route is matched.\n\t\"route\" (route, params) â€” Fired by the router when any route has been matched.\n\t\"route\" (router, route, params) â€” Fired by history when any route has been matched.\n\t\"all\" â€” this special event fires for any triggered event, passing the event name as the first argument.\nGenerally speaking, when calling a function that emits an event (model.set, collection.add, and so on...), if you'd like to prevent the event from being triggered, you may pass {silent: true} as an option. Note that this is rarely, perhaps even never, a good idea. Passing through a specific flag in the options for your event callback to look at, and choose to ignore, will usually work out better.","commentRange":[130591,133212],"fileName":"ALL.js","module":{"annotation":"module","name":"Backbone","text":"\n\n#About\nBackbone.js gives structure to web applications by providing models with key-value binding and custom events, collections with a rich API of enumerable functions, views with declarative event handling, and connects it all to your existing API over a RESTful JSON interface.\n\nThe project is hosted on GitHub, and the annotated source code is available, as well as an online test suite, an example application, a list of tutorials and a long list of real-world projects that use Backbone. Backbone is available for use under the MIT software license.\n\nYou can report bugs and discuss features on the GitHub issues page, on Freenode IRC in the #documentcloud channel, post questions to the Google Group, add pages to the wiki or send tweets to","commentRange":[130571,130589],"fileName":"ALL.js"},"absoluteName":"Backbone.BackboneEvents","methods":{"bind":{"annotation":"method","name":"bind","text":"Alias on\n\nBind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or \"change:selection\". The event string may also be a space-delimited list of several events...\n\n\tbook.on(\"change:title change:author\", ...);\n\nTo supply a context value for this when the callback is invoked, pass the optional third argument: model.on('change', this.render, this)\n\nCallbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of the event as the first argument. For example, to proxy all events from one object to another:\n\n\tproxy.on(\"all\", function(eventName) {\n\t  object.trigger(eventName);\n\t});\nAll Backbone event methods also support an event map syntax, as an alternative to positional arguments:\n\n\tbook.on({\n\t  \"change:title\": titleView.update,\n\t  \"change:author\": authorPane.update,\n\t  \"destroy\": bookView.remove\n\t});","children":[{"annotation":"param","type":"{String}","name":"event","text":"","theRestString":"@param {Function} callback\n@param {Object} context optional"},{"annotation":"param","type":"{Function}","name":"callback","text":"","theRestString":"@param {Object} context optional"},{"annotation":"param","type":"{Object}","name":"context","text":"optional","theRestString":""}],"commentRange":[133216,134336],"fileName":"ALL.js"},"off":{"annotation":"method","name":"off","text":"Remove a previously-bound callback function from an object. If no context is specified, all of the versions of the callback with different contexts will be removed. If no callback is specified, all callbacks for the event will be removed. If no event is specified, callbacks for all events will be removed.\n\n\t// Removes just the `onChange` callback.\n\tobject.off(\"change\", onChange);\n\n\t// Removes all \"change\" callbacks.\n\tobject.off(\"change\");\n\n\t// Removes the `onChange` callback for all events.\n\tobject.off(null, onChange);\n\n\t// Removes all callbacks for `context` for all events.\n\tobject.off(null, null, context);\n\n\t// Removes all callbacks on `object`.\n\tobject.off();\nNote that calling model.off(), for example, will indeed remove all events on the model â€” including events that Backbone uses for internal bookkeeping.","commentRange":[134340,135179],"fileName":"ALL.js"},"trigger":{"annotation":"method","name":"trigger","text":"Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be passed along to the event callbacks.","commentRange":[135183,135354],"fileName":"ALL.js"},"once":{"annotation":"method","name":"once","text":"Just like on, but causes the bound callback to only fire once before being removed. Handy for saying \"the next time that X happens, do this\".","children":[{"annotation":"param","type":"{String}","name":"event","text":"","theRestString":"@param {Function} callback"},{"annotation":"param","type":"{Function}","name":"callback","text":"","theRestString":""}],"commentRange":[135358,135565],"fileName":"ALL.js"},"listenTo":{"annotation":"method","name":"listenTo","text":"Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can be removed all at once later on. The callback will always be called with object as context.\n\n\tview.listenTo(model, 'change', view.render);","children":[{"annotation":"param","type":"{BackboneEvents}","name":"other","text":"","theRestString":"@param {String} event\n@param {Function} calback"},{"annotation":"param","type":"{String}","name":"event","text":"","theRestString":"@param {Function} calback"},{"annotation":"param","type":"{Function}","name":"calback","text":"","theRestString":""}],"commentRange":[135568,136033],"fileName":"ALL.js"},"stopListening":{"annotation":"method","name":"stopListening","text":"Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to on a specific object, or a specific event, or just a specific callback.\n\n\tview.stopListening();\n\n\tview.stopListening(model);","children":[{"annotation":"param","type":"{BackboneEvents}","name":"other","text":"optional","theRestString":"@param {String} event optional\n@param {Function} calback optional"},{"annotation":"param","type":"{String}","name":"event","text":"optional","theRestString":"@param {Function} calback optional"},{"annotation":"param","type":"{Function}","name":"calback","text":"optional","theRestString":""}],"commentRange":[136037,136525],"fileName":"ALL.js"},"listenToOnce":{"annotation":"method","name":"listenToOnce","text":"Just like listenTo, but causes the bound callback to only fire once before being removed.","commentRange":[136528,136643],"fileName":"ALL.js"}}},"Backbone.BackboneModel":{"annotation":"class","name":"BackboneModel","text":"Models are the heart of any JavaScript application, containing the interactive data as well as a large part of the logic surrounding it: conversions, validations, computed properties, and access control. You extend Backbone.Model with your domain-specific methods, and Model provides a basic set of functionality for managing changes.\n\nThe following is a contrived example, but it demonstrates defining a model with a custom method, setting an attribute, and firing an event keyed to changes in that specific attribute. After running this code once, sidebar will be available in your browser's console, so you can play around with it.\n\n\tvar Sidebar = Backbone.Model.extend({\n\t  promptColor: function() {\n\t    var cssColor = prompt(\"Please enter a CSS color:\");\n\t    this.set({color: cssColor});\n\t  }\n\t});\n\n\twindow.sidebar = new Sidebar;\n\n\tsidebar.on('change:color', function(model, color) {\n\t  $('#sidebar').css({background: color});\n\t});\n\n\tsidebar.set({color: 'white'});\n\n\tsidebar.promptColor();\n\n","children":[{"annotation":"extends","name":"BackboneEvents","text":"","theRestString":""}],"commentRange":[136645,137714],"fileName":"ALL.js","module":{"annotation":"module","name":"Backbone","text":"","commentRange":[136645,137714],"fileName":"ALL.js"},"absoluteName":"Backbone.BackboneModel","methods":{"extend":{"annotation":"method","name":"extend","text":"To create a Model class of your own, you extend Backbone.Model and provide instance properties, as well as optional classProperties to be attached directly to the constructor function.\n\nextend correctly sets up the prototype chain, so subclasses created with extend can be further extended and subclassed as far as you like.\n\n\tvar Note = Backbone.Model.extend({\n\n\t  initialize: function() { ... },\n\n\t  author: function() { ... },\n\n\t  coordinates: function() { ... },\n\n\t  allowedToEdit: function(account) {\n\t    return true;\n\t  }\n\n\t});\n\n\tvar PrivateNote = Note.extend({\n\n\t  allowedToEdit: function(account) {\n\t    return account.owns(this);\n\t  }\n\n\t});\n\n#super\n\nBrief aside on super: JavaScript does not provide a simple way to call super â€” the function of the same name defined higher on the prototype chain. If you override a core function like set, or save, and you want to invoke the parent object's implementation, you'll have to explicitly call it, along these lines:\n\n\tvar Note = Backbone.Model.extend({\n\t  set: function(attributes, options) {\n\t    Backbone.Model.prototype.set.apply(this, arguments);\n\t    ...\n\t  }\n\t});","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} properties\n@param {Object} classProperties"},{"annotation":"param","type":"{Object}","name":"properties","text":"","theRestString":"@param {Object} classProperties"},{"annotation":"param","type":"{Object}","name":"classProperties","text":"","theRestString":""}],"commentRange":[137719,138936],"fileName":"ALL.js"},"initialize":{"annotation":"method","name":"initialize","text":"Use like this:\n\n\tnew Model([attributes], [options]) \n\nWhen creating an instance of a model, you can pass in the initial values of the attributes, which will be set on the model. If you define an initialize function, it will be invoked when the model is created.\n\n\tnew Book({\n\t  title: \"One Thousand and One Nights\",\n\t  author: \"Scheherazade\"\n\t});\nIn rare cases, if you're looking to get fancy, you may want to override constructor, which allows you to replace the actual constructor function for your model.\n\n\tvar Library = Backbone.Model.extend({\n\t  constructor: function() {\n\t    this.books = new Books();\n\t    Backbone.Model.apply(this, arguments);\n\t  },\n\t  parse: function(data, options) {\n\t    this.books.reset(data.books);\n\t    return data.library;\n\t  }\n\t});\nIf you pass a {collection: ...} as the options, the model gains a collection property that will be used to indicate which collection the model belongs to, and is used to help compute the model's url. The model.collection property is normally created automatically when you first add a model to a collection. Note that the reverse is not true, as passing this option to the constructor will not automatically add the model to the collection. Useful, sometimes.\n\nIf {parse: true} is passed as an option, the attributes will first be converted by parse before being set on the model.","commentRange":[138940,140312],"fileName":"ALL.js"},"get":{"annotation":"method","name":"get","text":"Get the current value of an attribute from the model. For example: note.get(\"title\")","children":[{"annotation":"param","type":"{String}","name":"name","text":"the property name to get","theRestString":"@returns {Any} the value of the property"},{"annotation":"returns","type":"{Any}","name":"the","text":"value of the property","theRestString":""}],"commentRange":[140316,140504],"fileName":"ALL.js"},"set":{"annotation":"method","name":"set","text":"Set a hash of attributes (one or many) on the model. If any of the attributes change the model's state, a \"change\" event will be triggered on the model. Change events for specific attributes are also triggered, and you can bind to those as well, for example: change:title, and change:content. You may also pass individual keys and values.\n\n\tnote.set({title: \"March 20\", content: \"In his eyes she eclipses...\"});\n\n\tbook.set(\"title\", \"A Scandal in Bohemia\");","children":[{"annotation":"param","type":"{String}","name":"name","text":"","theRestString":"@param {Any} value\n@param {Object} options Optional"},{"annotation":"param","type":"{Any}","name":"value","text":"","theRestString":"@param {Object} options Optional"},{"annotation":"param","type":"{Object}","name":"options","text":"Optional","theRestString":""}],"commentRange":[140509,141058],"fileName":"ALL.js"},"escape":{"annotation":"method","name":"escape","text":"Similar to get, but returns the HTML-escaped version of a model's attribute. If you're interpolating data from the model into HTML, using escape to retrieve attributes will prevent XSS attacks.\n\n\tvar hacker = new Backbone.Model({\n\t  name: \"<script>alert('xss')</script>\"\n\t});\n\n\talert(hacker.escape('name'));","commentRange":[141063,141392],"fileName":"ALL.js"},"has":{"annotation":"method","name":"has","text":"Returns true if the attribute is set to a non-null or non-undefined value.\n\n\tif (note.has(\"title\")) {\n\t  ...\n\t}","children":[{"annotation":"param","type":"{String}","name":"name","text":"","theRestString":""}],"commentRange":[141395,141546],"fileName":"ALL.js"},"unset":{"annotation":"method","name":"unset","text":"Remove an attribute by deleting it from the internal attributes hash. Fires a \"change\" event unless silent is passed as an option.","children":[{"annotation":"param","type":"{String}","name":"attribute","text":"","theRestString":"@param {Object} options Optional"},{"annotation":"param","type":"{Object}","name":"options","text":"Optional","theRestString":""}],"commentRange":[141549,141757],"fileName":"ALL.js"},"clear":{"annotation":"method","name":"clear","text":"Removes all attributes from the model, including the id attribute. Fires a \"change\" event unless silent is passed as an option.","children":[{"annotation":"param","type":"{Object}","name":"options","text":"Optional","theRestString":""}],"commentRange":[141762,141944],"fileName":"ALL.js"},"toJSON":{"annotation":"method","name":"toJSON","text":"Return a shallow copy of the model's attributes for JSON stringification. This can be used for persistence, serialization, or for augmentation before being sent to the server. The name of this method is a bit confusing, as it doesn't actually return a JSON string â€” but I'm afraid that it's the way that the JavaScript API for JSON.stringify works.\n\n\tvar artist = new Backbone.Model({\n\t  firstName: \"Wassily\",\n\t  lastName: \"Kandinsky\"\n\t});\n\n\tartist.set({birthday: \"December 16, 1866\"});\n\n\talert(JSON.stringify(artist));","children":[{"annotation":"param","type":"{Object}","name":"options","text":"Optional","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[144581,145173],"fileName":"ALL.js"},"sync":{"annotation":"method","name":"sync","text":"Uses Backbone.sync to persist the state of a model to the server. Can be overridden for custom behavior.","children":[{"annotation":"param","type":"{String}","name":"method","text":"","theRestString":"@param {BackboneModel} model\n@param {Object} options Optional\n@static dummy"},{"annotation":"param","type":"{BackboneModel}","name":"model","text":"","theRestString":"@param {Object} options Optional\n@static dummy"},{"annotation":"param","type":"{Object}","name":"options","text":"Optional","theRestString":"@static dummy"},{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[145178,145394],"fileName":"ALL.js"},"fetch":{"annotation":"method","name":"fetch","text":"Resets the model's state from the server by delegating to Backbone.sync. Returns a jqXHR. Useful if the model has never been populated with data, or if you'd like to ensure that you have the latest server state. A \"change\" event will be triggered if the server's state differs from the current attributes. Accepts success and error callbacks in the options hash, which are both passed (model, response, options) as arguments.\n\n\t// Poll every 10 seconds to keep the channel model up-to-date.\n\tsetInterval(function() {\n\t  channel.fetch();\n\t}, 10000);","children":[{"annotation":"param","type":"{Object}","name":"options","text":"Optional","theRestString":""}],"commentRange":[145399,146002],"fileName":"ALL.js"},"dummy":{"annotation":"method","name":"dummy","text":"","commentRange":[146007,146020],"fileName":"ALL.js"}},"properties":{"id":{"annotation":"property","type":"{String}","name":"id","text":"A special property of models, the id is an arbitrary string (integer id or UUID). If you set the id in the attributes hash, it will be copied onto the model as a direct property. Models can be retrieved by id from collections, and the id is used to generate model URLs by default.","commentRange":[141947,142257],"fileName":"ALL.js"},"idAttribute":{"annotation":"property","type":"{String}","name":"idAttribute","text":"A model's unique identifier is stored under the id attribute. If you're directly communicating with a backend (CouchDB, MongoDB) that uses a different unique key, you may set a Model's idAttribute to transparently map from that key to id.\n\n\tvar Meal = Backbone.Model.extend({\n\t  idAttribute: \"_id\"\n\t});\n\n\tvar cake = new Meal({ _id: 1, name: \"Cake\" });\n\talert(\"Cake id: \" + cake.id);","commentRange":[142261,142680],"fileName":"ALL.js"},"cid":{"annotation":"property","type":"{String}","name":"cid","text":"A special property of models, the cid or client id is a unique identifier automatically assigned to all models when they're first created. Client ids are handy when the model has not yet been saved to the server, and does not yet have its eventual true id, but already needs to be visible in the UI.","commentRange":[142684,143014],"fileName":"ALL.js"},"attributes":{"annotation":"property","type":"{Object}","name":"attributes","text":"The attributes property is the internal hash containing the model's state â€” usually (but not necessarily) a form of the JSON object representing the model data on the server. It's often a straightforward serialization of a row from the database, but it could also be client-side computed state.\n\nPlease use set to update the attributes instead of modifying them directly. If you'd like to retrieve and munge a copy of the model's attributes, use _.clone(model.attributes) instead.\n\nDue to the fact that Events accepts space separated lists of events, attribute names should not include spaces.","commentRange":[143018,143645],"fileName":"ALL.js"},"changed":{"annotation":"property","type":"{Object}","name":"changed","text":"The changed property is the internal hash containing all the attributes that have changed since the last set. Please do not update changed directly since its state is internally maintained by set. A copy of changed can be acquired from changedAttributes.","commentRange":[143651,143936],"fileName":"ALL.js"},"defaults":{"annotation":"property","type":"{Object}","name":"defaults","text":"The defaults hash (or function) can be used to specify the default attributes for your model. When creating an instance of the model, any unspecified attributes will be set to their default value.\n\n\tvar Meal = Backbone.Model.extend({\n\t  defaults: {\n\t    \"appetizer\":  \"caesar salad\",\n\t    \"entree\":     \"ravioli\",\n\t    \"dessert\":    \"cheesecake\"\n\t  }\n\t});\n\n\talert(\"Dessert will be \" + (new Meal).get('dessert'));\nRemember that in JavaScript, objects are passed by reference, so if you include an object as a default value, it will be shared among all instances. Instead, define defaults as a function.","commentRange":[143940,144573],"fileName":"ALL.js"}}},"Backbone.BackboneView":{"annotation":"class","name":"BackboneView","text":"","commentRange":[149007,149170],"fileName":"ALL.js","module":{"annotation":"module","name":"Backbone","text":"#About\nBackbone.js gives structure to web applications by providing models with key-value binding and custom events, collections with a rich API of enumerable functions, views with declarative event handling, and connects it all to your existing API over a RESTful JSON interface.\n\nThe project is hosted on GitHub, and the annotated source code is available, as well as an online test suite, an example application, a list of tutorials and a long list of real-world projects that use Backbone. Backbone is available for use under the MIT software license.\n\nYou can report bugs and discuss features on the GitHub issues page, on Freenode IRC in the #documentcloud channel, post questions to the Google Group, add pages to the wiki or send tweets to","children":[{"annotation":"documentcloud","name":".","text":"Backbone is an open-source component of DocumentCloud.\n\n#Dependencies\nBackbone's only hard dependency is Underscore.js ( >= 1.5.0). For RESTful persistence, history support via Backbone.Router and DOM manipulation with Backbone.View, include jQuery, and json2.js for older Internet Explorer support. (Mimics of the Underscore and jQuery APIs, such as Lo-Dash and Zepto, will also tend to work, with varying degrees of compatibility.)\n\n#Introduction\n\nWhen working on a web application that involves a lot of JavaScript, one of the first things you learn is to stop tying your data to the DOM. It's all too easy to create JavaScript applications that end up as tangled piles of jQuery selectors and callbacks, all trying frantically to keep data in sync between the HTML UI, your JavaScript logic, and the database on your server. For rich client-side applications, a more structured approach is often helpful.\n\nWith Backbone, you represent your data as Models, which can be created, validated, destroyed, and saved to the server. Whenever a UI action causes an attribute of a model to change, the model triggers a \"change\" event; all the Views that display the model's state can be notified of the change, so that they are able to respond accordingly, re-rendering themselves with the new information. In a finished Backbone app, you don't have to write the glue code that looks into the DOM to find an element with a specific id, and update the HTML manually â€” when the model changes, the views simply update themselves.\n\nPhilosophically, Backbone is an attempt to discover the minimal set of data-structuring (models and collections) and user interface (views and URLs) primitives that are generally useful when building web applications with JavaScript. In an ecosystem where overarching, decides-everything-for-you frameworks are commonplace, and many libraries require your site to be reorganized to suit their look, feel, and default behavior â€” Backbone should continue to be a tool that gives you the freedom to design the full experience of your web application.\n\nIf you're new here, and aren't yet quite sure what Backbone is for, start by browsing the list of Backbone-based projects.","theRestString":""}],"commentRange":[146022,149005],"fileName":"ALL.js"},"absoluteName":"Backbone.BackboneView","properties":{"$el":{"annotation":"property","type":"{jQuery}","name":"$el","text":"","commentRange":[149007,149170],"fileName":"ALL.js"},"$":{"annotation":"property","type":"{jQuery}","name":"$","text":"","commentRange":[149007,149170],"fileName":"ALL.js"},"el":{"annotation":"property","type":"{HTMLElement}","name":"el","text":"","commentRange":[149007,149170],"fileName":"ALL.js"}},"methods":{"render":{"annotation":"method","name":"render","text":"","commentRange":[149007,149170],"fileName":"ALL.js"}}},"Backbone.BackboneRouter":{"annotation":"class","name":"BackboneRouter","text":"","commentRange":[149007,149170],"fileName":"ALL.js","module":{"annotation":"module","name":"Backbone","text":"#About\nBackbone.js gives structure to web applications by providing models with key-value binding and custom events, collections with a rich API of enumerable functions, views with declarative event handling, and connects it all to your existing API over a RESTful JSON interface.\n\nThe project is hosted on GitHub, and the annotated source code is available, as well as an online test suite, an example application, a list of tutorials and a long list of real-world projects that use Backbone. Backbone is available for use under the MIT software license.\n\nYou can report bugs and discuss features on the GitHub issues page, on Freenode IRC in the #documentcloud channel, post questions to the Google Group, add pages to the wiki or send tweets to","children":[{"annotation":"documentcloud","name":".","text":"Backbone is an open-source component of DocumentCloud.\n\n#Dependencies\nBackbone's only hard dependency is Underscore.js ( >= 1.5.0). For RESTful persistence, history support via Backbone.Router and DOM manipulation with Backbone.View, include jQuery, and json2.js for older Internet Explorer support. (Mimics of the Underscore and jQuery APIs, such as Lo-Dash and Zepto, will also tend to work, with varying degrees of compatibility.)\n\n#Introduction\n\nWhen working on a web application that involves a lot of JavaScript, one of the first things you learn is to stop tying your data to the DOM. It's all too easy to create JavaScript applications that end up as tangled piles of jQuery selectors and callbacks, all trying frantically to keep data in sync between the HTML UI, your JavaScript logic, and the database on your server. For rich client-side applications, a more structured approach is often helpful.\n\nWith Backbone, you represent your data as Models, which can be created, validated, destroyed, and saved to the server. Whenever a UI action causes an attribute of a model to change, the model triggers a \"change\" event; all the Views that display the model's state can be notified of the change, so that they are able to respond accordingly, re-rendering themselves with the new information. In a finished Backbone app, you don't have to write the glue code that looks into the DOM to find an element with a specific id, and update the HTML manually â€” when the model changes, the views simply update themselves.\n\nPhilosophically, Backbone is an attempt to discover the minimal set of data-structuring (models and collections) and user interface (views and URLs) primitives that are generally useful when building web applications with JavaScript. In an ecosystem where overarching, decides-everything-for-you frameworks are commonplace, and many libraries require your site to be reorganized to suit their look, feel, and default behavior â€” Backbone should continue to be a tool that gives you the freedom to design the full experience of your web application.\n\nIf you're new here, and aren't yet quite sure what Backbone is for, start by browsing the list of Backbone-based projects.","theRestString":""}],"commentRange":[146022,149005],"fileName":"ALL.js"},"absoluteName":"Backbone.BackboneRouter"},"html.HTMLElement":{"annotation":"class","name":"HTMLElement","text":"","children":[{"annotation":"extends","name":"XMLNode","text":"#Events \n\nTaken from http://www.w3schools.com/tags/ref_eventattributes.asp\n\nHTML 4 added the ability to let events trigger actions in a browser, like starting a JavaScript when a user clicks on an element.","theRestString":""}],"commentRange":[149172,157256],"fileName":"ALL.js","module":{"annotation":"module","name":"html","text":"","commentRange":[149172,157256],"fileName":"ALL.js"},"absoluteName":"html.HTMLElement","events":{"onafterprint":{"annotation":"event","name":"onafterprint","text":"Script to be run after the document is printed","commentRange":[149172,157256],"fileName":"ALL.js"},"onbeforeprint":{"annotation":"event","name":"onbeforeprint","text":"Script to be run before the document is printed. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onbeforeunload":{"annotation":"event","name":"onbeforeunload","text":"Script to be run when the document is about to be unloaded. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onerror":{"annotation":"event","name":"onerror","text":"Script to be run when an error occur. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onhashchange":{"annotation":"event","name":"onhashchange","text":"Script to be run when there has been changes to the anchor part of the a URL. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onload":{"annotation":"event","name":"onload","text":"Fires after the page is finished loading. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onmessage":{"annotation":"event","name":"onmessage","text":"Script to be run when the message is triggered. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onoffline":{"annotation":"event","name":"onoffline","text":"Script to be run when the browser starts to work offline. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"ononline":{"annotation":"event","name":"ononline","text":"Script to be run when the browser starts to work online. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onpagehide":{"annotation":"event","name":"onpagehide","text":"Script to be run when a user navigates away from a page. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onpageshow":{"annotation":"event","name":"onpageshow","text":"Script to be run when a user navigates to a page. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onpopstate":{"annotation":"event","name":"onpopstate","text":"Script to be run when the window's history changes. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onresize":{"annotation":"event","name":"onresize","text":"Fires when the browser window is resized. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onstorage":{"annotation":"event","name":"onstorage","text":"Script to be run when a Web Storage area is updated. Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onunload":{"annotation":"event","name":"onunload","text":"Fires once a page has unloaded (or the browser window has been closed). Note: this is a Window Event Attribute, triggered for the window object (applies to the <body> tag). Compatible with HTML5","commentRange":[149172,157256],"fileName":"ALL.js"},"onblur":{"annotation":"event","name":"onblur","text":"Fires the moment that the element loses focus. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"onchange":{"annotation":"event","name":"onchange","text":"Fires the moment when the value of the element is changed. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"oncontextmenu":{"annotation":"event","name":"oncontextmenu","text":"Script to be run when a context menu is triggered. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"onfocus":{"annotation":"event","name":"onfocus","text":"Fires the moment when the element gets focus. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"oninput":{"annotation":"event","name":"oninput","text":"Script to be run when an element gets user input. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"oninvalid":{"annotation":"event","name":"oninvalid","text":"Script to be run when an element is invalid. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"onreset":{"annotation":"event","name":"onreset","text":"Fires when the Reset button in a form is clicked. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"onsearch":{"annotation":"event","name":"onsearch","text":"Fires when the user writes something in a search field (for <input=\"search\">). Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"onselect":{"annotation":"event","name":"onselect","text":"Fires after some text has been selected in an element. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"onsubmit":{"annotation":"event","name":"onsubmit","text":"script\tFires when a form is submitted. Note: this is a Form Event, triggered by actions inside a HTML form (applies to almost all HTML elements, but is most used in form elements)","commentRange":[149172,157256],"fileName":"ALL.js"},"onkeydown":{"annotation":"event","name":"onkeydown","text":"Fires when a user is pressing a key. This is a Keyboard Event","commentRange":[149172,157256],"fileName":"ALL.js"},"onkeypress":{"annotation":"event","name":"onkeypress","text":"Fires when a user presses a key. This is a Keyboard Event","commentRange":[149172,157256],"fileName":"ALL.js"},"onkeyup":{"annotation":"event","name":"onkeyup","text":"Fires when a user releases a key. This is a Keyboard Event","commentRange":[149172,157256],"fileName":"ALL.js"},"onclick":{"annotation":"event","name":"onclick","text":"script\tFires on a mouse click on the element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"ondblclick":{"annotation":"event","name":"ondblclick","text":"script\tFires on a mouse double-click on the element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"ondrag":{"annotation":"event","name":"ondrag","text":"script\tScript to be run when an element is dragged. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"ondragend":{"annotation":"event","name":"ondragend","text":"script\tScript to be run at the end of a drag operation. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"ondragenter":{"annotation":"event","name":"ondragenter","text":"script\tScript to be run when an element has been dragged to a valid drop target. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"ondragleave":{"annotation":"event","name":"ondragleave","text":"script\tScript to be run when an element leaves a valid drop target. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"ondragover":{"annotation":"event","name":"ondragover","text":"script\tScript to be run when an element is being dragged over a valid drop target. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"ondragstart":{"annotation":"event","name":"ondragstart","text":"script\tScript to be run at the start of a drag operation. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"ondrop":{"annotation":"event","name":"ondrop","text":"script\tScript to be run when dragged element is being dropped. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"onmousedown":{"annotation":"event","name":"onmousedown","text":"script\tFires when a mouse button is pressed down on an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"onmousemove":{"annotation":"event","name":"onmousemove","text":"script\tFires when the mouse pointer is moving while it is over an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"onmouseout":{"annotation":"event","name":"onmouseout","text":"script\tFires when the mouse pointer moves out of an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"onmouseover":{"annotation":"event","name":"onmouseover","text":"script\tFires when the mouse pointer moves over an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"onmouseup":{"annotation":"event","name":"onmouseup","text":"script\tFires when a mouse button is released over an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"onmousewheel":{"annotation":"event","name":"onmousewheel","text":"script\tDeprecated. Use the onwheel attribute instead. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"onscroll":{"annotation":"event","name":"onscroll","text":"script\tScript to be run when an element's scrollbar is being scrolled. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"},"onwheel":{"annotation":"event","name":"onwheel","text":"script\tFires when the mouse wheel rolls up or down over an element. Note: This is a Mouse Event, triggered by a mouse, or similar user actions","commentRange":[149172,157256],"fileName":"ALL.js"}}},"jquery.jQueryDeferred":{"annotation":"class","name":"jQueryDeferred","text":"The Deferred object, introduced in jQuery 1.5, is a chainable utility object created by calling the jQuery.Deferred() method. It can register multiple callbacks into callback queues, invoke callback queues, and relay the success or failure state of any synchronous or asynchronous function.\n\nThe Deferred object is chainable, similar to the way a jQuery object is chainable, but it has its own methods. After creating a Deferred object, you can use any of the methods below by either chaining directly from the object creation or saving the object in a variable and invoking one or more methods on that variable.","commentRange":[157258,157916],"fileName":"ALL.js","module":{"annotation":"module","name":"jquery","text":"","commentRange":[157258,157916],"fileName":"ALL.js"},"absoluteName":"jquery.jQueryDeferred","constructors":[{"annotation":"constructor","name":"n","text":"jQuery.Deferred\n\n##Description\n\nA constructor function that returns a chainable utility object with methods to register multiple callbacks into callback queues, invoke callback queues, and relay the success or failure state of any synchronous or asynchronous function.\n\nThe jQuery.Deferred method can be passed an optional function, which is called just before the constructor returns and is passed the constructed deferred object as both the this object and as the first argument to the function. The called function can attach callbacks using deferred.then(), for example.\n\nA Deferred object starts in the pending state. Any callbacks added to the object with deferred.then(), deferred.always(), deferred.done(), or deferred.fail() are queued to be executed later. Calling deferred.resolve() or deferred.resolveWith() transitions the Deferred into the resolved state and immediately executes any doneCallbacks that are set. Calling deferred.reject() or deferred.rejectWith() transitions the Deferred into the rejected state and immediately executes any failCallbacks that are set. Once the object has entered the resolved or rejected state, it stays in that state. Callbacks can still be added to the resolved or rejected Deferred â€” they will execute immediately.\n\n##Enhanced Callbacks with jQuery Deferred\n\nIn JavaScript it is common to invoke functions that optionally accept callbacks that are called within that function. For example, in versions prior to jQuery 1.5, asynchronous processes such as jQuery.ajax() accept callbacks to be invoked some time in the near-future upon success, error, and completion of the ajax request.\n\njQuery.Deferred() introduces several enhancements to the way callbacks are managed and invoked. In particular, jQuery.Deferred() provides flexible ways to provide multiple callbacks, and these callbacks can be invoked regardless of whether the original callback dispatch has already occurred. jQuery Deferred is based on the CommonJS Promises/A design.\n\nOne model for understanding Deferred is to think of it as a chain-aware function wrapper. The deferred.then(), deferred.always(), deferred.done(), and deferred.fail() methods specify the functions to be called and the deferred.resolve(args) or deferred.reject(args) methods \"call\" the functions with the arguments you supply. Once the Deferred has been resolved or rejected it stays in that state; a second call to deferred.resolve(), for example, is ignored. If more functions are added by deferred.then(), for example, after the Deferred is resolved, they are called immediately with the arguments previously provided.\n\nIn most cases where a jQuery API call returns a Deferred or Promise-compatible object, such as jQuery.ajax() or jQuery.when(), you will only want to use the deferred.then(), deferred.done(), and deferred.fail() methods to add callbacks to the Deferred's queues. The internals of the API call or code that created the Deferred will invoke deferred.resolve() or deferred.reject() on the deferred at some point, causing the appropriate callbacks to run.","children":[{"annotation":"param","type":"{Function}","name":"beforeStart","text":"Optional\nType: Function( Deferred deferred )\nA function that is called just before the constructor returns.\nThe jQuery.Deferred() constructor creates a new Deferred object. The new operator is optional.","theRestString":""}],"commentRange":[157918,161235],"fileName":"ALL.js","params":[{"annotation":"param","type":"{Function}","name":"beforeStart","text":"Optional\nType: Function( Deferred deferred )\nA function that is called just before the constructor returns.\nThe jQuery.Deferred() constructor creates a new Deferred object. The new operator is optional.","theRestString":""}],"throws":[]}],"methods":{"always":{"annotation":"method","name":"always","text":"Usage:\n\tdeferred.always( alwaysCallbacks [, alwaysCallbacks ] )\n\nDescription: Add handlers to be called when the Deferred object is either resolved or rejected.\n\nThe argument can be either a single function or an array of functions. When the Deferred is resolved or rejected, the alwaysCallbacks are called. Since deferred.always() returns the Deferred object, other methods of the Deferred object can be chained to this one, including additional .always() methods. When the Deferred is resolved or rejected, callbacks are executed in the order they were added, using the arguments provided to the resolve, reject, resolveWith or rejectWith method calls. For more information, see the documentation for Deferred object.\n\nExample:\nSince the jQuery.get() method returns a jqXHR object, which is derived from a Deferred object, we can attach a callback for both success and error using the deferred.always() method.\n\n\t$.get( \"test.php\" ).always(function() {\n\t  alert( \"$.get completed with success or error callback arguments\" );\n\t})","children":[{"annotation":"param","type":"{Function|Array<Function>}","name":"alwaysCallbacks","text":"A function, or array of functions, that is called when the Deferred is resolved or rejected.","theRestString":""}],"commentRange":[161241,162438],"fileName":"ALL.js"}}},"jquery.jQuery":{"annotation":"class","name":"jQuery","text":"","commentRange":[162440,162474],"fileName":"ALL.js","module":{"annotation":"module","name":"jquery","text":"","commentRange":[162440,162474],"fileName":"ALL.js"},"absoluteName":"jquery.jQuery"},"xml.dom.XMLDocument":{"annotation":"class","name":"XMLDocument","text":"XML DOM - The Document Object\n\nThe Document object represents the entire XML document.\n\nThe Document object is the root of a document tree, and gives us the primary access to the document's data.\n\nSince element nodes, text nodes, comments, processing instructions, etc. cannot exist outside the document, the Document object also contains methods to create these objects. The Node objects have a ownerDocument property which associates them with the Document where they were created.","commentRange":[162478,165933],"fileName":"ALL.js","module":{"annotation":"module","name":"xml.dom","text":"","commentRange":[162478,165933],"fileName":"ALL.js"},"absoluteName":"xml.dom.XMLDocument","properties":{"async":{"annotation":"property","name":"async","text":"Specifies whether downloading of an XML file should be handled asynchronously or not","commentRange":[162478,165933],"fileName":"ALL.js"},"childNodes":{"annotation":"property","name":"childNodes","text":"Returns a NodeList of child nodes for the document","commentRange":[162478,165933],"fileName":"ALL.js"},"doctype":{"annotation":"property","name":"doctype","text":"Returns the Document Type Declaration associated with the document","commentRange":[162478,165933],"fileName":"ALL.js"},"documentElement":{"annotation":"property","name":"documentElement","text":"Returns the root node of the document","commentRange":[162478,165933],"fileName":"ALL.js"},"documentURI":{"annotation":"property","name":"documentURI","text":"Sets or returns the location of the document","commentRange":[162478,165933],"fileName":"ALL.js"},"domConfig":{"annotation":"property","name":"domConfig","text":"Returns the configuration used when normalizeDocument() is invoked","commentRange":[162478,165933],"fileName":"ALL.js"},"firstChild":{"annotation":"property","name":"firstChild","text":"Returns the first child node of the document","commentRange":[162478,165933],"fileName":"ALL.js"},"implementation":{"annotation":"property","name":"implementation","text":"Returns the DOMImplementation object that handles this document","commentRange":[162478,165933],"fileName":"ALL.js"},"inputEncoding":{"annotation":"property","name":"inputEncoding","text":"Returns the encoding used for the document (when parsing)","commentRange":[162478,165933],"fileName":"ALL.js"},"lastChild":{"annotation":"property","name":"lastChild","text":"Returns the last child node of the document","commentRange":[162478,165933],"fileName":"ALL.js"},"nodeName":{"annotation":"property","name":"nodeName","text":"Returns the name of a node (depending on its type)","commentRange":[162478,165933],"fileName":"ALL.js"},"nodeType":{"annotation":"property","name":"nodeType","text":"Returns the node type of a node","commentRange":[162478,165933],"fileName":"ALL.js"},"nodeValue":{"annotation":"property","name":"nodeValue","text":"Sets or returns the value of a node (depending on its type)","commentRange":[162478,165933],"fileName":"ALL.js"},"strictErrorChecking":{"annotation":"property","name":"strictErrorChecking","text":"Sets or returns whether error-checking is enforced or not","commentRange":[162478,165933],"fileName":"ALL.js"},"xmlEncoding":{"annotation":"property","name":"xmlEncoding","text":"Returns the XML encoding of the document","commentRange":[162478,165933],"fileName":"ALL.js"},"xmlStandalone":{"annotation":"property","name":"xmlStandalone","text":"Sets or returns whether the document is standalone","commentRange":[162478,165933],"fileName":"ALL.js"},"xmlVersion":{"annotation":"property","name":"xmlVersion","text":"Sets or returns the XML version of the document","commentRange":[162478,165933],"fileName":"ALL.js"}},"methods":{"adoptNode":{"annotation":"method","name":"adoptNode","text":"(sourcenode)\tAdopts a node from another document to this document, and returns the adopted node","commentRange":[162478,165933],"fileName":"ALL.js"},"createAttribute":{"annotation":"method","name":"createAttribute","text":"(name)\tCreates an attribute node with the specified name, and returns the new Attr object","commentRange":[162478,165933],"fileName":"ALL.js"},"createAttributeNS":{"annotation":"method","name":"createAttributeNS","text":"(uri,name)\tCreates an attribute node with the specified name and namespace, and returns the new Attr object","commentRange":[162478,165933],"fileName":"ALL.js"},"createCDATASection":{"annotation":"method","name":"createCDATASection","text":"()\tCreates a CDATA section node","commentRange":[162478,165933],"fileName":"ALL.js"},"createComment":{"annotation":"method","name":"createComment","text":"()\tCreates a comment node","commentRange":[162478,165933],"fileName":"ALL.js"},"createDocumentFragment":{"annotation":"method","name":"createDocumentFragment","text":"()\tCreates an empty DocumentFragment object, and returns it","commentRange":[162478,165933],"fileName":"ALL.js"},"createElement":{"annotation":"method","name":"createElement","text":"()\tCreates an element node","commentRange":[162478,165933],"fileName":"ALL.js"},"createElementNS":{"annotation":"method","name":"createElementNS","text":"()\tCreates an element node with a specified namespace","commentRange":[162478,165933],"fileName":"ALL.js"},"createEntityReference":{"annotation":"method","name":"createEntityReference","text":"(name)\tCreates an EntityReference object, and returns it","commentRange":[162478,165933],"fileName":"ALL.js"},"createProcessingInstruction":{"annotation":"method","name":"createProcessingInstruction","text":"(target,data)\tCreates a ProcessingInstruction object, and returns it","commentRange":[162478,165933],"fileName":"ALL.js"},"createTextNode":{"annotation":"method","name":"createTextNode","text":"()\tCreates a text node","commentRange":[162478,165933],"fileName":"ALL.js"},"getElementById":{"annotation":"method","name":"getElementById","text":"(id)\tReturns the element that has an ID attribute with the given value. If no such element exists, it returns null","commentRange":[162478,165933],"fileName":"ALL.js"},"getElementsByTagName":{"annotation":"method","name":"getElementsByTagName","text":"()\tReturns a NodeList of all elements with a specified name","commentRange":[162478,165933],"fileName":"ALL.js"},"getElementsByTagNameNS":{"annotation":"method","name":"getElementsByTagNameNS","text":"()\tReturns a NodeList of all elements with a specified name and namespace","commentRange":[162478,165933],"fileName":"ALL.js"},"importNode":{"annotation":"method","name":"importNode","text":"(nodetoimport,deep)\tImports a node from another document to this document. This method creates a new copy of the source node. If the deep parameter is set to true, it imports all children of the specified node. If set to false, it imports only the node itself. This method returns the imported node","commentRange":[162478,165933],"fileName":"ALL.js"},"normalizeDocument":{"annotation":"method","name":"normalizeDocument","text":"()","commentRange":[162478,165933],"fileName":"ALL.js"},"renameNode":{"annotation":"method","name":"renameNode","text":"()\tRenames an element or attribute node","commentRange":[162478,165933],"fileName":"ALL.js"}}},"xml.dom.XMLDocumentType":{"annotation":"class","name":"XMLDocumentType","text":"The DocumentType object. \nEach document has a DOCTYPE attribute that whose value is either null or a DocumentType object.\n\nThe DocumentType object provides an interface to the entities defined for an XML document.","commentRange":[165939,166531],"fileName":"ALL.js","module":{"annotation":"module","name":"xml.dom","text":"","commentRange":[162478,165933],"fileName":"ALL.js"},"absoluteName":"xml.dom.XMLDocumentType","properties":{"entities":{"annotation":"property","name":"entities","text":"Returns a NamedNodeMap containing the entities declared in the DTD","commentRange":[165939,166531],"fileName":"ALL.js"},"internalSubset":{"annotation":"property","name":"internalSubset","text":"Returns the internal DTD as a string","commentRange":[165939,166531],"fileName":"ALL.js"},"name":{"annotation":"property","name":"name","text":"Returns the name of the DTD","commentRange":[165939,166531],"fileName":"ALL.js"},"notations":{"annotation":"property","name":"notations","text":"Returns a NamedNodeMap containing the notations declared in\tthe DTD","commentRange":[165939,166531],"fileName":"ALL.js"},"systemId":{"annotation":"property","name":"systemId","text":"Returns the system identifier of the external DTD","commentRange":[165939,166531],"fileName":"ALL.js"}}},"xml.dom.XMLElement":{"annotation":"class","name":"XMLElement","text":"XML DOM - The Element Object\n\nThe Element object represents an element in an XML document. Elements may contain attributes, other elements, or text. If an element contains text, the text is represented in a text-node.\n\nIMPORTANT! Text is always stored in text nodes. A common error in DOM processing is to navigate to an element node and expect it to contain the text. However, even the simplest element node has a text node under it. For example, in <year>2005</year>, there is an element node (year), and a text node under it, which contains the text (2005).\n\nBecause the Element object is also a Node, it inherits the Node object's properties and methods.","children":[{"annotation":"extends","name":"XMLNode","text":"","theRestString":""}],"commentRange":[166533,171779],"fileName":"ALL.js","module":{"annotation":"module","name":"xml.dom","text":"","commentRange":[162478,165933],"fileName":"ALL.js"},"absoluteName":"xml.dom.XMLElement","properties":{"attributes":{"annotation":"property","name":"attributes","text":"Returns a NamedNodeMap of attributes for the element","commentRange":[166533,171779],"fileName":"ALL.js"},"baseURI":{"annotation":"property","name":"baseURI","text":"Returns the absolute base URI of the element","commentRange":[166533,171779],"fileName":"ALL.js"},"childNodes":{"annotation":"property","name":"childNodes","text":"Returns a NodeList of child nodes for the element","commentRange":[166533,171779],"fileName":"ALL.js"},"firstChild":{"annotation":"property","name":"firstChild","text":"Returns the first child of the element","commentRange":[166533,171779],"fileName":"ALL.js"},"lastChild":{"annotation":"property","name":"lastChild","text":"Returns the last child of the element","commentRange":[166533,171779],"fileName":"ALL.js"},"localName":{"annotation":"property","name":"localName","text":"Returns the local part of the name of the element","commentRange":[166533,171779],"fileName":"ALL.js"},"namespaceURI":{"annotation":"property","name":"namespaceURI","text":"Returns the namespace URI of the element","commentRange":[166533,171779],"fileName":"ALL.js"},"nextSibling":{"annotation":"property","name":"nextSibling","text":"Returns the node immediately following the element","commentRange":[166533,171779],"fileName":"ALL.js"},"nodeName":{"annotation":"property","name":"nodeName","text":"Returns the name of the node, depending on its type","commentRange":[166533,171779],"fileName":"ALL.js"},"nodeType":{"annotation":"property","name":"nodeType","text":"Returns the type of the node","commentRange":[166533,171779],"fileName":"ALL.js"},"ownerDocument":{"annotation":"property","name":"ownerDocument","text":"Returns the root element (document object) for an element","commentRange":[166533,171779],"fileName":"ALL.js"},"parentNode":{"annotation":"property","name":"parentNode","text":"Returns the parent node of the element","commentRange":[166533,171779],"fileName":"ALL.js"},"prefix":{"annotation":"property","name":"prefix","text":"Sets or returns the namespace prefix of the element","commentRange":[166533,171779],"fileName":"ALL.js"},"previousSibling":{"annotation":"property","name":"previousSibling","text":"Returns the node immediately before the element","commentRange":[166533,171779],"fileName":"ALL.js"},"schemaTypeInfo":{"annotation":"property","name":"schemaTypeInfo","text":"Returns the type information associated with the element","commentRange":[166533,171779],"fileName":"ALL.js"},"tagName":{"annotation":"property","name":"tagName","text":"Returns the name of the element","commentRange":[166533,171779],"fileName":"ALL.js"},"textContent":{"annotation":"property","name":"textContent","text":"Sets or returns the text content of the element and its descendants","commentRange":[166533,171779],"fileName":"ALL.js"}},"methods":{"appendChild":{"annotation":"method","name":"appendChild","text":"()\tAdds a new child node to the end of the list of children of the node","commentRange":[166533,171779],"fileName":"ALL.js"},"cloneNode":{"annotation":"method","name":"cloneNode","text":"()\tClones a  node","commentRange":[166533,171779],"fileName":"ALL.js"},"compareDocumentPosition":{"annotation":"method","name":"compareDocumentPosition","text":"()\tCompares the document position of two nodes","commentRange":[166533,171779],"fileName":"ALL.js"},"getAttribute":{"annotation":"method","name":"getAttribute","text":"()\tReturns the value of an attribute","commentRange":[166533,171779],"fileName":"ALL.js"},"getAttributeNS":{"annotation":"method","name":"getAttributeNS","text":"()\tReturns the value of an attribute (with a namespace)","commentRange":[166533,171779],"fileName":"ALL.js"},"getAttributeNode":{"annotation":"method","name":"getAttributeNode","text":"()\tReturns an attribute node as an Attribute object","commentRange":[166533,171779],"fileName":"ALL.js"},"getAttributeNodeNS":{"annotation":"method","name":"getAttributeNodeNS","text":"()\tReturns an attribute node (with a namespace) as an Attribute object","commentRange":[166533,171779],"fileName":"ALL.js"},"getElementsByTagName":{"annotation":"method","name":"getElementsByTagName","text":"()\tReturns a NodeList of matching element nodes, and their children","commentRange":[166533,171779],"fileName":"ALL.js"},"getElementsByTagNameNS":{"annotation":"method","name":"getElementsByTagNameNS","text":"()\tReturns a NodeList of matching element nodes (with a namespace), and their children","commentRange":[166533,171779],"fileName":"ALL.js"},"getFeature":{"annotation":"method","name":"getFeature","text":"(feature,version)\tReturns a DOM object which implements the specialized APIs of the specified feature and version","commentRange":[166533,171779],"fileName":"ALL.js"},"getUserData":{"annotation":"method","name":"getUserData","text":"(key)\tReturns the object associated to a key on a this node. The object must first have been set to this node by calling setUserData with the same key","commentRange":[166533,171779],"fileName":"ALL.js"},"hasAttribute":{"annotation":"method","name":"hasAttribute","text":"()\tReturns whether an element has any attributes matching a specified name","commentRange":[166533,171779],"fileName":"ALL.js"},"hasAttributeNS":{"annotation":"method","name":"hasAttributeNS","text":"()\tReturns whether an element has any attributes matching a specified name and namespace","commentRange":[166533,171779],"fileName":"ALL.js"},"hasAttributes":{"annotation":"method","name":"hasAttributes","text":"()\tReturns whether the element has any attributes","commentRange":[166533,171779],"fileName":"ALL.js"},"hasChildNodes":{"annotation":"method","name":"hasChildNodes","text":"()\tReturns whether the element has any child nodes","commentRange":[166533,171779],"fileName":"ALL.js"},"insertBefore":{"annotation":"method","name":"insertBefore","text":"()\tInserts a new child node before an existing child node","commentRange":[166533,171779],"fileName":"ALL.js"},"isDefaultNamespace":{"annotation":"method","name":"isDefaultNamespace","text":"(URI)\tReturns whether the specified namespaceURI is the default","commentRange":[166533,171779],"fileName":"ALL.js"},"isEqualNode":{"annotation":"method","name":"isEqualNode","text":"()\tChecks if two nodes are equal","commentRange":[166533,171779],"fileName":"ALL.js"},"isSameNode":{"annotation":"method","name":"isSameNode","text":"()\tChecks if two nodes are the same node","commentRange":[166533,171779],"fileName":"ALL.js"},"isSupported":{"annotation":"method","name":"isSupported","text":"(feature,version)\tReturns whether a specified feature is supported on the element","commentRange":[166533,171779],"fileName":"ALL.js"},"lookupNamespaceURI":{"annotation":"method","name":"lookupNamespaceURI","text":"()\tReturns the namespace URI matching a specified prefix","commentRange":[166533,171779],"fileName":"ALL.js"},"lookupPrefix":{"annotation":"method","name":"lookupPrefix","text":"()\tReturns the prefix matching a specified namespace URI","commentRange":[166533,171779],"fileName":"ALL.js"},"normalize":{"annotation":"method","name":"normalize","text":"()\tPuts all text nodes underneath this element (including attributes) into a \"normal\" form where only structure (e.g., elements, comments, processing instructions, CDATA sections, and entity references) separates Text nodes, i.e., there are neither adjacent Text nodes nor empty Text nodes","commentRange":[166533,171779],"fileName":"ALL.js"},"removeAttribute":{"annotation":"method","name":"removeAttribute","text":"()\tRemoves a specified attribute","commentRange":[166533,171779],"fileName":"ALL.js"},"removeAttributeNS":{"annotation":"method","name":"removeAttributeNS","text":"()\tRemoves a specified attribute (with a namespace)","commentRange":[166533,171779],"fileName":"ALL.js"},"removeAttributeNode":{"annotation":"method","name":"removeAttributeNode","text":"()\tRemoves a specified attribute node","commentRange":[166533,171779],"fileName":"ALL.js"},"removeChild":{"annotation":"method","name":"removeChild","text":"()\tRemoves a child node","commentRange":[166533,171779],"fileName":"ALL.js"},"replaceChild":{"annotation":"method","name":"replaceChild","text":"()\tReplaces a child node","commentRange":[166533,171779],"fileName":"ALL.js"},"setUserData":{"annotation":"method","name":"setUserData","text":"(key,data,handler)\tAssociates an object to a key on the element","commentRange":[166533,171779],"fileName":"ALL.js"},"setAttribute":{"annotation":"method","name":"setAttribute","text":"()\tAdds a new attribute","commentRange":[166533,171779],"fileName":"ALL.js"},"setAttributeNS":{"annotation":"method","name":"setAttributeNS","text":"()\tAdds a new attribute (with a namespace)","commentRange":[166533,171779],"fileName":"ALL.js"},"setAttributeNode":{"annotation":"method","name":"setAttributeNode","text":"()\tAdds a new attribute node","commentRange":[166533,171779],"fileName":"ALL.js"},"setAttributeNodeNS":{"annotation":"method","name":"setAttributeNodeNS","text":"(attrnode)\tAdds a new attribute node (with a namespace)","commentRange":[166533,171779],"fileName":"ALL.js"},"setIdAttribute":{"annotation":"method","name":"setIdAttribute","text":"(name,isId)\tIf the isId property of the Attribute object is true, this method declares the specified attribute to be a user-determined ID attribute","commentRange":[166533,171779],"fileName":"ALL.js"},"setIdAttributeNS":{"annotation":"method","name":"setIdAttributeNS","text":"(uri,name,isId)\tIf the isId property of the Attribute object is true, this method declares the specified attribute (with a namespace) to be a user-determined ID attribute","commentRange":[166533,171779],"fileName":"ALL.js"},"setIdAttributeNode":{"annotation":"method","name":"setIdAttributeNode","text":"(idAttr,isId)\tIf the isId property of the Attribute object is true, this method declares the specified attribute to be a user-determined ID attribute","commentRange":[166533,171779],"fileName":"ALL.js"}}},"xml.dom.XMLNode":{"annotation":"class","name":"XMLNode","text":"(from http://www.w3schools.com/dom/dom_node.asp)\n\nXML DOM - The Node Object\n\nThe Node object represents a single node in the document tree.\n\nA node can be an element node, an attribute node, a text node, or any other of the node types explained in the Node Types chapter.\n\nNotice that while all objects inherits the Node properties / methods for dealing with parents and children, not all objects can have parents or children. For example, Text nodes may not have children, and adding children to such nodes results in a DOM error.","commentRange":[171781,172352],"fileName":"ALL.js","module":{"annotation":"module","name":"xml.dom","text":"","commentRange":[171781,172352],"fileName":"ALL.js"},"absoluteName":"xml.dom.XMLNode","properties":{"attributes":{"annotation":"property","type":"{Object}","name":"attributes","text":"A NamedNodeMap containing the attributes of this node (if it is an Element)","commentRange":[172356,174538],"fileName":"ALL.js"},"baseURI":{"annotation":"property","type":"{String}","name":"baseURI","text":"Returns the absolute base URI of a node","commentRange":[172356,174538],"fileName":"ALL.js"},"childNodes":{"annotation":"property","type":"{XMLNodeList}","name":"childNodes","text":"Returns a NodeList of child nodes for a node\n\n##Definition and Usage\nThe childNodes property returns a NodeList of child nodes for the specified node.\n\nTip: You can use the length property to determine the number of child nodes, then you can loop through all child nodes and extract the info you want.\n\n##Browser Support\nInternet Explorer Firefox Opera Google Chrome Safari\n\nThe childNodes property is supported in all major browsers.\n\n##Return Value:\t\nA NodeList object representing a collection of nodes\nDOM Version\tCore Level 1\n\n##Example\nThe following code fragment loads \"books.xml\" into xmlDoc using loadXMLDoc() and displays the child nodes of the XML document:\n\n\txmlDoc = loadXMLDoc(\"books.xml\");\n\n\tx = xmlDoc.childNodes;\n\tfor (i=0; i<x.length; i++)\n\t  {\n\t  document.write(\"Nodename: \" + x[i].nodeName);\n\t  document.write(\" (nodetype: \" + x[i].nodeType + \")<br>\");\n\t  }\n\nOutput IE:\n\n\tNodename: xml (nodetype: 7)\n\tNodename: #comment (nodetype: 8)\n\tNodename: bookstore (nodetype: 1)\n\nOutput Firefox, Opera, Chrome, and Safari :\n\n\tNodename: #comment (nodetype: 8)\n\tNodename: bookstore (nodetype: 1)","commentRange":[172356,174538],"fileName":"ALL.js"},"firstChild":{"annotation":"property","name":"firstChild","text":"Returns the first child of a node","commentRange":[172356,174538],"fileName":"ALL.js"},"lastChild":{"annotation":"property","name":"lastChild","text":"Returns the last child of a node","commentRange":[172356,174538],"fileName":"ALL.js"},"localName":{"annotation":"property","name":"localName","text":"Returns the local part of the name of a node","commentRange":[172356,174538],"fileName":"ALL.js"},"namespaceURI":{"annotation":"property","name":"namespaceURI","text":"Returns the namespace URI of a node","commentRange":[172356,174538],"fileName":"ALL.js"},"nextSibling":{"annotation":"property","name":"nextSibling","text":"Returns the node immediately following a node","commentRange":[172356,174538],"fileName":"ALL.js"},"nodeName":{"annotation":"property","name":"nodeName","text":"Returns the name of a node, depending on its type","commentRange":[172356,174538],"fileName":"ALL.js"},"nodeType":{"annotation":"property","name":"nodeType","text":"Returns the type of a node","commentRange":[172356,174538],"fileName":"ALL.js"},"nodeValue":{"annotation":"property","name":"nodeValue","text":"Sets or returns the value of a node, depending on its type","commentRange":[172356,174538],"fileName":"ALL.js"},"ownerDocument":{"annotation":"property","name":"ownerDocument","text":"Returns the root element (document object) for a node","commentRange":[172356,174538],"fileName":"ALL.js"},"parentNode":{"annotation":"property","name":"parentNode","text":"Returns the parent node of a node","commentRange":[172356,174538],"fileName":"ALL.js"},"prefix":{"annotation":"property","name":"prefix","text":"Sets or returns the namespace prefix of a node","commentRange":[172356,174538],"fileName":"ALL.js"},"previousSibling":{"annotation":"property","name":"previousSibling","text":"Returns the node immediately before a node","commentRange":[172356,174538],"fileName":"ALL.js"},"textContent":{"annotation":"property","name":"textContent","text":"Sets or returns the textual content of a node and its descendants","commentRange":[172356,174538],"fileName":"ALL.js"}},"methods":{"appendChild":{"annotation":"method","name":"appendChild","text":"Appends a new child node to the end of the list of children of a node","commentRange":[174543,176362],"fileName":"ALL.js"},"cloneNode":{"annotation":"method","name":"cloneNode","text":"Clones a node","commentRange":[174543,176362],"fileName":"ALL.js"},"compareDocumentPosition":{"annotation":"method","name":"compareDocumentPosition","text":"Compares the placement of two nodes in the DOM hierarchy (document)","commentRange":[174543,176362],"fileName":"ALL.js"},"getFeature":{"annotation":"method","name":"getFeature","text":"(feature,version)\tReturns a DOM object which implements the specialized APIs of the specified feature and version","commentRange":[174543,176362],"fileName":"ALL.js"},"getUserData":{"annotation":"method","name":"getUserData","text":"(key)\tReturns the object associated to a key on a this node. The object must first have been set to this node by calling setUserData with the same key","commentRange":[174543,176362],"fileName":"ALL.js"},"hasAttributes":{"annotation":"method","name":"hasAttributes","text":"Returns true if the specified node has any attributes, otherwise false","commentRange":[174543,176362],"fileName":"ALL.js"},"hasChildNodes":{"annotation":"method","name":"hasChildNodes","text":"Returns true if the specified node has any child nodes, otherwise false","commentRange":[174543,176362],"fileName":"ALL.js"},"insertBefore":{"annotation":"method","name":"insertBefore","text":"Inserts a new child node before an existing child node","commentRange":[174543,176362],"fileName":"ALL.js"},"isDefaultNamespace":{"annotation":"method","name":"isDefaultNamespace","text":"(URI)\tReturns whether the specified namespaceURI is the default","commentRange":[174543,176362],"fileName":"ALL.js"},"isEqualNode":{"annotation":"method","name":"isEqualNode","text":"Tests whether two nodes are equal","commentRange":[174543,176362],"fileName":"ALL.js"},"isSameNode":{"annotation":"method","name":"isSameNode","text":"Tests whether the two nodes are the same node","commentRange":[174543,176362],"fileName":"ALL.js"},"isSupported":{"annotation":"method","name":"isSupported","text":"Tests whether the DOM implementation supports a specific feature and that the feature is supported by the specified node","commentRange":[174543,176362],"fileName":"ALL.js"},"lookupNamespaceURI":{"annotation":"method","name":"lookupNamespaceURI","text":"Returns the namespace URI associated with a given prefix","commentRange":[174543,176362],"fileName":"ALL.js"},"lookupPrefix":{"annotation":"method","name":"lookupPrefix","text":"Returns the prefix associated with a given namespace URI","commentRange":[174543,176362],"fileName":"ALL.js"},"normalize":{"annotation":"method","name":"normalize","text":"Puts all Text nodes underneath a node (including attribute nodes) into a \"normal\" form where only structure (e.g., elements, comments, processing instructions, CDATA sections, and entity references) separates Text nodes, i.e., there are neither adjacent Text nodes nor empty Text nodes","commentRange":[174543,176362],"fileName":"ALL.js"},"removeChild":{"annotation":"method","name":"removeChild","text":"Removes a specified child node from the current node","commentRange":[174543,176362],"fileName":"ALL.js"},"replaceChild":{"annotation":"method","name":"replaceChild","text":"Replaces a child node with a new node","commentRange":[174543,176362],"fileName":"ALL.js"},"setUserData":{"annotation":"method","name":"setUserData","text":"(key,data,handler)\tAssociates an object to a key on a node","commentRange":[174543,176362],"fileName":"ALL.js"}}},"xml.dom.XMLNodeList":{"annotation":"class","name":"XMLNodeList","text":"XML DOM - The NodeList Object\n\nThe NodeList object represents an ordered list of nodes.\n\nThe nodes in the node list can be accessed through their index number (starting from 0).\n\nThe node list keeps itself up-to-date. If an element is deleted or added, in the node list or the XML document, the list is automatically updated.\n\nNote: In a node list, the nodes are returned in the order in which they are specified in the XML document.","commentRange":[176366,177013],"fileName":"ALL.js","module":{"annotation":"module","name":"xml.dom","text":"","commentRange":[176366,177013],"fileName":"ALL.js"},"absoluteName":"xml.dom.XMLNodeList","properties":{"length_":{"annotation":"property","name":"length_","text":"Returns the number of nodes in a node list k","commentRange":[176366,177013],"fileName":"ALL.js"}},"methods":{"item":{"annotation":"method","name":"item","text":"","children":[{"annotation":"param","type":"{Number}","name":"i","text":"","theRestString":"@return {XMLNode}Returns the node at the specified index in a node list"},{"annotation":"return","type":"{XMLNode}","name":"Returns","text":"the node at the specified index in a node list","theRestString":""}],"commentRange":[176366,177013],"fileName":"ALL.js"}}},"ideal.BaseObject":{"annotation":"class","name":"BaseObject","text":"","commentRange":[177015,177051],"fileName":"ALL.js","module":{"annotation":"module","name":"ideal","text":"","commentRange":[177015,177051],"fileName":"ALL.js"},"absoluteName":"ideal.BaseObject","properties":{"creationDate":{"annotation":"property","type":"{Date}","name":"creationDate","text":"","commentRange":[177163,177324],"fileName":"ALL.js"},"name":{"annotation":"property","type":"{String}","name":"name","text":"","commentRange":[177163,177324],"fileName":"ALL.js"},"description":{"annotation":"property","type":"{String}","name":"description","text":"","commentRange":[177163,177324],"fileName":"ALL.js"},"owners":{"annotation":"property","type":"{Object<String,User>}","name":"owners","text":"the owners, a map by owner id","commentRange":[177163,177324],"fileName":"ALL.js"}}},"ideal.ObjectPool":{"annotation":"class","name":"ObjectPool","text":"","commentRange":[177351,177370],"fileName":"ALL.js","module":{"annotation":"module","name":"ideal","text":"","commentRange":[177015,177051],"fileName":"ALL.js"},"absoluteName":"ideal.ObjectPool","methods":{"loadObjects":{"annotation":"method","name":"loadObjects","text":"","children":[{"annotation":"param","type":"{Array<String>}","name":"objects_ids","text":"","theRestString":"@return {Object<String,BaseObject>}"},{"annotation":"return","type":"{Object<String,BaseObject>}","text":"","theRestString":""}],"commentRange":[177396,177488],"fileName":"ALL.js","params":{"objects_ids":{"annotation":"param","type":"{Array<String>}","name":"objects_ids","text":"","commentRange":[177559,177596],"fileName":"ALL.js"}}},"getOwners":{"annotation":"method","name":"getOwners","text":"this method is useful for *blabla* blabla _blabla_ bab","commentRange":[177710,177784],"fileName":"ALL.js"},"getState":{"annotation":"method","name":"getState","text":"get's the current state of this pool","children":[{"annotation":"returns","type":"{#obj(id:String,objectDic:Object<String>)}","name":"bla","text":"bla bla","theRestString":""}],"commentRange":[177897,178020],"fileName":"ALL.js"}},"events":{"objectCreated":{"annotation":"event","name":"objectCreated","text":"event fired when an object is created in this pool.","commentRange":[178049,178124],"fileName":"ALL.js"}}},"ideal.Thing":{"annotation":"class","name":"Thing","text":"","children":[{"annotation":"extends","name":"BaseObject","text":"","theRestString":""}],"commentRange":[178238,178304],"fileName":"ALL.js","module":{"annotation":"module","name":"ideal","text":"","commentRange":[177015,177051],"fileName":"ALL.js"},"absoluteName":"ideal.Thing","properties":{"importance":{"annotation":"property","type":"{Number}","name":"importance","text":"","commentRange":[178238,178304],"fileName":"ALL.js"}}},"ideal.Action":{"annotation":"class","name":"Action","text":"","children":[{"annotation":"extends","name":"BaseObject","text":"","theRestString":""}],"commentRange":[178419,178459],"fileName":"ALL.js","module":{"annotation":"module","name":"ideal","text":"","commentRange":[177015,177051],"fileName":"ALL.js"},"absoluteName":"ideal.Action","methods":{"extract":{"annotation":"method","name":"extract","text":"","children":[{"annotation":"param","type":"{String|BaseObject|Array<BaseObject>}","name":"what","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js"}}},"ideasAndProblems67.Idea":{"annotation":"class","name":"Idea","text":"","commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"ideasAndProblems67.Idea"},"ideasAndProblems67.Problem":{"annotation":"class","name":"Problem","text":"","children":[{"annotation":"extends","name":"Idea","text":"","theRestString":"@param {Number} complexity"},{"annotation":"param","type":"{Number}","name":"complexity","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"ideasAndProblems67.Problem"},"ideasAndProblems67.IdealProblem":{"annotation":"class","name":"IdealProblem","text":"","children":[{"annotation":"extends","name":"Problem","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"ideasAndProblems67.IdealProblem"},"ideasAndProblems67.MathProblem":{"annotation":"class","name":"MathProblem","text":"","children":[{"annotation":"extends","name":"IdealProblem","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"ideasAndProblems67.MathProblem","properties":{"equations":{"annotation":"property","type":"{Object<String,Equation>}","name":"equations","text":"","commentRange":[178573,179461],"fileName":"ALL.js"}}},"ideasAndProblems67.Equation":{"annotation":"class","name":"Equation","text":"","commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"ideasAndProblems67.Equation","methods":{"resolve":{"annotation":"method","name":"resolve","text":"invoke this method to solve the equation","children":[{"annotation":"throws","type":"{EquationError}","name":"kja","text":"shkdj ahsd","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js"}},"events":{"afterThatHappens":{"annotation":"event","name":"afterThatHappens","text":"triggered when you-know-who comes the handler must be a ....","children":[{"annotation":"returns","type":"{Solution}","name":"because","text":"we are very practical","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js"}}},"ideasAndProblems67.Solution":{"annotation":"class","name":"Solution","text":"","commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"ideasAndProblems67.Solution"},"ideasAndProblems67.EquationError":{"annotation":"class","name":"EquationError","text":"","children":[{"annotation":"extends","name":"Error","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"ideasAndProblems67.EquationError"},"life.Living":{"annotation":"class","name":"Living","text":"","children":[{"annotation":"extends","name":"Thing","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"life","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"life.Living","methods":{"breath":{"annotation":"method","name":"breath","text":"","children":[{"annotation":"param","type":"{Number}","name":"size","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js"}}},"life.Animal":{"annotation":"class","name":"Animal","text":"","children":[{"annotation":"extends","name":"Living","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"life","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"life.Animal","methods":{"eat":{"annotation":"method","name":"eat","text":"","children":[{"annotation":"param","type":"{Array<Food>}","name":"food","text":"","theRestString":"@return {Array<Energy>}"},{"annotation":"return","type":"{Array<Energy>}","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js"}}},"life.Person":{"annotation":"class","name":"Person","text":"","children":[{"annotation":"extends","name":"Animal","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js","module":{"annotation":"module","name":"life","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"absoluteName":"life.Person","methods":{"walk":{"annotation":"method","name":"walk","text":"","children":[{"annotation":"return","type":"{Action}","text":"","theRestString":""}],"commentRange":[178573,179461],"fileName":"ALL.js"},"crossStreet":{"annotation":"method","name":"crossStreet","text":"This try to be a markdown [text](http://google.com)\n\nAnother paragraph \n\n\tvar someMarkup = {\n\t\ta: 1\n\t,\tn: 2\n\t,\tg: function (e)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t};\n\nand some final text with a list\n\n1. First ordered list item\n2. Another item\n  * Unordered sub-list.\n1. Actual numbers don't matter, just that it's a number\n  1. Ordered sub-list\n  2. hello\n4. And another item.","commentRange":[179462,179850],"fileName":"ALL.js"}}},"problem1.TerranObject":{"annotation":"class","name":"TerranObject","text":"","commentRange":[179853,180207],"fileName":"ALL.js","module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"},"absoluteName":"problem1.TerranObject"},"problem1.Person":{"annotation":"class","name":"Person","text":"","children":[{"annotation":"extends","name":"TerranObject","text":"","theRestString":""}],"commentRange":[179853,180207],"fileName":"ALL.js","module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"},"absoluteName":"problem1.Person"},"problem1.List":{"annotation":"class","name":"List","text":"This is just a semantic alias for javascript Array.","children":[{"annotation":"extends","name":"Array","text":"","theRestString":""}],"commentRange":[179853,180207],"fileName":"ALL.js","module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"},"absoluteName":"problem1.List"},"problem1.Map":{"annotation":"class","name":"Map","text":"This is just a semantic alias for javascript Object.","children":[{"annotation":"extends","name":"Object","text":"","theRestString":""}],"commentRange":[179853,180207],"fileName":"ALL.js","module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"},"absoluteName":"problem1.Map"},"problem1.Building":{"annotation":"class","name":"Building","text":"","children":[{"annotation":"extends","name":"TerranObject","text":"","theRestString":""}],"commentRange":[180209,180251],"fileName":"ALL.js","module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"},"absoluteName":"problem1.Building"},"problem1.Hospital":{"annotation":"class","name":"Hospital","text":"","children":[{"annotation":"extends","name":"Building","text":"","theRestString":""}],"commentRange":[180253,180812],"fileName":"ALL.js","module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"},"absoluteName":"problem1.Hospital","constructors":[{"annotation":"constructor","name":"n","text":"Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...","children":[{"annotation":"param","type":"{Number}","name":"availableBeds","text":"Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...","theRestString":""}],"commentRange":[180253,180812],"fileName":"ALL.js","params":[{"annotation":"param","type":"{Number}","name":"availableBeds","text":"Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...","theRestString":""}],"throws":[]}],"methods":{"getActiveDoctors":{"annotation":"method","name":"getActiveDoctors","text":"","children":[{"annotation":"returns","type":"{List<Doctor>}","name":"the","text":"currently active doctors in this hospital","theRestString":""}],"commentRange":[180253,180812],"fileName":"ALL.js"}},"properties":{"todayIngresedPatients":{"annotation":"property","type":"{Array<Person>}","name":"todayIngresedPatients","text":"all the patiens that entered this hospital today","commentRange":[180253,180812],"fileName":"ALL.js"}}},"problem1.Doctor":{"annotation":"class","name":"Doctor","text":"","children":[{"annotation":"extend","name":"Person","text":"","theRestString":""}],"commentRange":[180253,180812],"fileName":"ALL.js","module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"},"absoluteName":"problem1.Doctor","properties":{"skills":{"annotation":"property","type":"{Map<String,MedicalTopic>}","name":"skills","text":"","commentRange":[180253,180812],"fileName":"ALL.js"}}},"problem1.MedicalTopic":{"annotation":"class","name":"MedicalTopic","text":"Lorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum","commentRange":[180814,182006],"fileName":"ALL.js","module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"},"absoluteName":"problem1.MedicalTopic","methods":{"beUsed":{"annotation":"method","name":"beUsed","text":"Lorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum","children":[{"annotation":"throws","type":"{MedicalException}","name":"if","text":"there is any medical issue stuff...","theRestString":"@param {Number} amount Excepteur sint occaecat *cupidatat* \n\n@return {Array<MedicalTopic>}"},{"annotation":"param","type":"{Number}","name":"amount","text":"Excepteur sint occaecat *cupidatat*","theRestString":"@return {Array<MedicalTopic>}"},{"annotation":"return","type":"{Array<MedicalTopic>}","text":"","theRestString":""}],"commentRange":[180814,182006],"fileName":"ALL.js"}}},"problem1.MedicalException":{"annotation":"class","name":"MedicalException","text":"","children":[{"annotation":"extends","name":"Error","text":"","theRestString":""}],"commentRange":[180814,182006],"fileName":"ALL.js","module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"},"absoluteName":"problem1.MedicalException"}},"modules":{"javascript":{"annotation":"module","name":"javascript","text":"","commentRange":[0,3668],"fileName":"ALL.js"},"Backbone":{"annotation":"module","name":"Backbone","text":"\n\n#About\nBackbone.js gives structure to web applications by providing models with key-value binding and custom events, collections with a rich API of enumerable functions, views with declarative event handling, and connects it all to your existing API over a RESTful JSON interface.\n\nThe project is hosted on GitHub, and the annotated source code is available, as well as an online test suite, an example application, a list of tutorials and a long list of real-world projects that use Backbone. Backbone is available for use under the MIT software license.\n\nYou can report bugs and discuss features on the GitHub issues page, on Freenode IRC in the #documentcloud channel, post questions to the Google Group, add pages to the wiki or send tweets to","commentRange":[130571,130589],"fileName":"ALL.js"},"html":{"annotation":"module","name":"html","text":"","commentRange":[149172,157256],"fileName":"ALL.js"},"jquery":{"annotation":"module","name":"jquery","text":"","commentRange":[157258,157916],"fileName":"ALL.js"},"xml.dom":{"annotation":"module","name":"xml.dom","text":"","commentRange":[162478,165933],"fileName":"ALL.js"},"ideal":{"annotation":"module","name":"ideal","text":"","commentRange":[177015,177051],"fileName":"ALL.js"},"ideasAndProblems67":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"life":{"annotation":"module","name":"life","text":"","commentRange":[178573,179461],"fileName":"ALL.js"},"problem1":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[179853,180207],"fileName":"ALL.js"}}}
