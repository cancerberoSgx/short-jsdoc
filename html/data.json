{
    "source": "//@module ideal\n//@class BaseObject \nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n//@property {Date} creationDate\n//@property {String} name\n//@property {String} description\n//@property {Object<String,User>} owners the owners, a map by owner id\nfunction BaseObject(){};\n\n//@class ObjectPool\nfunction ObjectPool(){};\n//@method loadObjects @param {Array<String>} objects_ids @return {Object<String,BaseObject>}\nObjectPool.prototype.getOwners = function(objects_ids){return null;}\n\n// @param {Array<String>} objects_ids\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n\n//@method getOwners this method is useful for *blabla* blabla _blabla_ bab\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n// @method getState get's the current state of this pool\n// @returns {#obj(id:String,objectDic:Object<String>)} bla bla bla\nvar getState=function(){};\n\n// @event objectCreated event fired when an object is created in this pool.\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n\n//@class Thing @extends BaseObject\n//@property {Number} importance\n\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n\n/** @class Action @extends BaseObject */\n\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n//@method extract @param {String|BaseObject|Array<BaseObject>} what\n\n// @module Problems\n\n// @class Idea\n// @class Problem\n\n//@module life\n//@class Living @extends Thing\n//@method breath @param {Number} size\n\n//@class Animal @extends Living\n//@method eat @param {Array<Food>} food @return {Array<Energy>}\n\n//@class Person @extends Animal\n//@method walk @return {Action}\n/*@method crossStreet\n\nThis try to be a markdown [text](http://google.com)\n\nAnother paragraph \n\n\tvar someMarkup = {\n\t\ta: 1\n\t,\tn: 2\n\t,\tg: function (e)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t};\n\nand some final text with a list\n\n1. First ordered list item\n2. Another item\n  * Unordered sub-list.\n1. Actual numbers don't matter, just that it's a number\n  1. Ordered sub-list\n  2. hello\n4. And another item.\n*/\n\n\n// @module problem1 This is a description of planet earth city from the point of view of an alien observing us from a space ship.\n//@class TerranObject\n// @class Person @extends TerranObject\n\n//@class List This is just a semantic alias for javascript Array. @extends Array\n//@class Map This is just a semantic alias for javascript Object. @extends Object\n\n/*@class Building @extends TerranObject */\n\n//@class Hospital @extends Building\n//@constructor Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit... \n//@param {Number} availableBeds\n//Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...\n//@method getActiveDoctors @returns {List<Doctor>} the currently active doctors in this hospital\n//@property {Array<Person>} todayIngresedPatients all the patiens that entered this hospital today\n\n// @class Doctor @extend Person\n// @property {Map<String,MedicalTopic>} skills\n\n/*@class MedicalTopic\nLorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum\n\n\n@method beUsed \nLorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum\n\n@param {Number} amount Excepteur sint occaecat *cupidatat* \n\n@return {Array<MedicalTopic>}\n*/\n\n//@module shortjsdoc\n//@class AbstractView @extend Backbone.View @module shortjsdoc\n\nvar AbstractView = Backbone.View.extend({\n\n\ttagName: 'div'\n\n,\tinitialize: function(application) \n\t{\n\t\tthis.application = application;\n\t}\n\n\t//@method renderIn renders this view in given parent element @param {jQuery} $parent\n,\trenderIn: function($parent)\n\t{\n\t\tvar template = this.application.templates[this.template]; \n\t\tif(template)\n\t\t{\t\t\t\n\t\t\tvar html = template.apply(this, []); \n\t\t\tthis.$el.html(html);\n\t\t\t$parent.append(this.$el); \n\t\t}\n\t\tthis.afterRender();\n\t\treturn this;\n\t}\n\n\t//@method render implemented to comply with Backbone View contract\n,\trender: function()\n\t{\n\t\treturn this.renderIn(jQuery(this.el)); \n\t}\n\n\n,\tafterRender: function()\n\t{\n\t\tthis.renderSource(); \n\t}\n});\n\n\n\n//@module shortjsdoc\n// this is the main class for all the application\n// utilities for rendering jsdoc data generated by jsdocgenerator1 js-indentator plugin\n// using backbone. The user should provide with underscore templates. \n// @class AbstractView @extend Backbone.View @module shortjsdoc\n// @author: sgurin\n\n//@class Application \n//@constructor Application @param {Object} data\nvar Application = function(data)\n{\n\tthis.textFormat = 'markdown'; \n\t\n\tthis.templates = shortjsdoc; //global variable given b templates.js\n\n\t// this.parser = jsindentator.styles.shortJsDoc; \n\tthis.data = data; \n\n\tthis.maker = new JsDocMaker();\n\tthis.maker.data = data;\n\tthis.maker.postProccessBinding();\n\tthis.maker.postProccessInherited(); // <-- important - explicitly ask the framework to calculate inherited methods&properties\n\n\tif(jQuery('#mainContainer').size()===0)\n\t{\n\t\tjQuery('body').append('<div id=\"mainContainer\"></div>'); \n\t}\n\tthis.$containerEl = jQuery('#mainContainer'); \n};\n\n_(Application.prototype).extend({\n\n\t//@method start starts the application by instantiating routers and history and navigating to the index.\n\tstart: function()\n\t{\t\t\n\t\tthis.router = new JsDocRouter(this);\n\t\tBackbone.history.start();\n\t\tvar navigateTo = Backbone.history.getHash() || 'index'; \n\t\tBackbone.history.navigate(navigateTo, {trigger: true});\n\t}\n\n\t//@method showView @param {AbstractView} view\n,\tshowView: function(view)\n\t{\n\t\tthis.applicationView = this.applicationView || new ApplicationView(this); \n\t\tthis.currentView = view;\n\t\tthis.$containerEl.empty();\n\t\tthis.applicationView.renderIn(this.$containerEl);\n\t}\n\n\t//@method refreshWithNewModel @param {Object}data\n,\trefreshWithNewModel: function(data)\n\t{\n\t\tthis.data = data; \n\t\tBackbone.history.navigate('#index', {trigger: true}); \n\t\tthis.showView(this.currentView);\n\t}\n\n\t//@method showErrorView @param {String}s \n,\tshowErrorView: function(s) \n\t{\n\t\tthis.$containerEl.empty().append('<h1>'+s+'</h1>'); \n\t}\n\n});\n\n//@method start an application loading it with given data. @static\n//@param data the output of passing jsindentator JsDocMaker. \nApplication.startApplication = function(data)\n{\n\tvar app = new Application(data); \n\tapp.start();\n}; \n  \n\n//@module shortjsdoc\n//@class ApplicationView @extends AbstractView\nvar ApplicationView = AbstractView.extend({\n\n\tclassName: 'application-view'\n\n,\ttemplate: 'application'\n\n,\tinitialize: function(application) \n\t{\n\t\tthis.application = application;\n\t}\n\n,\trenderIn: function($el)\n\t{\n\t\tAbstractView.prototype.renderIn.apply(this, arguments); \n\n\t\tthis.headerView = this.headerView || new HeaderView(this.application);\n\t\tthis.headerView.renderIn(this.$('[data-type=\"header-container\"]')); \n\n\t\tthis.mainView = this.application.currentView; \n\n\t\tthis.mainView.renderIn(this.$('[data-type=\"main-view-container\"]')); \n\t}\n\n});\n\n//@module shortjsdoc\n//@class ClassView @extends AbstractView\n\nvar ClassView = AbstractView.extend({\n\n\tclassName: 'class-view'\n\n,\ttemplate: 'class'\n\n,\tinitialize: function(application, className, options) \n\t{\n\t\tthis.application = application;\n\t\tthis.jsdoc = this.application.data.classes[className]; \n\t\tif(!this.jsdoc)\n\t\t{\n\t\t\tthis.resourceNotFound = true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.jsdoc.textHtml = this.getTextHtml(this.jsdoc);\t\n\n\t\tthis.options = options || {};\n\t\tthis.options.inherited = this.options.inherited ? parseInt(this.options.inherited, 10) : 0;\n\n\t\tthis.methods = this.jsdoc.methods;\n\t\tif(this.options.inherited)\n\t\t{\n\t\t\tthis.methods = _(_(this.methods).clone()).extend(this.jsdoc.inherited.methods); \n\t\t}\n\n\t\tthis.properties = this.jsdoc.properties;\n\t\tif(this.options.inherited)\n\t\t{\n\t\t\tthis.properties = _(_(this.properties).clone()).extend(this.jsdoc.inherited.properties); \n\t\t}\n\t\t// this.hierarchy = this.computeHierarchy();\n\t}\n\n/*\n,\tcomputeHierarchy: function()\n\t{\n\t\tvar hierarchy = [];\n\t\tvar c = this.jsdoc;\n\t\tdo \n\t\t{\n\t\t\thierarchy = [c].concat(hierarchy);\n\t\t\tif(c.name===this.jsdoc.name)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile( (c = c.extends) ); \n\t\treturn hierarchy;\n\t}\n*/\n});\n\n//@module shortjsdoc\n//@class HeaderView @extends AbstractView\nvar HeaderView = AbstractView.extend({\n\n\tclassName: 'header-view'\n\n,\ttemplate: 'header'\n\n,\tinitialize: function(application) \n\t{\n\t\tthis.application = application;\n\t}\n\t\n,\trenderIn: function()\n\t{\n\t\tAbstractView.prototype.renderIn.apply(this, arguments); \n\t\tthis.installTypeAhead();\n\t}\n\n,\tinstallTypeAhead: function()\n\t{\n\t\tthis.classes = this.application.data.classes;\n\t\tthis.modules = this.application.data.modules;\n\n\t\tthis.typeahead = $('.main-header .typeahead1').typeahead({\n\t\t\thint: true,\n\t\t\thighlight: true,\n\t\t\tminLength: 1\n\t\t},\t{\n\t\t\tname: 'jsdoc',\n\t\t\tdisplayKey: 'value',\n\t\t\tsource: this.substringMatcher()\n\t\t});\n\n\t\tvar self = this;\n\t\tthis.typeahead.on('typeahead:selected', function()\n\t\t{\n\t\t\tself.handleSearchSelection.apply(self, arguments);\n\t\t});\n\t}\n\n,\thandleSearchSelection: function(event, object, dataset)\n\t{\n\t\tvar href = this.makeLink(object.node);\n\t\tBackbone.history.navigate(href, {trigger: true}); \n\t}\n\n,\tsearch: function(q)\n\t{\n\t\tvar self=this,matches = []\n\n\t\t// regex used to determine if a string contains the substring `q`\n\t\t,\tsubstrRegex = new RegExp(q, 'i');\n\n\t\t// iterate through the pool of strings and for any string that\n\t\t// contains the substring `q`, add it to the `matches` array\n\t\t_(self.classes).each(function (c)\n\t\t{\n\t\t\tif (substrRegex.test(c.name)) \n\t\t\t{\n\t\t\t\tmatches.push({ value: c.name, node: c });\n\t\t\t}\n\t\t\t_(c.methods).each(function (m)\n\t\t\t{\n\t\t\t\tif (substrRegex.test(m.name)) \n\t\t\t\t{\n\t\t\t\t\tmatches.push({ value: m.name, node: m });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}); \n\t\t}); \n\n\t\t_(self.modules).each(function (m)\n\t\t{\n\t\t\tif (substrRegex.test(m.name)) \n\t\t\t{\n\t\t\t\tmatches.push({ value: m.name, node: m });\n\t\t\t}\n\t\t}); \n\n\t\treturn matches;\n\t}\n\n,\tsubstringMatcher: function() \n\t{\n\t\tvar self = this;\n\t\treturn function findMatches(q, cb) \n\t\t{\n\t\t\tvar matches;\n\t\t\t// an array that will be populated with substring matches\n\t\t\tmatches = self.search(q);\t\t\t\n\t\t\tcb(matches);\n\t\t};\n\t}\n\n});\n\n\n//@module shortjsdoc\n//@class IndexView @extends AbstractView\nvar IndexView = AbstractView.extend({\n\n\tclassName: 'index'\n\n,\ttemplate: 'index'\n\n});\n\n//@module shortjsdoc\n//@class JsDocRouter @extends BackboneRouter\nvar JsDocRouter = Backbone.Router.extend({\n\n\troutes: {\n\t\t'class/:class': 'showClass'\n\t,\t'class/:class?:options': 'showClass'\n\n\t,\t'module/:module': 'showModule'\n\n\t,\t'method/:method': 'showMethod'\n\t,\t'constructor/:method': 'showMethod'\n\n\t,\t'property/:property': 'showProperty'\n\t,\t'event/:event': 'showEvent'\n\n\t,\t'index': 'showIndex'\n\t,\t'modules': 'showModules'\n\t,\t'classes': 'showClasses'\n\n\t,\t'parse': 'showParse'\n\t}\n\n,\tinitialize: function(application) \n\t{\n\t\tthis.application=application;\n\t}\n\n\t//@method showView @param {AbstractView}view @param {String} resourceName\n,\tshowView: function(view, resourceName)\n\t{\n\t\tresourceName = resourceName||'Resource'; \n\t\tif(view.resourceNotFound)\n\t\t{\n\t\t\tthis.application.showErrorView(resourceName+' '+resourceName+' not found!'); \n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.application.showView(view); \n\t\t}\n\t}\n\n\t//@method showModule  @param {String} moduleName\n,\tshowModule: function(moduleName) \n\t{\n\t\tvar view = new ModuleView(this.application, moduleName);\n\t\tthis.showView(view); \n\t}\n\n\t//method parseOptions @return {Object<String,String>}\n,\tparseOptions: function(options)\n\t{\n\t\tvar params = {};\n\t\t_(options.split('&')).each(function(p)\n\t\t{\n\t\t\tvar a = p.split('='); \n\t\t\tif (a.length >= 2)\n\t\t\t{\n\t\t\t\tparams[a[0]] = a[1]; \n\t\t\t}\n\t\t}); \n\t\treturn params;\n\t}\n\n\t//@method showClass  @param {String} className\n,\tshowClass: function(className, options) \n\t{\n\t\toptions = options || '';\n\t\tvar params = this.parseOptions(options);\t\t\n\t\tvar view = new ClassView(this.application, className, params);\n\t\tthis.showView(view); \n\t}\n\n\t//@method showMethod  @param {String} method\n,\tshowMethod: function(method)\n\t{\n\t\tvar view = new MethodView(this.application, method);\n\t\tthis.showView(view); \n\t}\n\n\t//@method showProperty  @param {String} property\n,\tshowProperty: function(property)\n\t{\n\t\tvar view = new PropertyView(this.application, property);\n\t\tthis.showView(view); \n\t}\n\n\t//@method showEvent  @param {String} event\n,\tshowEvent: function(event)\n\t{\n\t\tvar view = new PropertyView(this.application, event, true);\n\t\tthis.showView(view); \n\t}\n\n\t//@method showModules\n,\tshowModules: function()\n\t{\n\t\tvar view = new AbstractView(this.application);\n\t\tview.template = 'modules';\n\t\tthis.showView(view);\n\t}\n\t\n\t//@method showClasses\n,\tshowClasses: function()\n\t{\n\t\tvar view = new AbstractView(this.application);\n\t\tview.template = 'classes';\n\t\tthis.showView(view);\n\t}\n\t\n\t//@method showIndex\n,\tshowIndex: function() \n\t{\n\t\tvar view = new IndexView(this.application);\n\t\tthis.application.showView(view); \n\t}\n\n\t//@method showParse\n,\tshowParse: function() \n\t{\n\t\tvar view = new ParseView(this.application);\n\t\tthis.application.showView(view); \n\t}\n\n});\n\n\n//@module shortjsdoc\n//@class MethodView @extends AbstractView\nvar MethodView = AbstractView.extend({\n\n\tclassName: 'method-view'\n\n,\ttemplate: 'method'\n\n,\tinitialize: function(application, methodName) \n\t{\n\t\tthis.application = application;\n\t\tvar a = methodName.split('.');\n\t\tvar className = a[0] + '.' + a[1]; \n\t\tvar class_ = this.application.data.classes[className];\n\t\tvar methodSimpleName = a[2];\n\t\tif(!isNaN(parseInt(methodSimpleName, 10)))\n\t\t{\n\t\t\tthis.jsdoc = class_.constructors[parseInt(methodSimpleName, 10)]; \n\t\t\tthis.isConstructor = true;\n\t\t}\n\t\telse\n\t\t{\t\t\t\n\t\t\tthis.jsdoc = class_.methods[methodSimpleName]; \n\t\t\tthis.isConstructor = false;\n\t\t}\n\t\tif(!this.jsdoc)\n\t\t{\n\t\t\tthis.resourceNotFound = true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.jsdoc.textHtml = this.getTextHtml(this.jsdoc);\n\n\t\tdebugger;\n\t}\n\n});\n\n\n\n//@module shortjsdoc\n//@class ModuleView @extends AbstractView\nvar ModuleView = AbstractView.extend({\n\n\tclassName: 'module'\n\n,\ttemplate: 'module'\n\n,\tinitialize: function(application, moduleName) \n\t{\n\t\tthis.application = application;\n\t\tthis.jsdoc = this.application.data.modules[moduleName]; \n\t\tthis.classes = _( _(this.application.data.classes).values() ).filter(function(c){\n\t\t\treturn c.module.name === moduleName; \n\t\t}); \n\t\t\n\t\tthis.jsdoc.textHtml = this.getTextHtml(this.jsdoc);\t\n\t}\n\n});\n\n//@module shortjsdoc\n//@class ParseView @extends AbstractView\nvar ParseView = AbstractView.extend({\n\n\tclassName: \"parse\"\n\n,\tevents: {\n\t\t'click [data-action=\"inputcode_doit\"]': 'inputCodeDoit'\n\t}\n\n,\ttemplate: 'parse'\n\n,\tinputCodeDoit: function()\n\t{\n\t\tvar code = this.$('[data-type=\"inputcode\"]').val();\n\t\tvar maker = this.application.maker;\n\t\tmaker.parseFile(code, 'textarea');\t\t\n\t\tmaker.postProccess();\n\t\t//console.log(JSON.stringify(maker.data));\n\t\tmaker.postProccessBinding();\n\t\tthis.application.refreshWithNewModel(maker.data);\n\t\t// \n\t}\n\n});\n\n//@module shortjsdoc\n//@class PropertyView @extends AbstractView\nvar PropertyView = AbstractView.extend({\n\n\tclassName: \"property-view\"\n\n,\ttemplate: 'property'\n\n,\tinitialize: function(application, propertyName, isEvent) \n\t{\n\t\tthis.application = application;\n\t\tthis.isEvent = isEvent;\n\t\tvar a = propertyName.split('.');\n\t\tvar className = a[0] + '.' + a[1]; \n\t\tvar class_ = this.application.data.classes[className];\n\t\tvar propertySimpleName = a[2];\n\t\tthis.jsdoc = isEvent ? class_.events[propertySimpleName] : class_.properties[propertySimpleName];\n\t\tif(!this.jsdoc)\n\t\t{\n\t\t\tthis.resourceNotFound = true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.jsdoc.textHtml = this.getTextHtml(this.jsdoc);\t\t\n\t}\n\n\n});\n\n\n\n//@module shortjsdoc\n//@class SourcesView @extends AbstractView\nvar SourcesView = AbstractView.extend({\n\n\tclassName: \"sources\"\n\n,\ttemplate: 'sources'\n\n,\tevents: {\n\t\t'click [data-type=\"goto-source\"]': 'gotoSource'\n\t}\n\n,\tinitialize: function(application, jsdoc)\n\t{\n\t\tthis.application = application;\n\t\tthis.jsdoc = jsdoc;\n\t\tthis.allSource = this.application.maker.data.source; \n\n\t\tvar rangeRatio = 400;\n\t\tvar rangeMin = Math.max(0, this.jsdoc.commentRange[0] - rangeRatio);\n\t\tvar rangeMax = Math.min(this.allSource.length - 1, this.jsdoc.commentRange[1] + rangeRatio);\n\t\tthis.sourceSubset = this.allSource.substring(rangeMin, rangeMax);\n\t\tvar jsdocSource = this.allSource.substring(this.jsdoc.commentRange[0], this.jsdoc.commentRange[1]); \n\t\tvar previusSource = this.sourceSubset.substring(0, this.sourceSubset.indexOf(jsdocSource));\n\t\tvar previusSourceLineCount = previusSource.split('\\n').length; \n\n\t\tthis.jsdocLineNumber = previusSourceLineCount - 1;\n\n\t\tthis.lineCount = jsdocSource.split('\\n').length; \n\n\t\t//TODO: count the lines of the comment and show all the lines - not only the first one\n\t}\n\n,\tafterRender: function()\n\t{\n\t\tif(typeof prettyPrint !== 'undefined') \n\t\t{\n\t\t\tprettyPrint();\n\t\t}\n\t}\n\n,\tgotoSource: function()\n\t{\n\t\tvar selector = 'ol.linenums>li'\n\t\t,\t$target = jQuery(jQuery(selector).get(this.jsdocLineNumber));\n\t\tif($target.size())\n\t\t{\n\t\t\tjQuery(window).scrollTop($target.position().top);\n\t\t\t$target.addClass('selectedJsDocLine'); \n\t\t}\n\n\t\tfor (var i = 0; i < this.lineCount; i++) \n\t\t{\n\t\t\t$target = jQuery(jQuery(selector).get(this.jsdocLineNumber+i));\n\t\t\t$target.addClass('selectedJsDocLine'); \n\t\t}\n\t}\n});\n\n//@module shortjsdoc\n// this file add methods to Abstract Application for dealing with types and html markup. \n// @class AbstractView @extends BackboneView\n\n_(AbstractView.prototype).extend({\n\n\t//@method printTag\n\tprintTag: function(text, classAttribute, tag) {\n\t\ttag = tag || 'span'; \n\t\tclassAttribute = classAttribute ||'';\n\t\tif(text)\n\t\t{\n\t\t\treturn '<'+tag+ (classAttribute?(' class=\"'+classAttribute+'\"'):'') +'>'+text+'</'+tag+'>'; \n\t\t}\n\t\treturn '';\n\t}\n\n\t//@method simpleName @param {String}name\n,\tsimpleName: function(name)\n\t{\n\t\treturn this.application.maker.simpleName(name);\n\t}\n\n\t//@method makeLink @param {boolean} htmlAnchors will output anchor elements html\n,\tmakeLink: function(node, htmlAnchors)\n\t{\n\t\t// if (!node || !node.type) // no type for this node. This isn't undefined ! This means we just simply doesn't have the information.\n\t\t// {\n\t\t//\treturn '';\n\t\t// }\n\t\tvar className = node.annotation + '-name'; \n\t\tvar s = htmlAnchors ? ('<a class=\"' + className + '\" href=\"') : '';\n\t\tif(node.annotation==='method')\n\t\t{\n\t\t\ts += '#method/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='constructor')\n\t\t{\t\t\t\n\t\t\ts += '#constructor/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='property')\n\t\t{\n\t\t\ts += '#property/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='event')\n\t\t{\n\t\t\ts += '#event/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='class')\n\t\t{\n\t\t\ts += '#class/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='module')\n\t\t{\n\t\t\ts += '#module/' + node.name; \n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\ts += htmlAnchors?('\">'+node.name+'</a>'):'';\n\t\treturn s;\n\t}\n\n,\tprintLiteralObjectType: function(context)\n\t{\n\t\tvar self = this;\n\t\tvar buf = []; \n\t\tcontext.buffer.push(this.printType(context.type, true) + '{');\n\t\t_(context.type.objectProperties).each(function(value, key)\n\t\t{\n\t\t\tbuf.push(key + ': ' + self.printSingleTypeAsString(value));\n\t\t}); \n\t\tcontext.buffer.push(buf.join(', ')); \n\t}\n\t\n\t//@method printType prints a type as html support generic@param {Object}context  @return {String} the type html\n,\tprintType: function(context, ignoreLiteralObject)\n\t{\n\t\tif(!context || !context.type)\n\t\t{\n\t\t\treturn ''; \n\t\t}\n\n\t\tif(context.type.objectProperties && !ignoreLiteralObject)\n\t\t{\n\t\t\tthis.printLiteralObjectType(context); \n\t\t}\n\n\t\tvar self = this;\n\t\tvar href = context.type.nativeTypeUrl || '#class/'+context.type.absoluteName; \n\t\tvar htmlText = context.type.name; \n\t\t// htmlText += (context.type.nativeTypeUrl ? '<span class=\"external-label\">(external)</span>' : '');\n\t\t// htmlText += (context.type.nativeTypeUrl ? '<span class=\"glyphicon glyphicon-star\"></span>' : '');\n\t\tvar aclass = (context.type.nativeTypeUrl ? ' type external ' : ' type ');\n\t\tvar iconHtml = context.type.nativeTypeUrl ? '<span class=\"glyphicon glyphicon-share\"></span>' : ''; \n\n\t\tcontext.buffer.push('<a class=\"'+aclass+'\" href=\"'+href+'\">'+iconHtml+htmlText+'</a>');\n\n\t\tif(context.type.params) \n\t\t{ \n\t\t\tcontext.buffer.push('&lt;');\n\t\t\tfor (var i = 0; i < (context.type.params||[]).length; i++) \n\t\t\t{\n\t\t\t\tvar param = context.type.params[i]; \n\t\t\t\tself.printType({ //recurse!\n\t\t\t\t\ttype:param\n\t\t\t\t,\tbuffer: context.buffer\n\t\t\t\t});\n\t\t\t\tif(i < context.type.params.length - 1)\n\t\t\t\t{\n\t\t\t\t\tcontext.buffer.push(','); \n\t\t\t\t}\n\t\t\t}\n\t\t\tcontext.buffer.push('>'); \n\t\t} \n\t}\n\n\t//@method printTypeAsString this is the public method for printing a type - supports any type @param {String} type @return {String}  @return {String} the type html\n,\tprintSingleTypeAsString: function(type)\n\t{\n\t\tvar buffer = [];\n\t\tvar context = {type: type, typeTemplate: this.printType, buffer: buffer}; \n\t\tthis.printType(context); \n\t\tvar typeOutput = buffer.join(''); \n\t\treturn typeOutput; \n\t}\n\t//@method printTypeAsString @param {Array<Type>|Type} type @return {String} the type html\n,\tprintTypeAsString: function(type)\n\t{\n\t\tvar self = this;\n\t\tif(_(type).isArray())\n\t\t{\n\t\t\tvar a = [];\n\t\t\t_(type).each(function(t)\n\t\t\t{\n\t\t\t\ta.push(self.printSingleTypeAsString(t));\n\t\t\t}); \n\t\t\treturn a.join('<span class=\"type-separator\">or</span>'); \n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.printSingleTypeAsString(type); \n\t\t}\n\t}\n\t//@method getTextHtml depends on lib/marked/\n,\tgetTextHtml: function(node)\n\t{\n\t\tif(!node || !node.text)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\t\tvar text = node.text\n\t\t,\ttype = this.application.textFormat\n\t\t,\thtml = _(node.children).find(function(c){return c.annotation==='html'; })\n\t\t,\tmarkdown = _(node.children).find(function(c){return c.annotation==='markdown'; });\n\t\t\n\t\tif(html)\n\t\t{\n\t\t\ttype = 'html'; \n\t\t}\n\t\tif(markdown)\n\t\t{\n\t\t\ttype = 'markdown'; \n\t\t}\n\n\t\tif(type === 'markdown')\n\t\t{\n\t\t\treturn marked(text); \n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn text; \n\t\t}\n\t}\n\n\t//@method printMethod\n,\tprintMethod: function(m)\n\t{\n\t\tvar isConstructor = m.annotation==='constructor'; \n\t\tvar s = '<span class=\"method\">';\n\t\tvar methodName = isConstructor ? this.simpleName(m.ownerClass) : m.name;\n\t\tif(!isConstructor && m.returns)\n\t\t{\n\t\t\ts += this.printTypeAsString(m.returns) + '&nbsp;'; \n\t\t}\n\n\t\ts += '<a href=\"' + this.makeLink(m) + '\">' + methodName + '</a>'; \n\n\t\treturn s + '</span>';\n\t}\n\n,\trenderSource_: function(jsdoc, $container)\n\t{\n\t\tvar view = new SourcesView(this.application, jsdoc); \n\t\tview.renderIn($container); \n\t}\n\n\n,\trenderSource: function()\n\t{\n\t\tif(!this.jsdoc)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tthis.renderSource_(this.jsdoc, this.$('[data-type=\"sources\"]')); \n\t\tthis.$('pre code').addClass('prettyprint'); \n\t\tif(typeof prettyPrint !== 'undefined') \n\t\t{\n\t\t\tprettyPrint('pre code');\n\t\t}\n\t}\n\n\t\n,\tgetInherited: function(c, what)\n\t{\n\t\tvar data = {};\n\t\tif(what==='method')\n\t\t{\n\t\t\tdata = _(c.methods).clone();\n\t\t\t_(data).extend(c.inherited.methods || {});\n\t\t}\n\t\treturn data;\n\t}\n});\n\n\n//@module Backbone\n\n//@class BackboneView\n//@property {jQuery} $el\n//@property {jQuery} $\n//@property {HTMLElement} el\n//@method render\n\n//@class BackboneRouter\n//@class BackboneModel\n\n//@module jQuery\n// @class jQuery a jQuery Object\n\n/*\n@module javascript\n@class Boolean\n\n#Summary\nThe Boolean object is an object wrapper for a boolean value.\n\n#Constructor\n\tnew Boolean(value)\n\n#Description\nThe value passed as the first parameter is converted to a boolean value, if necessary. If value is omitted or is 0, -0, null, false, NaN, undefined, or the empty string (\"\"), the object has an initial value of false. All other values, including any object or the string \"false\", create an object with an initial value of true.\n\nDo not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.\n\nAny object whose value is not undefined or null, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement. For example, the condition in the following if statement evaluates to true:\n\n\tx = new Boolean(false);\n\tif (x) {\n\t  // . . . this code is executed\n\t}\n\tThis behavior does not apply to Boolean primitives. For example, the condition in the following if statement evaluates to false:\n\n\tx = false;\n\tif (x) {\n\t  // . . . this code is not executed\n\t}\nDo not use a Boolean object to convert a non-boolean value to a boolean value. Instead, use Boolean as a function to perform this task:\n\n\tx = Boolean(expression);     // preferred\n\tx = new Boolean(expression); // don't use\n\tIf you specify any object, including a Boolean object whose value is false, as the initial value of a Boolean object, the new Boolean object has a value of true.\n\n\tmyFalse = new Boolean(false);   // initial value of false\n\tg = new Boolean(myFalse);       // initial value of true\n\tmyString = new String(\"Hello\"); // string object\n\ts = new Boolean(myString);      // initial value of true\n\tDo not use a Boolean object in place of a Boolean primitive.\n\n#Properties\nFor properties available on Boolean instances, see Properties of Boolean instances.\n\nBoolean.length\nLength property whose value is 1.\nBoolean.prototype\nRepresents the prototype for the Boolean constructor.\n#Properties inherited from Function:\narity, caller, constructor, length, name\n##Methods\nFor methods available on Boolean instances, see Methods of Boolean instances.\n\nThe global Boolean object contains no methods of its own, however, it does inherit some methods through the prototype chain:\n\n#Methods inherited from Function:\napply, call, toSource, toString\n\n#Boolean instances\nAll Boolean instances inherit from Boolean.prototype. As with all constructors, the prototype object dictates instances' inherited properties and methods.\n\n#Properties\n\nBoolean.prototype.constructor\nReturns the function that created an instance's prototype. This is the Boolean function by default.\nProperties inherited from Object:\n__parent__, __proto__\n#Methods\n\nBoolean.prototype.toSource() \nReturns a string containing the source of the Boolean object; you can use this string to create an equivalent object. Overrides the Object.prototype.toSource() method.\nBoolean.prototype.toString()\nReturns a string of either \"true\" or \"false\" depending upon the value of the object. Overrides the Object.prototype.toString() method.\nBoolean.prototype.valueOf()\nReturns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.\n\n\n#Examples\nCreating Boolean objects with an initial value of false\n\n\tvar bNoParam = new Boolean();\n\tvar bZero = new Boolean(0);\n\tvar bNull = new Boolean(null);\n\tvar bEmptyString = new Boolean(\"\");\n\tvar bfalse = new Boolean(false);\n\tCreating Boolean objects with an initial value of true\n\n\tvar btrue = new Boolean(true);\n\tvar btrueString = new Boolean(\"true\");\n\tvar bfalseString = new Boolean(\"false\");\n\tvar bSuLin = new Boolean(\"Su Lin\");\n\n\n*/\n\n\n/*\n@method valueOf\n#Summary\nThe valueOf() method returns the primitive value of a Boolean object.\n\n#Syntax\n\tbool.valueOf()\n\n#Description\nThe valueOf method of Boolean returns the primitive value of a Boolean object or literal Boolean as a Boolean data type.\n\nThis method is usually called internally by JavaScript and not explicitly in code.\n\n#Examples\n##Example: Using valueOf\n\n\tx = new Boolean();\n\tmyVar = x.valueOf()      // assigns false to myVar\n*/\n\n/*\n@module javascript\n@class Error\n\n#Summary\nThe Error constructor creates an error object. Instances of Error objects are thrown when runtime errors occur. The Error object can also be used as a base objects for user-defined exceptions. See below for standard built-in error types.\n\n#Syntax\n\tnew Error([message[, fileName[,lineNumber]]])\n#Description\nRuntime errors result in new Error objects being created and thrown.\n\nThis page documents the use of the Error object itself and its use as a constructor function. For a list of properties and methods inherited by Error instances, see Error.prototype.\n\n#Error types\n\nBesides the generic Error constructor, there are six other core error constructors in JavaScript. For client-side exceptions, see Exception Handling Statements.\n\n\tEvalError\n\tCreates an instance representing an error that occurs regarding the global function eval().\n\tInternalError \n\tCreates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. \"too much recursion\".\n\tRangeError\n\tCreates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.\n\tReferenceError\n\tCreates an instance representing an error that occurs when de-referencing an invalid reference.\n\tSyntaxError\n\tCreates an instance representing a syntax error that occurs while parsing code in eval().\n\tTypeError\n\tCreates an instance representing an error that occurs when a variable or parameter is not of a valid type.\n\tURIError\n\tCreates an instance representing an error that occurs when encodeURI() or decodeURl() are passed invalid parameters.\n\n#Properties\nError.prototype\nAllows the addition of properties to Error instances.\n#Methods\nThe global Error object contains no methods of its own, however, it does inherit some methods through the prototype chain.\n\n#Error instances\nAll Error instances and instances of non-generic errors inherit from Error.prototype. As with all constructor functions, you can use the prototype of the constructor to add properties or methods to all instances created with that constructor.\n\n#Properties\n\n##Standard properties\n\nError.prototype.constructor\nSpecifies the function that created an instance's prototype.\n\tError.prototype.message\n\tError message.\n\tError.prototype.name\n\tError name.\n\n\n#Vendor-specific extensions\n\n##Non-standard\nThis feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.\n##Microsoft\n\n\tError.prototype.description\n\tError description. Similar to message.\n\tError.prototype.number\n\tError number.\n##Mozilla\n\n\tError.prototype.fileName\n\tPath to file that raised this error.\n\tError.prototype.lineNumber\n\tLine number in file that raised this error.\n\tError.prototype.columnNumber\n\tColumn number in line that raised this error.\n\tError.prototype.stack\n\tStack trace.\n\n#Examples\n##Example: Throwing a generic error\n\nUsually you create an Error object with the intention of raising it using the throw keyword. You can handle the error using the try...catch construct:\n\n\ttry {\n\t  throw new Error(\"Whoops!\");\n\t} catch (e) {\n\t  alert(e.name + \": \" + e.message);\n\t}\n\tExample: Handling a specific error\n\n\tYou can choose to handle only specific error types by testing the error type with the error's constructor property or, if you're writing for modern JavaScript engines, instanceof keyword:\n\n\ttry {\n\t  foo.bar();\n\t} catch (e) {\n\t  if (e instanceof EvalError) {\n\t    alert(e.name + \": \" + e.message);\n\t  } else if (e instanceof RangeError) {\n\t    alert(e.name + \": \" + e.message);\n\t  }\n\t  // ... etc\n\t}\n##Custom Error Types\n\nYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. The common way to do this is demonstrated below.\n\nNote that the thrown MyError will report incorrect lineNumber and fileName at least in Firefox.\nSee also the \"What's a good way to extend Error in JavaScript?\" discussion on Stackoverflow.\n\n\t// Create a new object, that prototypally inherits from the Error constructor.\n\tfunction MyError(message) {\n\t  this.name = \"MyError\";\n\t  this.message = message || \"Default Message\";\n\t}\n\tMyError.prototype = new Error();\n\tMyError.prototype.constructor = MyError;\n\n\ttry {\n\t  throw new MyError();\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"Default Message\"\n\t}\n\n\ttry {\n\t  throw new MyError(\"custom message\");\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"custom message\"\n\t}\n\n*/\n\n/*\n\n@constructor Boolean\n@param {String} message Human-readable description of the error\n@param {String} fileName The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.\n@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation.\n*/\n\n\n\n/*\n@module javascript\n\n@class Function\n\n#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.\n*/\n\n\n/*\n@property {Number} length\n\n#Summary\nThe length property specifies the number of arguments expected by the function.\n\n#Description\nlength is a property of a function object, and indicates how many arguments the function expects, i.e. the number of formal parameters. This number does not include the rest parameter. By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.\n\nData property of the Function constructor\n\nThe Function constructor is itself a Function object. It's length data property has a value of 1. The property attributes are: Writable: false, Enumerable: false, Configurable: true.\n\nProperty of the Function prototype object\n\nThe length property of the Function prototype object has a value of 0.\n\n#Examples\n\tconsole.log ( Function.length ); //1\n\n\tconsole.log( (function ()        {}).length ); //0\n\tconsole.log( (function (a)       {}).length ); //1\n\tconsole.log( (function (a, b)    {}).length ); //2 etc. \n\tconsole.log( (function (...args) {}).length ); //0, rest parameter is no\n\n*/\n\n\n/*\n@property {FunctionPrototype} prototype\n#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.\n*/\n\n\n\n/*\n@method apply\n\nThe apply() method calls a function with a given this value and arguments provided as an array (or an array-like object).\n\nNote: While the syntax of this function is almost identical to that of call(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.apply(thisArg, [argsArray])\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object. With apply, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\napply is very similar to call(), except for the type of arguments it supports. You can use an arguments array instead of a named set of parameters. With apply, you can use an array literal, for example, fun.apply(this, ['eat', 'bananas']), or an Array object, for example, fun.apply(this, new Array('eat', 'bananas')).\n\nYou can also use arguments for the argsArray parameter. arguments is a local variable of a function. It can be used for all unspecified arguments of the called object. Thus, you do not have to know the arguments of the called object when you use the apply method. You can use arguments to pass all the arguments to the called object. The called object is then responsible for handling the arguments.\n\nSince ECMAScript 5th Edition you can also use any kind of object which is array-like, so in practice this means it's going to have a property length and integer properties in the range [0...length). As an example you can now use a NodeList or a own custom object like {'length': 2, '0': 'eat', '1': 'bananas'}.\n\nNote: Most browsers, including Chrome 14 and Internet Explorer 9, still do not accept array-like objects and will throw an exception.\n#Examples\nUsing apply to chain constructors\n\nYou can use apply to chain constructors for an object, similar to Java. In the following example we will create a global Function method called construct, which will make you able to use an array-like object with a constructor instead of an arguments list.\n\n\tFunction.prototype.construct = function (aArgs) {\n\t    var fConstructor = this, fNewConstr = function () { fConstructor.apply(this, aArgs); };\n\t    fNewConstr.prototype = fConstructor.prototype;\n\t    return new fNewConstr();\n\t};\n\nExample usage:\n\n\tfunction MyConstructor () {\n\t    for (var nProp = 0; nProp < arguments.length; nProp++) {\n\t        this[\"property\" + nProp] = arguments[nProp];\n\t    }\n\t}\n\n\tvar myArray = [4, \"Hello world!\", false];\n\tvar myInstance = MyConstructor.construct(myArray);\n\n\talert(myInstance.property1); // alerts \"Hello world!\"\n\talert(myInstance instanceof MyConstructor); // alerts \"true\"\n\talert(myInstance.constructor); // alerts \"MyConstructor\"\n\nNote: This non-native Function.construct method will not work with some native constructors (like Date, for example). In these cases you have to use the Function.bind method (for example, imagine to have an array like the following, to be used with Date constructor: [2012, 11, 4]; in this case you have to write something like: new (Function.prototype.bind.apply(Date, [null].concat([2012, 11, 4])))() â€“ anyhow this is not the best way to do things and probably should not be used in any production environment).\nUsing apply and built-in functions\n\nClever usage of apply allows you to use built-ins functions for some tasks that otherwise probably would have been written by looping over the array values. As an example here we are going to use Math.max/Math.min to find out the maximum/minimum value in an array.\n\n\t//min/max number in an array \n\tvar numbers = [5, 6, 2, 3, 7];\n\n\t//using Math.min/Math.max apply \n\tvar max = Math.max.apply(null, numbers); // This about equal to Math.max(numbers[0], ...) or Math.max(5, 6, ..) \n\tvar min = Math.min.apply(null, numbers);\n\n\t/ vs. simple loop based algorithm \n\tmax = -Infinity, min = +Infinity;\n\n\tfor (var i = 0; i < numbers.length; i++) {\n\t  if (numbers[i] > max)\n\t    max = numbers[i];\n\t  if (numbers[i] < min) \n\t    min = numbers[i];\n\t}\n\nBut beware: in using apply this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (think more than tens of thousands of arguments) vary across engines (JavaScriptCore has hard-coded argument limit of 65536), because the limit (indeed even the nature of any excessively-large-stack behavior) is unspecified. Some engines will throw an exception. More perniciously, others will arbitrarily limit the number of arguments actually passed to the applied function. (To illustrate this latter case: if such an engine had a limit of four arguments [actual limits are of course significantly higher], it would be as if the arguments 5, 6, 2, 3 had been passed to apply in the examples above, rather than the full array.) If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:\n\n\tfunction minOfArray(arr) {\n\t  var min = Infinity;\n\t  var QUANTUM = 32768;\n\n\t  for (var i = 0, len = arr.length; i < len; i += QUANTUM) {\n\t    var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len)));\n\t    min = Math.min(submin, min);\n\t  }\n\n\t  return min;\n\t}\n\n\tvar min = minOfArray([5, 6, 2, 3, 7]);\nUsing apply in \"monkey-patching\"\n\nApply can be the best way to monkey-patch a builtin function of Firefox, or JS libraries. Given someobject.foo function, you can modify the function in a somewhat hacky way, like so:\n\n\tvar originalfoo = someobject.foo;\n\tsomeobject.foo = function() {\n\t  //Do stuff before calling function\n\t  console.log(arguments);\n\t  //Call the function as it would have been called normally:\n\t  originalfoo.apply(this,arguments);\n\t  //Run stuff after, here.\n\t}\n\nThis method is especially handy where you want to debug events, or interface with something that has no API like the various .on([event]... events, such as those usable on the Devtools Inspector).\n\n\n@param {Object}thisArg The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.\n@param {Array} argsArray An array-like object, specifying the arguments with which fun should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.\n\n@returns the result of evaluating this function with given context and parameters\n*/\n\n\n\n\n\n\n\n/*\n@method bind\n\n#Summary\nThe bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.\n\n#Syntax\n\tfun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nThe bind() function creates a new function (a bound function) with the same function body (internal call property in ECMAScript 5 terms) as the function it is being called on (the bound function's target function) with the this value bound to the first argument of bind(), which cannot be overridden. bind() also accepts leading default arguments to provide to the target function when the bound function is called. A bound function may also be constructed using the new operator: doing so acts as though the target function had instead been constructed. The provided this value is ignored, while prepended arguments are provided to the emulated function.\n\n#Examples\nCreating a bound function\n\nThe simplest use of bind() is to make a function that, no matter how it is called, is called with a particular this value. A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g. by using that method in callback-based code). Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:\n\n\tthis.x = 9; \n\tvar module = {\n\t  x: 81,\n\t  getX: function() { return this.x; }\n\t};\n\n\tmodule.getX(); // 81\n\n\tvar getX = module.getX;\n\tgetX(); // 9, because in this case, \"this\" refers to the global object\n\n\t// create a new function with 'this' bound to module\n\tvar boundGetX = getX.bind(module);\n\tboundGetX(); // 81\n\n##Partial Functions\n\nThe next simplest use of bind() is to make a function with pre-specified initial arguments. These arguments (if any) follow the provided this value and are then inserted at the start of the arguments passed to the target function, followed by the arguments passed to the bound function, whenever the bound function is called.\n\n\tfunction list() {\n\t  return Array.prototype.slice.call(arguments);\n\t}\n\n\tvar list1 = list(1, 2, 3); // [1, 2, 3]\n\n\t//  Create a function with a preset leading argument\n\tvar leadingThirtysevenList = list.bind(undefined, 37);\n\n\tvar list2 = leadingThirtysevenList(); // [37]\n\tvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n##With setTimeout\n\nBy default within window.setTimeout(), the this keyword will be set to the window (or global) object. When working with class methods that require this to refer to class instances, you may explicitly bind this to the callback function, in order to maintain the instance.\n\n\tfunction LateBloomer() {\n\t  this.petalCount = Math.ceil( Math.random() * 12 ) + 1;\n\t}\n\n\t// declare bloom after a delay of 1 second\n\tLateBloomer.prototype.bloom = function() {\n\t  window.setTimeout( this.declare.bind( this ), 1000 );\n\t};\n\n\tLateBloomer.prototype.declare = function() {\n\t  console.log('I am a beautiful flower with ' + \n\t    this.petalCount + ' petals!');\n\t};\n\n##Bound functions used as constructors\n\nWarning: This section demonstrates JavaScript capabilities and documents some edge cases of the bind() method. The methods shown below are not the best way to do things and probably should not be used in any production environment.\nBound functions are automatically suitable for use with the new operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided this is ignored. However, provided arguments are still prepended to the constructor call:\n\n\tfunction Point(x, y) {\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\n\tPoint.prototype.toString = function() { \n\t  return this.x + \",\" + this.y; \n\t};\n\n\tvar p = new Point(1, 2);\n\tp.toString(); // \"1,2\"\n\n\n\tvar emptyObj = {};\n\tvar YAxisPoint = Point.bind(emptyObj, 0);\n\t// not supported in the polyfill below, works fine with native bind:\n\tvar YAxisPoint = Point.bind(null,0 );\n\n\tvar axisPoint = new YAxisPoint(5);\n\taxisPoint.toString(); //  \"0,5\"\n\n\taxisPoint instanceof Point; // true\n\taxisPoint instanceof YAxisPoint; // true\n\tnew Point(17, 42) instanceof YAxisPoint; // false\nNote that you need do nothing special to create a bound function for use with new. The corollary is that you need do nothing special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using new.\n\n\t// Example can be run directly in your JavaScript console\n\t// ...continuing from above\n\n\t// Can still be called as a normal function \n\t// (although usually this is undesired)\n\tYAxisPoint(13);\n\n\temptyObj.x + \",\" + emptyObj.y;\n\t// >  \"0,13\"\nIf you wish to support use of a bound function only using new, or only by calling it, the target function must enforce that restriction.\n\n##Creating shortcuts\n\nbind() is also helpful in cases where you want to create a shortcut to a function which requires a specific this value.\n\nTake Array.prototype.slice, for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:\n\n\tvar slice = Array.prototype.slice;\n\n\t// ...\n\n\tslice.call(arguments);\n\tWith bind(), this can be simplified. In the following piece of code, slice is a bound function to the call() function of Function.prototype, with the this value set to the slice() function of Array.prototype. This means that additional call() calls can be eliminated:\n\n\t// same as \"slice\" in the previous example\n\tvar unboundSlice = Array.prototype.slice;\n\tvar slice = Function.prototype.call.bind(unboundSlice);\n\n\t// ...\n\n\tslice(arguments);\n#Polyfill\nThe bind function is a recent addition to ECMA-262, 5th edition; as such it may not be present in all browsers. You can partially work around this by inserting the following code at the beginning of your scripts, allowing use of much of the functionality of bind() in implementations that do not natively support it.\n\n\tif (!Function.prototype.bind) {\n\t  Function.prototype.bind = function (oThis) {\n\t    if (typeof this !== \"function\") {\n\t      // closest thing possible to the ECMAScript 5\n\t      // internal IsCallable function\n\t      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\t    }\n\n\t    var aArgs = Array.prototype.slice.call(arguments, 1), \n\t        fToBind = this, \n\t        fNOP = function () {},\n\t        fBound = function () {\n\t          return fToBind.apply(this instanceof fNOP && oThis\n\t                 ? this\n\t                 : oThis,\n\t                 aArgs.concat(Array.prototype.slice.call(arguments)));\n\t        };\n\n\t    fNOP.prototype = this.prototype;\n\t    fBound.prototype = new fNOP();\n\n\t    return fBound;\n\t  };\n\t}\n\nSome of the many differences (there may well be others, as this list does not seriously attempt to be exhaustive) between this algorithm and the specified algorithm are:\n\nThe partial implementation relies Array.prototype.slice, Array.prototype.concat, Function.prototype.call and Function.prototype.apply, built-in methods to have their original values.\nThe partial implementation creates functions that do not have immutable \"poison pill\" caller and arguments properties that throw a TypeError upon get, set, or deletion. (This could be added if the implementation supports Object.defineProperty, or partially implemented [without throw-on-delete behavior] if the implementation supports the __defineGetter__ and __defineSetter__ extensions.)\nThe partial implementation creates functions that have a prototype property. (Proper bound functions have none.)\nThe partial implementation creates bound functions whose length property does not agree with that mandated by ECMA-262: it creates functions with length 0, while a full implementation, depending on the length of the target function and the number of pre-specified arguments, may return a non-zero length.\nIf you choose to use this partial implementation, you must not rely on those cases where behavior deviates from ECMA-262, 5th edition! With some care, however (and perhaps with additional modification to suit specific needs), this partial implementation may be a reasonable bridge to the time when bind() is widely implemented according to the specification.\n\n@param thisArg The value to be passed as the this parameter to the target function when the bound function is called. The value is ignored if the bound function is constructed using the new operator.\n@param args Arguments to prepend to arguments provided to the bound function when invoking the target function.\n\n*/\n\n\n\n\n\n\n/*\n@method call\n\n#Summary\nThe call() method calls a function with a given this value and arguments provided individually.\n\nNOTE: While the syntax of this function is almost identical to that of apply(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.call(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object.\n\nWith call, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\n#Examples\n##Using call to chain constructors for an object\n\nYou can use call to chain constructors for an object, similar to Java. In the following example, the constructor for the Product object is defined with two parameters, name and price. Two other functions Food and Toy invoke Product passing this and name and price. Product initializes the properties name and price, both specialized functions define the category.\n\n\tfunction Product(name, price) {\n\t  this.name = name;\n\t  this.price = price;\n\n\t  if (price < 0) {\n\t    throw RangeError('Cannot create product ' +\n\t                      this.name + ' with a negative price');\n\t  }\n\n\t  return this;\n\t}\n\n\tfunction Food(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'food';\n\t}\n\n\tFood.prototype = Object.create(Product.prototype);\n\n\tfunction Toy(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'toy';\n\t}\n\n\tToy.prototype = Object.create(Product.prototype);\n\n\tvar cheese = new Food('feta', 5);\n\tvar fun = new Toy('robot', 40);\n \n##Using call to invoke an anonymous function\n\nIn this purely constructed example, we create anonymous function and use call to invoke it on every object in an array. The main purpose of the anonymous function here is to add a print function to every object, which is able to print the right index of the object in the array. Passing the object as this value was not strictly necessary, but is done for explanatory purpose.\n\n\tvar animals = [\n\t  {species: 'Lion', name: 'King'},\n\t  {species: 'Whale', name: 'Fail'}\n\t];\n\n\tfor (var i = 0; i < animals.length; i++) {\n\t  (function (i) { \n\t    this.print = function () { \n\t      console.log('#' + i  + ' ' + this.species \n\t                  + ': ' + this.name); \n\t    } \n\t    this.print();\n\t  }).call(animals[i], i);\n\t}\n\n\n@param thisArg The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.\n@param arg1,arg2,... Arguments for the object.\n\n*/\n\n\n\n\n/*\n@method toString\n#Summary\nThe toString() method returns a string representing the source code of the function.\n\n#Syntax\n\tfunction.toString(indentation)\n#Description\nThe Function object overrides the toString method inherited from Object; it does not inherit Object.prototype.toString. For Function objects, the toString method returns a string representation of the object in the form of a function declaration. That is, toString decompiles the function, and the string returned includes the function keyword, the argument list, curly braces, and the source of the function body.\n\nJavaScript calls the toString method automatically when a Function is to be represented as a text value, e.g. when a function is concatenated with a string.\n\n@return {String}\n*/\n\n/*\n@module javascript\n\n@class Object\nAdapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n\n@property {ObjectPrototype} prototype\n@static \n\n\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method __defineGetter__()  \nAssociates a function with a property that, when accessed, executes that function and returns its return value.\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method hasOwnProperty\n##Summary\nThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n##Syntax\nobj.hasOwnProperty(prop)\n\n##Examples\n###Example: Using hasOwnProperty to test for a property's existence\n\nThe following example determines whether the o object contains a property named prop:\n\n\to = new Object();\n\to.prop = 'exists';\n\n\tfunction changeO() {\n\t  o.newprop = o.prop;\n\t  delete o.prop;\n\t}\n\n\to.hasOwnProperty('prop');   // returns true\n\tchangeO();\n\to.hasOwnProperty('prop');   // returns false\n\n###Example: Direct versus inherited properties\n\nThe following example differentiates between direct properties and properties inherited through the prototype chain:\n\n\to = new Object();\n\to.prop = 'exists';\n\to.hasOwnProperty('prop');             // returns true\n\to.hasOwnProperty('toString');         // returns false\n\to.hasOwnProperty('hasOwnProperty');   // returns false\n\n##Example: Iterating over the properties of an object\n\nThe following example shows how to iterate over the properties of an object without executing on inherit properties. Note that the for..in loop is already only iterating enumerable items, so one should not assume based on the lack of non-enumerable properties shown in the loop that hasOwnProperty itself is confined strictly to enumerable items (as with Object.getOwnPropertyNames()).\n\n\tvar buz = {\n\t    fog: 'stack'\n\t};\n\n\tfor (var name in buz) {\n\t    if (buz.hasOwnProperty(name)) {\n\t        alert(\"this is fog (\" + name + \") for sure. Value: \" + buz[name]);\n\t    }\n\t    else {\n\t        alert(name); // toString or something else\n\t    }\n\t}\n\n###Example: hasOwnProperty as a property\n\nJavaScript does not protect the property name hasOwnProperty; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an external hasOwnProperty to get correct results:\n\n\tvar foo = {\n\t    hasOwnProperty: function() {\n\t        return false;\n\t    },\n\t    bar: 'Here be dragons'\n\t};\n\n\tfoo.hasOwnProperty('bar'); // always returns false\n\n\t// Use another Object's hasOwnProperty and call it with 'this' set to foo\n\t({}).hasOwnProperty.call(foo, 'bar'); // true\n\n\t// It's also possible to use the hasOwnProperty property from the Object property for this purpose\n\tObject.prototype.hasOwnProperty.call(foo, 'bar'); // true\n\nNote that in the last case there are no newly created objects.\n\n@param param The name of the property to test.\n\n*/\n\n\n\n\n\n\n\n\n/*\n@method isPrototypeOf\n##Summary\nThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\n\tNote: isPrototypeOf differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n\nThe isPrototypeOf method allows you to check whether or not an object exists within another object's prototype chain.\n\nFor example, consider the following prototype chain:\n\n\tfunction Fee() {\n\t  // . . .\n\t}\n\n\tfunction Fi() {\n\t  // . . .\n\t}\n\tFi.prototype = new Fee();\n\n\tfunction Fo() {\n\t  // . . .\n\t}\n\tFo.prototype = new Fi();\n\n\tfunction Fum() {\n\t  // . . .\n\t}\n\tFum.prototype = new Fo();\n\nLater on down the road, if you instantiate Fum and need to check if Fi's prototype exists within the Fum prototype chain, you could do this:\n\n\tvar fum = new Fum();\n\t. . .\n\t\n\tif (Fi.prototype.isPrototypeOf(fum)) {\n\t  // do something safe\n\t}\nThis, along with the instanceof operator particularly comes in handy if you have code that can only function when dealing with objects descended from a specific prototype chain, e.g., to guarantee that certain methods or properties will be present on that object.\n\n\n@param {Object} obj the object whose prototype chain will be searched\n*/\n\n\n\n\n\n/*\n@method propertyIsEnumerable\n##Summary\nThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n\n##Description\nEvery object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.\n\n##Examples\n###Example: A basic use of propertyIsEnumerable\n\nThe following example shows the use of propertyIsEnumerable on objects and arrays:\n\n\tvar o = {};\n\tvar a = [];\n\to.prop = 'is enumerable';\n\ta[0] = 'is enumerable';\n\n\to.propertyIsEnumerable('prop');   // returns true\n\ta.propertyIsEnumerable(0);        // returns true\n\n###Example: User-defined versus built-in objects\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n\tvar a = ['is enumerable'];\n\n\ta.propertyIsEnumerable(0);          // returns true\n\ta.propertyIsEnumerable('length');   // returns false\n\n\tMath.propertyIsEnumerable('random');   // returns false\n\tthis.propertyIsEnumerable('Math');     // returns false\n\tExample: Direct versus inherited properties\n\n\tvar a = [];\n\ta.propertyIsEnumerable('constructor');         // returns false\n\n\tfunction firstConstructor() {\n\t  this.property = 'is not enumerable';\n\t}\n\n\tfirstConstructor.prototype.firstMethod = function () {};\n\n\tfunction secondConstructor() {\n\t  this.method = function method() { return 'is enumerable'; };\n\t}\n\n\tsecondConstructor.prototype = new firstConstructor;\n\tsecondConstructor.prototype.constructor = secondConstructor;\n\n\tvar o = new secondConstructor();\n\to.arbitraryProperty = 'is enumerable';\n\n\to.propertyIsEnumerable('arbitraryProperty');   // returns true\n\to.propertyIsEnumerable('method');              // returns true\n\to.propertyIsEnumerable('property');            // returns false\n\n\to.property = 'is enumerable';\n\n\to.propertyIsEnumerable('property');            // returns true\n\n\t// These return false as they are on the prototype which \n\t// propertyIsEnumerable does not consider (even though the last two\n\t// are iteratable with for-in)\n\to.propertyIsEnumerable('prototype');   // returns false (as of JS 1.8.1/FF3.6)\n\to.propertyIsEnumerable('constructor'); // returns false\n\to.propertyIsEnumerable('firstMethod'); // returns false\n\n@param prop\nThe name of the property to test.\n*/\n\n\n\n\n/*\n@method toLocaleString\n##Summary\nThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n##Syntax\nobj.toLocaleString();\n##Description\nObject's toLocaleString returns the result of calling toString().\n\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. See the list below.\n\n##Objects overriding toLocaleString\n\nArray: Array.prototype.toLocaleString()\nNumber: Number.prototype.toLocaleString()\nDate: Date.prototype.toLocaleString()\n*/\n\n\n\n\n\n/*\n@method toString\n##Summary\nThe toString() method returns a string representing object.\n\n##Syntax\nobj.toString()\n##Description\nEvery object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected. By default, the toString() method is inherited by every object descended from Object. If this method is not overridden in a custom object, toString() returns \"[object type]\", where type is the object type. The following code illustrates this:\n\nvar o = new Object();\no.toString();           // returns [object Object]\nStarting in JavaScript 1.8.5 toString() called on null returns [object Null], and undefined returns [object Undefined], as defined in the 5th Edition of ECMAScript and a subsequent Errata. See Using toString to detect object type.\n##Examples\n###Overriding the default toString method\n\nYou can create a function to be called in place of the default toString() method. The toString() method takes no arguments and should return a string. The toString() method you create can be any value you want, but it will be most useful if it carries information about the object.\n\nThe following code defines the Dog object type and creates theDog, an object of type Dog:\n\n\tfunction Dog(name,breed,color,sex) {\n\t   this.name=name;\n\t   this.breed=breed;\n\t   this.color=color;\n\t   this.sex=sex;\n\t}\n\n\ttheDog = new Dog(\"Gabby\",\"Lab\",\"chocolate\",\"female\");\nIf you call the toString() method on this custom object, it returns the default value inherited from Object:\n\n\ttheDog.toString(); //returns [object Object]\n\tThe following code creates and assigns dogToString() to override the default toString() method. This function generates a string containing the name, breed, color, and sex of the object, in the form \"property = value;\".\n\n\tDog.prototype.toString = function dogToString() {\n\t  var ret = \"Dog \" + this.name + \" is a \" + this.sex + \" \" + this.color + \" \" + this.breed;\n\t  return ret;\n\t}\nWith the preceding code in place, any time theDog is used in a string context, JavaScript automatically calls the dogToString() function, which returns the following string:\n\nDog Gabby is a female chocolate Lab\nUsing toString() to detect object class\n\ntoString() can be used with every object and allows you to get its class. To use the Object.prototype.toString() with every object, you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter called thisArg.\n\n\tvar toString = Object.prototype.toString;\n\n\ttoString.call(new Date); // [object Date]\n\ttoString.call(new String); // [object String]\n\ttoString.call(Math); // [object Math]\n\n\t//Since JavaScript 1.8.5\n\ttoString.call(undefined); // [object Undefined]\n\ttoString.call(null); // [object Null]\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method create\n\n#Summary\nThe Object.create() method creates a new object with the specified prototype object and properties.\n\n#Syntax\n\tObject.create(proto[, propertiesObject])\n\n#Examples\n\n##Example: Classical inheritance with Object.create\n\nBelow is an example of how to use Object.create to achieve classical inheritance. This is for single inheritance, which is all that Javascript supports.\n\n\t// Shape - superclass\n\tfunction Shape() {\n\t  this.x = 0;\n\t  this.y = 0;\n\t}\n\n\t// superclass method\n\tShape.prototype.move = function(x, y) {\n\t  this.x += x;\n\t  this.y += y;\n\t  console.info('Shape moved.');\n\t};\n\n\t// Rectangle - subclass\n\tfunction Rectangle() {\n\t  Shape.call(this); // call super constructor.\n\t}\n\n\t// subclass extends superclass\n\tRectangle.prototype = Object.create(Shape.prototype);\n\tRectangle.prototype.constructor = Rectangle;\n\n\tvar rect = new Rectangle();\n\n\trect instanceof Rectangle; // true\n\trect instanceof Shape; // true\n\n\trect.move(1, 1); // Outputs, 'Shape moved.'\n\tIf you wish to inherit from multiple objects, then mixins are a possibility.\n\n\tfunction MyClass() {\n\t  SuperClass.call(this);\n\t  OtherSuperClass.call(this);\n\t}\n\n\tMyClass.prototype = Object.create(SuperClass.prototype); // inherit\n\tmixin(MyClass.prototype, OtherSuperClass.prototype); // mixin\n\n\tMyClass.prototype.myMethod = function() {\n\t  // do a thing\n\t};\n\nThe mixin function would copy the functions from the superclass prototype to the subclass prototype, the mixin function needs to be supplied by the user. An example of a mixin like function would be jQuery.extend.\n\n##Example: Using propertiesObject argument with Object.create\n\n\tvar o;\n\n\t// create an object with null as prototype\n\to = Object.create(null);\n\n\n\to = {};\n\t// is equivalent to:\n\to = Object.create(Object.prototype);\n\n\n\t// Example where we create an object with a couple of sample properties.\n\t// (Note that the second parameter maps keys to *property descriptors*.)\n\to = Object.create(Object.prototype, {\n\t  // foo is a regular 'value property'\n\t  foo: { writable: true, configurable: true, value: 'hello' },\n\t  // bar is a getter-and-setter (accessor) property\n\t  bar: {\n\t    configurable: false,\n\t    get: function() { return 10; },\n\t    set: function(value) { console.log('Setting `o.bar` to', value); }\n\t  }\n\t});\n\n\n\tfunction Constructor() {}\n\to = new Constructor();\n\t// is equivalent to:\n\to = Object.create(Constructor.prototype);\n\t// Of course, if there is actual initialization code in the\n\t// Constructor function, the Object.create cannot reflect it\n\n\n\t// create a new object whose prototype is a new, empty object\n\t// and a adding single property 'p', with value 42\n\to = Object.create({}, { p: { value: 42 } });\n\n\t// by default properties ARE NOT writable, enumerable or configurable:\n\to.p = 24;\n\to.p;\n\t// 42\n\n\to.q = 12;\n\tfor (var prop in o) {\n\t  console.log(prop);\n\t}\n\t// 'q'\n\n\tdelete o.p;\n\t// false\n\n\t// to specify an ES3 property\n\to2 = Object.create({}, {\n\t  p: {\n\t    value: 42,\n\t    writable: true,\n\t    enumerable: true,\n\t    configurable: true\n\t  }\n\t});\n\n##Polyfill\nThis polyfill covers the main use case which is creating a new object for which the prototype has been chosen but doesn't take the second argument into account.\n\n\tif (typeof Object.create != 'function') {\n\t  Object.create = (function() {\n\t    var Object = function() {};\n\t    return function (prototype) {\n\t      if (arguments.length > 1) {\n\t        throw Error('Second argument not supported');\n\t      }\n\t      if (typeof prototype != 'object') {\n\t        throw TypeError('Argument must be an object');\n\t      }\n\t      Object.prototype = prototype;\n\t      var result = new Object();\n\t      Object.prototype = null;\n\t      return result;\n\t    };\n\t  })();\n\t}\n\n@static\n\n@param {Object} proto The object which should be the prototype of the newly-created object.\n\n@param {Object} propertiesObject If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). @optional\n\n@throws Throws a TypeError exception if the proto parameter isn't null or an object.\n\n*/\n\n\n\n\n\n\n\n\n/*\n@method defineProperties\n\n#Summary\nThe Object.defineProperties() method defines new or modifies existing properties directly on an object, returning the object.\n\n#Syntax\n\tObject.defineProperties(obj, props)\n\n#Description\nObject.defineProperties, in essence, defines all properties corresponding to the enumerable own properties of props on the object obj object.\n\n#Example\n\n\tObject.defineProperties(obj, {\n\t  \"property1\": {\n\t    value: true,\n\t    writable: true\n\t  },\n\t  \"property2\": {\n\t    value: \"Hello\",\n\t    writable: false\n\t  }\n\t  // etc. etc.\n\t});\n\n\n# Polyfill\n\nAssuming a pristine execution environment with all names and properties referring to their initial values, Object.defineProperties is almost completely equivalent (note the comment in isCallable) to the following reimplementation in JavaScript:\n\n\tfunction defineProperties(obj, properties) {\n\t  function convertToDescriptor(desc) {\n\t    function hasProperty(obj, prop) {\n\t      return Object.prototype.hasOwnProperty.call(obj, prop);\n\t    }\n\n\t    function isCallable(v) {\n\t      // NB: modify as necessary if other values than functions are callable.\n\t      return typeof v === \"function\";\n\t    }\n\n\t    if (typeof desc !== \"object\" || desc === null)\n\t      throw new TypeError(\"bad desc\");\n\n\t    var d = {};\n\n\t    if (hasProperty(desc, \"enumerable\"))\n\t      d.enumerable = !!obj.enumerable;\n\t    if (hasProperty(desc, \"configurable\"))\n\t      d.configurable = !!obj.configurable;\n\t    if (hasProperty(desc, \"value\"))\n\t      d.value = obj.value;\n\t    if (hasProperty(desc, \"writable\"))\n\t      d.writable = !!desc.writable;\n\t    if (hasProperty(desc, \"get\")) {\n\t      var g = desc.get;\n\n\t      if (!isCallable(g) && typeof g !== \"undefined\")\n\t        throw new TypeError(\"bad get\");\n\t      d.get = g;\n\t    }\n\t    if (hasProperty(desc, \"set\")) {\n\t      var s = desc.set;\n\t      if (!isCallable(s) && typeof s !== \"undefined\")\n\t        throw new TypeError(\"bad set\");\n\t      d.set = s;\n\t    }\n\n\t    if ((\"get\" in d || \"set\" in d) && (\"value\" in d || \"writable\" in d))\n\t      throw new TypeError(\"identity-confused descriptor\");\n\n\t    return d;\n\t  }\n\n\t  if (typeof obj !== \"object\" || obj === null)\n\t    throw new TypeError(\"bad obj\");\n\n\t  properties = Object(properties);\n\n\t  var keys = Object.keys(properties);\n\t  var descs = [];\n\n\t  for (var i = 0; i < keys.length; i++)\n\t    descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);\n\n\t  for (var i = 0; i < descs.length; i++)\n\t    Object.defineProperty(obj, descs[i][0], descs[i][1]);\n\n\t  return obj;\n\t} \n\n\n@static \n\n@param {Object} obj The object on which to define or modify properties.\n@param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.\n\n\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method defineProperty\n\n#Summary\nThe Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\n\n#Syntax\nObject.defineProperty(obj, prop, descriptor)\n\n#Description\nThis method allows precise addition to or modification of a property on an object. Normal property addition through assignment creates properties which show up during property enumeration (for...in loop or Object.keys method), whose values may be changed, and which may be deleted. This method allows these extra details to be changed from their defaults.\n\nProperty descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both.\n\nBoth data and accessor descriptors are objects. They share the following optional keys:\n\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\nDefaults to false.\n\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\nDefaults to false.\nA data descriptor also has the following optional keys:\n\n###value\nThe value associated with the property. Can be any valid JavaScript value (number, object, function, etc).\nDefaults to undefined.\nwritable\ntrue if and only if the value associated with the property may be changed with an assignment operator.\nDefaults to false.\nAn accessor descriptor also has the following optional keys:\n\n###get\nA function which serves as a getter for the property, or undefined if there is no getter. The function return will be used as the value of property.\nDefaults to undefined.\n\n###set\nA function which serves as a setter for the property, or undefined if there is no setter. The function will receive as only argument the new value being assigned to the property.\nDefaults to undefined.\nBear in mind that these options are not necessarily own properties so, if inherited, will be considered too. In order to ensure these defaults are preserved you might freeze the Object.prototype upfront, specify all options explicitly, or point to null as __proto__ property.\n\n\t// using __proto__\n\tObject.defineProperty(obj, 'key', {\n\t  __proto__: null, // no inherited properties\n\t  value: 'static'  // not enumerable\n\t                   // not configurable\n\t                   // not writable\n\t                   // as defaults\n\t});\n\n\t// being explicit\n\tObject.defineProperty(obj, 'key', {\n\t  enumerable: false,\n\t  configurable: false,\n\t  writable: false,\n\t  value: 'static'\n\t});\n\n\t// recycling same object\n\tfunction withValue(value) {\n\t  var d = withValue.d || (\n\t    withValue.d = {\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false,\n\t      value: null\n\t    }\n\t  );\n\t  d.value = value;\n\t  return d;\n\t}\n\t// ... and ...\n\tObject.defineProperty(obj, 'key', withValue('static'));\n\n\t// if freeze is available, prevents the code to add\n\t// value, get, set, enumerable, writable, configurable\n\t// to the Object prototype\n\t(Object.freeze || Object)(Object.prototype);\n\n#Examples\n\nIf you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see additional examples.\n\n##Example: Creating a property\n\nWhen the property specified doesn't exist in the object, Object.defineProperty() creates a new property as described. Fields may be omitted from the descriptor, and default values for those fields are imputed. All of the Boolean-valued fields default to false. The value, get, and set fields default to undefined. A property which is defined without get/set/value/writable is called â€œgenericâ€ and is â€œtypedâ€ as a data descriptor.\n\n\tvar o = {}; // Creates a new object\n\n\t// Example of an object property added with defineProperty with a data property descriptor\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: true,\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\t// 'a' property exists in the o object and its value is 37\n\n\t// Example of an object property added with defineProperty with an accessor property descriptor\n\tvar bValue = 38;\n\tObject.defineProperty(o, 'b', {\n\t  get: function() { return bValue; },\n\t  set: function(newValue) { bValue = newValue; },\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\to.b; // 38\n\t// 'b' property exists in the o object and its value is 38\n\t// The value of o.b is now always identical to bValue, unless o.b is redefined\n\n\t// You cannot try to mix both:\n\tObject.defineProperty(o, 'conflict', {\n\t  value: 0x9f91102,\n\t  get: function() { return 0xdeadbeef; }\n\t});\n\t// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors\n\n##Example: Modifying a property\n\nWhen the property already exists, Object.defineProperty() attempts to modify the property according to the values in the descriptor and the object's current configuration. If the old descriptor had its configurable attribute set to false (the property is said to be â€œnon-configurableâ€), then no attribute besides writable can be changed. In that case, it is also not possible to switch back and forth between the data and accessor property types.\n\nIf a property is non-configurable, its writable attribute can only be changed to false.\n\nA TypeError is thrown when attempts are made to change non-configurable property attributes (besides the writable attribute) unless the current and new values are the same.\n\n##Writable attribute\n\nWhen the writable property attribute is set to false, the property is said to be â€œnon-writableâ€. It cannot be reassigned.\n\n\tvar o = {}; // Creates a new object\n\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: false\n\t});\n\n\tconsole.log(o.a); // logs 37\n\to.a = 25; // No error thrown (it would throw in strict mode, even if the value had been the same)\n\tconsole.log(o.a); // logs 37. The assignment didn't work.\n\nAs seen in the example, trying to write into the non-writable property doesn't change it but doesn't throw an error either.\n\n##Enumerable attribute\n\nThe enumerable property attribute defines whether the property shows up in a for...in loop and Object.keys() or not.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', { value: 1, enumerable: true });\n\tObject.defineProperty(o, 'b', { value: 2, enumerable: false });\n\tObject.defineProperty(o, 'c', { value: 3 }); // enumerable defaults to false\n\to.d = 4; // enumerable defaults to true when creating a property by setting it\n\n\tfor (var i in o) {\n\t  console.log(i);\n\t}\n\t// logs 'a' and 'd' (in undefined order)\n\n\tObject.keys(o); // ['a', 'd']\n\n\to.propertyIsEnumerable('a'); // true\n\to.propertyIsEnumerable('b'); // false\n\to.propertyIsEnumerable('c'); // false\n\tConfigurable attribute\n\n\tThe configurable attribute controls at the same time whether the property can be deleted from the object and whether its attributes (other than writable) can be changed.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', {\n\t  get: function() { return 1; },\n\t  configurable: false\n\t});\n\n\tObject.defineProperty(o, 'a', { configurable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { enumerable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { set: function() {} }); // throws a TypeError (set was undefined previously)\n\tObject.defineProperty(o, 'a', { get: function() { return 1; } }); // throws a TypeError (even though the new get does exactly the same thing)\n\tObject.defineProperty(o, 'a', { value: 12 }); // throws a TypeError\n\n\tconsole.log(o.a); // logs 1\n\tdelete o.a; // Nothing happens\n\tconsole.log(o.a); // logs 1\n\n\nIf the configurable attribute of o.a had been true, none of the errors would be thrown and the property would be deleted at the end.\n\n##Example: Adding properties and default values\n\nIt's important to consider the way default values of attributes are applied. There is often a difference between simply using dot notation to assign a value and using Object.defineProperty(), as shown in the example below.\n\n\tvar o = {};\n\n\to.a = 1;\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: true,\n\t  configurable: true,\n\t  enumerable: true\n\t});\n\n\n\t// On the other hand,\n\tObject.defineProperty(o, 'a', { value: 1 });\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: false,\n\t  configurable: false,\n\t  enumerable: false\n\t});\n\n\n##Example: Custom Setters and Getters\n\nExample below shows how to implement a self-archiving object. When temperature property is set, the archive array gets a log entry.\n\n\tfunction Archiver() {\n\t  var temperature = null;\n\t  var archive = [];\n\n\t  Object.defineProperty(this, 'temperature', {\n\t    get: function() {\n\t      console.log('get!');\n\t      return temperature;\n\t    },\n\t    set: function(value) {\n\t      temperature = value;\n\t      archive.push({ val: temperature });\n\t    }\n\t  });\n\n\t  this.getArchive = function() { return archive; };\n\t}\n\n\tvar arc = new Archiver();\n\tarc.temperature; // 'get!'\n\tarc.temperature = 11;\n\tarc.temperature = 13;\n\tarc.getArchive(); // [{ val: 11 }, { val: 13 }]\t\n\n\n@static\n@param {Object} obj The object on which to define the property.\n@param {String} prop The name of the property to be defined or modified.\n@param {Object} descriptor The descriptor for the property being defined or modified.\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method freeze\n\n#Summary\nThe Object.freeze() method freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen.\n\n#Syntax\nObject.freeze(obj)\n\n#Description\nNothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail, either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode).\n\nValues cannot be changed for data properties. Accessor properties (getters and setters) work the same (and still give the illusion that you are changing the value). Note that values that are objects can still be modified, unless they are also frozen.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.freeze(obj);\n\n\tassert(Object.isFrozen(obj) === true);\n\n\t// Now any changes will fail\n\tobj.foo = 'quux'; // silently does nothing\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors\n\tfunction fail(){\n\t  'use strict';\n\t  obj.foo = 'sparky'; // throws a TypeError\n\t  delete obj.quaxxor; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\n\tfail();\n\n\t// Attempted changes through Object.defineProperty will also throw\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // throws a TypeError\n\tThe following example shows that object values in a frozen object can be mutated (freeze is shallow).\n\n\tobj = {\n\t  internal: {}\n\t};\n\n\tObject.freeze(obj);\n\tobj.internal.a = 'aValue';\n\n\tobj.internal.a // 'aValue'\n\n\t// To make obj fully immutable, freeze each object in obj.\n\t// To do so, we use this function.\n\n\tfunction deepFreeze(o) {\n\t  var prop, propKey;\n\t  Object.freeze(o); // First freeze the object.\n\t  for (propKey in o) {\n\t    prop = o[propKey];\n\t    if (!o.hasOwnProperty(propKey) || !(typeof prop === 'object') || Object.isFrozen(prop)) {\n\t      // If the object is on the prototype, not an object, or is already frozen,\n\t      // skip it. Note that this might leave an unfrozen reference somewhere in the\n\t      // object if there is an already frozen object containing an unfrozen object.\n\t      continue;\n\t    }\n\n\t    deepFreeze(prop); // Recursively call deepFreeze.\n\t  }\n\t}\n\n\tobj2 = {\n\t  internal: {}\n\t};\n\n\tdeepFreeze(obj2);\n\tobj2.internal.a = 'anotherValue';\n\tobj2.internal.a; // undefined\n\n\n@static\n\n@param obj The object to freeze.\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method getOwnPropertyDescriptor\n\n#Summary\nThe Object.getOwnPropertyDescriptor() method returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object.\n\n#Syntax\n\tObject.getOwnPropertyDescriptor(obj, prop)\n\n#Description\nThis method permits examination of the precise description of a property. A property in JavaScript consists of a string-valued name and a property descriptor. Further information about property descriptor types and their attributes can be found in Object.defineProperty().\n\nA property descriptor is a record with some of the following attributes:\n\n###value\nThe value associated with the property (data descriptors only).\n###writable\ntrue if and only if the value associated with the property may be changed (data descriptors only).\n###get\nA function which serves as a getter for the property, or undefined if there is no getter (accessor descriptors only).\n###set\nA function which serves as a setter for the property, or undefined if there is no setter (accessor descriptors only).\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\n\n#Examples\n\n\tvar o, d;\n\n\to = { get foo() { return 17; } };\n\td = Object.getOwnPropertyDescriptor(o, 'foo');\n\t// d is { configurable: true, enumerable: true, get: , set: undefined }\n\n\to = { bar: 42 };\n\td = Object.getOwnPropertyDescriptor(o, 'bar');\n\t// d is { configurable: true, enumerable: true, value: 42, writable: true }\n\n\to = {};\n\tObject.defineProperty(o, 'baz', { value: 8675309, writable: false, enumerable: false });\n\td = Object.getOwnPropertyDescriptor(o, 'baz');\n\t// d is { value: 8675309, writable: false, enumerable: false, configurable: false }\n\n\n@static \n@param {Object}obj The object in which to look for the property.\n@param {String}prop The name of the property whose description is to be retrieved.\n@returns A property descriptor of the given property if it exists on the object, undefined otherwise.\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method getOwnPropertyNames\n\n#Summary\nThe Object.getOwnPropertyNames() method returns an array of all properties (enumerable or not) found directly upon a given object.\n\n#Syntax\nObject.getOwnPropertyNames(obj)\n\n#Description\nObject.getOwnPropertyNames returns an array whose elements are strings corresponding to the enumerable and non-enumerable properties found directly upon obj. The ordering of the enumerable properties in the array is consistent with the ordering exposed by a for...in loop (or by Object.keys) over the properties of the object. The ordering of the non-enumerable properties in the array, and among the enumerable properties, is not defined.\n\n#Examples\n##Example: Using getOwnPropertyNames\n\n\tvar arr = ['a', 'b', 'c'];\n\tprint(Object.getOwnPropertyNames(arr).sort()); // prints '0,1,2,length'\n\n\t// Array-like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tprint(Object.getOwnPropertyNames(obj).sort()); // prints '0,1,2'\n\n\t// Printing property names and values using Array.forEach\n\tObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n\t  print(val + ' -> ' + obj[val]);\n\t});\n\t// prints\n\t// 0 -> a\n\t// 1 -> b\n\t// 2 -> c\n\n\t// non-enumerable property\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: false } });\n\tmy_obj.foo = 1;\n\n\tprint(Object.getOwnPropertyNames(my_obj).sort()); // prints 'foo,getFoo'\n\nIf you want only the enumerable properties, see Object.keys() or use a for...in loop (although note that this will return enumerable properties not found directly upon that object but also along the prototype chain for the object unless the latter is filtered with hasOwnProperty()).\n\nItems on the prototype chain are not listed:\n\n\tfunction ParentClass() {}\n\tParentClass.prototype.inheritedMethod = function() {};\n\n\tfunction ChildClass() {\n\t  this.prop = 5;\n\t  this.method = function() {};\n\t}\n\tChildClass.prototype = new ParentClass;\n\tChildClass.prototype.prototypeMethod = function() {};\n\n\talert(\n\t  Object.getOwnPropertyNames(\n\t    new ChildClass() // ['prop', 'method']\n\t  )\n\t);\n\n##Example: Get Non-Enumerable Only\n\nThis uses the Array.prototype.filter() function to remove the enumerable keys (obtained with Object.keys()) from a list of all keys (obtained with Object.getOwnPropertyNames) leaving only the non-enumerable keys.\n\n\tvar target = myObject;\n\tvar enum_and_nonenum = Object.getOwnPropertyNames(target);\n\tvar enum_only = Object.keys(target);\n\tvar nonenum_only = enum_and_nonenum.filter(function(key) {\n\t  var indexInEnum = enum_only.indexOf(key);\n\t  if (indexInEnum == -1) {\n\t    // not found in enum_only keys mean the key is non-enumerable,\n\t    // so return true so we keep this in the filter\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t});\n\n\tconsole.log(nonenum_only);\n\n@static\n@param {Object} obj The object whose enumerable and non-enumerable own properties are to be returned.\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method isExtensible\n#Summary\nThe Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it).\n\n#Syntax\n\tObject.isExtensible(obj)\n\n#Description\nObjects are extensible by default: they can have new properties added to them, and (in engines that support __proto__  their __proto__ property) can be modified. An object can be marked as non-extensible using Object.preventExtensions(), Object.seal(), or Object.freeze().\n\n#Examples\n\t// New objects are extensible.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Sealed objects are by definition non-extensible.\n\tvar sealed = Object.seal({});\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// Frozen objects are also by definition non-extensible.\n\tvar frozen = Object.freeze({});\n\tassert(Object.isExtensible(frozen) === false);\n\tNotes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n\n\t> Object.isExtensible(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isExtensible(1)\n\tfalse                \n\n@static \n\n@param {Object} obj The object which should be checked.\n@return {boolean}\n*/\n\n\n\n\n/*\n@method isFrozen\n\n#Summary\nThe Object.isFrozen() determines if an object is frozen.\n\n#Syntax\n\tObject.isFrozen(obj)\n\n#Description\nAn object is frozen if and only if it is not extensible, all its properties are non-configurable, and all its data properties (that is, properties which are not accessor properties with getter or setter components) are non-writable.\n\n#Examples\n\t// A new object is extensible, so it is not frozen.\n\tassert(Object.isFrozen({}) === false);\n\n\t// An empty object which is not extensible is vacuously frozen.\n\tvar vacuouslyFrozen = Object.preventExtensions({});\n\tassert(Object.isFrozen(vacuouslyFrozen) === true);\n\n\t// A new object with one property is also extensible, ergo not frozen.\n\tvar oneProp = { p: 42 };\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// Preventing extensions to the object still doesn't make it frozen,\n\t// because the property is still configurable (and writable).\n\tObject.preventExtensions(oneProp);\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// ...but then deleting that property makes the object vacuously frozen.\n\tdelete oneProp.p;\n\tassert(Object.isFrozen(oneProp) === true);\n\n\t// A non-extensible object with a non-writable but still configurable property is not frozen.\n\tvar nonWritable = { e: 'plep' };\n\tObject.preventExtensions(nonWritable);\n\tObject.defineProperty(nonWritable, 'e', { writable: false }); // make non-writable\n\tassert(Object.isFrozen(nonWritable) === false);\n\n\t// Changing that property to non-configurable then makes the object frozen.\n\tObject.defineProperty(nonWritable, 'e', { configurable: false }); // make non-configurable\n\tassert(Object.isFrozen(nonWritable) === true);\n\n\t// A non-extensible object with a non-configurable but still writable property also isn't frozen.\n\tvar nonConfigurable = { release: 'the kraken!' };\n\tObject.preventExtensions(nonConfigurable);\n\tObject.defineProperty(nonConfigurable, 'release', { configurable: false });\n\tassert(Object.isFrozen(nonConfigurable) === false);\n\n\t// Changing that property to non-writable then makes the object frozen.\n\tObject.defineProperty(nonConfigurable, 'release', { writable: false });\n\tassert(Object.isFrozen(nonConfigurable) === true);\n\n\t// A non-extensible object with a configurable accessor property isn't frozen.\n\tvar accessor = { get food() { return 'yum'; } };\n\tObject.preventExtensions(accessor);\n\tassert(Object.isFrozen(accessor) === false);\n\n\t// ...but make that property non-configurable and it becomes frozen.\n\tObject.defineProperty(accessor, 'food', { configurable: false });\n\tassert(Object.isFrozen(accessor) === true);\n\n\t// But the easiest way for an object to be frozen is if Object.freeze has been called on it.\n\tvar frozen = { 1: 81 };\n\tassert(Object.isFrozen(frozen) === false);\n\tObject.freeze(frozen);\n\tassert(Object.isFrozen(frozen) === true);\n\n\t// By definition, a frozen object is non-extensible.\n\tassert(Object.isExtensible(frozen) === false);\n\n\t// Also by definition, a frozen object is sealed.\n\tassert(Object.isSealed(frozen) === true);\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n\n\t> Object.isFrozen(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isFrozen(1)\n\ttrue                          // ES6 code\n\n\n@static\n@param {Object}obj The object which should be checked.\n@returns boolean\n*/\n\n\n\n\n\n/*\n@method isSealed\n\n#Summary\nThe Object.isSealed() method determines if an object is sealed.\n\n#Syntax\n\tObject.isSealed(obj)\n#Description\nReturns true if the object is sealed, otherwise false. An object is sealed if it is not extensible and if all its properties are non-configurable and therefore not removable (but not necessarily non-writable).\n\n#Examples\n\t// Objects aren't sealed by default.\n\tvar empty = {};\n\tassert(Object.isSealed(empty) === false);\n\n\t// If you make an empty object non-extensible, it is vacuously sealed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isSealed(empty) === true);\n\n\t// The same is not true of a non-empty object, unless its properties are all non-configurable.\n\tvar hasProp = { fee: 'fie foe fum' };\n\tObject.preventExtensions(hasProp);\n\tassert(Object.isSealed(hasProp) === false);\n\n\t// But make them all non-configurable and the object becomes sealed.\n\tObject.defineProperty(hasProp, 'fee', { configurable: false });\n\tassert(Object.isSealed(hasProp) === true);\n\n\t// The easiest way to seal an object, of course, is Object.seal.\n\tvar sealed = {};\n\tObject.seal(sealed);\n\tassert(Object.isSealed(sealed) === true);\n\n\t// A sealed object is, by definition, non-extensible.\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// A sealed object might be frozen, but it doesn't have to be.\n\tassert(Object.isFrozen(sealed) === true); // all properties also non-writable\n\n\tvar s2 = Object.seal({ p: 3 });\n\tassert(Object.isFrozen(s2) === false); // 'p' is still writable\n\n\tvar s3 = Object.seal({ get p() { return 0; } });\n\tassert(Object.isFrozen(s3) === true); // only configurability matters for accessor properties\n\n#Notes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n\n\t> Object.isSealed(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isSealed(1)\n\ttrue                          // ES6 code\n\n\n@static\n@param {Object} obj The object which should be checked.\n@returns {boolean}\n*/\n\n\n\n\n\n\n\n/*\n@method keys\n#Summary\nThe Object.keys() method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n#Syntax\n\tObject.keys(obj)\n\n#Examples\n\tvar arr = ['a', 'b', 'c'];\n\tconsole.log(Object.keys(arr)); // console: ['0', '1', '2']\n\n\t// array like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tconsole.log(Object.keys(obj)); // console: ['0', '1', '2']\n\n\t// array like object with random key ordering\n\tvar an_obj = { 100: 'a', 2: 'b', 7: 'c' };\n\tconsole.log(Object.keys(an_obj)); // console: ['2', '7', '100']\n\n\t// getFoo is property which isn't enumerable\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\n\tmy_obj.foo = 1;\n\n\tconsole.log(Object.keys(my_obj)); // console: ['foo']\nIf you want all properties, even not enumerables, see Object.getOwnPropertyNames().\n\n#Polyfill\nTo add compatible Object.keys support in older environments that do not natively support it, copy the following snippet:\n\n\t// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n\tif (!Object.keys) {\n\t  Object.keys = (function() {\n\t    'use strict';\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty,\n\t        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n\t        dontEnums = [\n\t          'toString',\n\t          'toLocaleString',\n\t          'valueOf',\n\t          'hasOwnProperty',\n\t          'isPrototypeOf',\n\t          'propertyIsEnumerable',\n\t          'constructor'\n\t        ],\n\t        dontEnumsLength = dontEnums.length;\n\n\t    return function(obj) {\n\t      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n\t        throw new TypeError('Object.keys called on non-object');\n\t      }\n\n\t      var result = [], prop, i;\n\n\t      for (prop in obj) {\n\t        if (hasOwnProperty.call(obj, prop)) {\n\t          result.push(prop);\n\t        }\n\t      }\n\n\t      if (hasDontEnumBug) {\n\t        for (i = 0; i < dontEnumsLength; i++) {\n\t          if (hasOwnProperty.call(obj, dontEnums[i])) {\n\t            result.push(dontEnums[i]);\n\t          }\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t  }());\n\t}\nPlease note that the above code includes non-enumerable keys in IE7 (and maybe IE8), when passing in an object from a different window.\n\nFor a simple browser polyfill, see Javascript - Object.keys Browser Compatibility.\n\n@static\n@param {Object} obj The object whose enumerable own properties are to be returned.\n@returns {Array<String>} method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n*/\n\n\n\n\n\n\n\n\n/*\n@method preventExtensions\n\n#Summary\nThe Object.preventExtensions() method prevents new properties from ever being added to an object (i.e. prevents future extensions to the object).\n\n#Syntax\n\tObject.preventExtensions(obj)\n\n#Description\nAn object is extensible if new properties can be added to it. Object.preventExtensions() marks an object as no longer extensible, so that it will never have properties beyond the ones it had at the time it was marked as non-extensible. Note that the properties of a non-extensible object, in general, may still be deleted. Attempting to add new properties to a non-extensible object will fail, either silently or by throwing a TypeError (most commonly, but not exclusively, when in strict mode).\n\nObject.preventExtensions() only prevents addition of own properties. Properties can still be added to the object prototype. However, calling Object.preventExtensions() on an object will also prevent extensions on its __proto__  property.\n\nIf there is a way to turn an extensible object to a non-extensible one, there is no way to do the opposite in ECMAScript 5.\n\n#Examples\n\t// Object.preventExtensions returns the object being made non-extensible.\n\tvar obj = {};\n\tvar obj2 = Object.preventExtensions(obj);\n\tassert(obj === obj2);\n\n\t// Objects are extensible by default.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Object.defineProperty throws when adding a new property to a non-extensible object.\n\tvar nonExtensible = { removable: true };\n\tObject.preventExtensions(nonExtensible);\n\tObject.defineProperty(nonExtensible, 'new', { value: 8675309 }); // throws a TypeError\n\n\t// In strict mode, attempting to add new properties to a non-extensible object throws a TypeError.\n\tfunction fail() {\n\t  'use strict';\n\t  nonExtensible.newProperty = 'FAIL'; // throws a TypeError\n\t}\n\tfail();\n\n\t// EXTENSION (only works in engines supporting __proto__\n\t// (which is deprecated. Use Object.getPrototypeOf instead)):\n\t// A non-extensible object's prototype is immutable.\n\tvar fixed = Object.preventExtensions({});\n\tfixed.__proto__ = { oh: 'hai' }; // throws a TypeError\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return it.\n\n\t> Object.preventExtensions(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.preventExtensions(1)\n\t1                             // ES6 code\n\n@static\n@param {Object}obj The object which should be made non-extensible.\n\n*/\n\n\n\n\n\n\n\n/*\n@method hasOwnProperty\n\n#Summary\nThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n#Syntax\n\tobj.hasOwnProperty(prop)\n\n#Description\nEvery object descended from Object inherits the hasOwnProperty method. This method can be used to determine whether an object has the specified property as a direct property of that object; unlike the in operator, this method does not check down the object's prototype chain.\n\n#Examples\n##Example: Using hasOwnProperty to test for a property's existence\n\nThe following example determines whether the o object contains a property named prop:\n\n\to = new Object();\n\to.prop = 'exists';\n\n\tfunction changeO() {\n\t  o.newprop = o.prop;\n\t  delete o.prop;\n\t}\n\n\to.hasOwnProperty('prop');   // returns true\n\tchangeO();\n\to.hasOwnProperty('prop');   // returns false\n\tExample: Direct versus inherited properties\n\n\tThe following example differentiates between direct properties and properties inherited through the prototype chain:\n\n\to = new Object();\n\to.prop = 'exists';\n\to.hasOwnProperty('prop');             // returns true\n\to.hasOwnProperty('toString');         // returns false\n\to.hasOwnProperty('hasOwnProperty');   // returns false\n##Example: Iterating over the properties of an object\n\nThe following example shows how to iterate over the properties of an object without executing on inherit properties. Note that the for...in loop is already only iterating enumerable items, so one should not assume based on the lack of non-enumerable properties shown in the loop that hasOwnProperty itself is confined strictly to enumerable items (as with Object.getOwnPropertyNames()).\n\n\tvar buz = {\n\t  fog: 'stack'\n\t};\n\n\tfor (var name in buz) {\n\t  if (buz.hasOwnProperty(name)) {\n\t    alert('this is fog (' + name + ') for sure. Value: ' + buz[name]);\n\t  }\n\t  else {\n\t    alert(name); // toString or something else\n\t  }\n\t}\n##Example: hasOwnProperty as a property\n\nJavaScript does not protect the property name hasOwnProperty; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an external hasOwnProperty to get correct results:\n\n\tvar foo = {\n\t  hasOwnProperty: function() {\n\t    return false;\n\t  },\n\t  bar: 'Here be dragons'\n\t};\n\n\tfoo.hasOwnProperty('bar'); // always returns false\n\n\t// Use another Object's hasOwnProperty and call it with 'this' set to foo\n\t({}).hasOwnProperty.call(foo, 'bar'); // true\n\n\t// It's also possible to use the hasOwnProperty property from the Object prototype for this purpose\n\tObject.prototype.hasOwnProperty.call(foo, 'bar'); // true\nNote that in the last case there are no newly created objects.\n\n@static \n@param {String}prop The name of the property to test.\n\n*/\n\n\n\n\n\n\n\n/*\n@method  isPrototypeOf\n\n\n#Summary\nThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\nNote: isPrototypeOf differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n#Syntax\n\tprototypeObj.isPrototypeOf(obj)\n#Description\nThe isPrototypeOf method allows you to check whether or not an object exists within another object's prototype chain.\n\nFor example, consider the following prototype chain:\n\n\tfunction Fee() {\n\t  // ...\n\t}\n\n\tfunction Fi() {\n\t  // ...\n\t}\n\tFi.prototype = new Fee();\n\n\tfunction Fo() {\n\t  // ...\n\t}\n\tFo.prototype = new Fi();\n\n\tfunction Fum() {\n\t  // ...\n\t}\n\tFum.prototype = new Fo();\nLater on down the road, if you instantiate Fum and need to check if Fi's prototype exists within the Fum prototype chain, you could do this:\n\n\tvar fum = new Fum();\n\t// ...\n\n\tif (Fi.prototype.isPrototypeOf(fum)) {\n\t  // do something safe\n\t}\nThis, along with the instanceof operator particularly comes in handy if you have code that can only function when dealing with objects descended from a specific prototype chain, e.g., to guarantee that certain methods or properties will be present on that object.\n\n\n@static \n@param {Object} prototypeObj An object to be tested against each link in the prototype chain of the object argument.\n@param {Object}object The object whose prototype chain will be searched.\n@returns {boolean}\n*/\n\n\n\n\n\n\n/*\n\n@method propertyIsEnumerable\n\n#Summary\nThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n#Syntax\n\tobj.propertyIsEnumerable(prop)\n\n#Description\nEvery object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.\n\n#Examples\n##Example: A basic use of propertyIsEnumerable\n\nThe following example shows the use of propertyIsEnumerable on objects and arrays:\n\n\tvar o = {};\n\tvar a = [];\n\to.prop = 'is enumerable';\n\ta[0] = 'is enumerable';\n\n\to.propertyIsEnumerable('prop');   // returns true\n\ta.propertyIsEnumerable(0);        // returns true\n##Example: User-defined versus built-in objects\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n\tvar a = ['is enumerable'];\n\n\ta.propertyIsEnumerable(0);          // returns true\n\ta.propertyIsEnumerable('length');   // returns false\n\n\tMath.propertyIsEnumerable('random');   // returns false\n\tthis.propertyIsEnumerable('Math');     // returns false\n##Example: Direct versus inherited properties\n\n\tvar a = [];\n\ta.propertyIsEnumerable('constructor');         // returns false\n\n\tfunction firstConstructor() {\n\t  this.property = 'is not enumerable';\n\t}\n\n\tfirstConstructor.prototype.firstMethod = function() {};\n\n\tfunction secondConstructor() {\n\t  this.method = function method() { return 'is enumerable'; };\n\t}\n\n\tsecondConstructor.prototype = new firstConstructor;\n\tsecondConstructor.prototype.constructor = secondConstructor;\n\n\tvar o = new secondConstructor();\n\to.arbitraryProperty = 'is enumerable';\n\n\to.propertyIsEnumerable('arbitraryProperty');   // returns true\n\to.propertyIsEnumerable('method');              // returns true\n\to.propertyIsEnumerable('property');            // returns false\n\n\to.property = 'is enumerable';\n\n\to.propertyIsEnumerable('property');            // returns true\n\n\t// These return false as they are on the prototype which \n\t// propertyIsEnumerable does not consider (even though the last two\n\t// are iteratable with for-in)\n\to.propertyIsEnumerable('prototype');   // returns false (as of JS 1.8.1/FF3.6)\n\to.propertyIsEnumerable('constructor'); // returns false\n\to.propertyIsEnumerable('firstMethod'); // returns false\n\n\n@param {String}prop The name of the property to test.\n@return {boolean}\n\n*/\n\n\n\n/*\n@method toLocaleString\n#Summary\nThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n#Syntax\n\tobj.toLocaleString();\n#Description\nObject's toLocaleString returns the result of calling toString().\n\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. See the list below.\n\nObjects overriding toLocaleString\n\n\tArray: Array.prototype.toLocaleString()\n\tNumber: Number.prototype.toLocaleString()\n\tDate: Date.prototype.toLocaleString()\n*/\n\n\n\n/*\n@method toString\n\n#Summary\nThe toString() method returns a string representing object.\n\n#Syntax\n\tobj.toString()\n#Description\nEvery object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected. By default, the toString() method is inherited by every object descended from Object. If this method is not overridden in a custom object, toString() returns \"[object type]\", where type is the object type. The following code illustrates this:\n\n\tvar o = new Object();\n\to.toString();           // returns [object Object]\nNote: Starting in JavaScript 1.8.5 toString() called on null returns [object Null], and undefined returns [object Undefined], as defined in the 5th Edition of ECMAScript and a subsequent Errata. See Using toString to detect object type.\n#Examples\n##Example: Overriding the default toString method\n\nYou can create a function to be called in place of the default toString() method. The toString() method takes no arguments and should return a string. The toString() method you create can be any value you want, but it will be most useful if it carries information about the object.\n\nThe following code defines the Dog object type and creates theDog, an object of type Dog:\n\n\tfunction Dog(name, breed, color, sex) {\n\t  this.name = name;\n\t  this.breed = breed;\n\t  this.color = color;\n\t  this.sex = sex;\n\t}\n\n\ttheDog = new Dog('Gabby', 'Lab', 'chocolate', 'female');\nIf you call the toString() method on this custom object, it returns the default value inherited from Object:\n\n\ttheDog.toString(); // returns [object Object]\nThe following code creates and assigns dogToString() to override the default toString() method. This function generates a string containing the name, breed, color, and sex of the object, in the form \"property = value;\".\n\n\tDog.prototype.toString = function dogToString() {\n\t  var ret = 'Dog ' + this.name + ' is a ' + this.sex + ' ' + this.color + ' ' + this.breed;\n\t  return ret;\n\t}\n\nWith the preceding code in place, any time theDog is used in a string context, JavaScript automatically calls the dogToString() function, which returns the following string:\n\n\tDog Gabby is a female chocolate Lab\n\n##Example: Using toString() to detect object class\n\ntoString() can be used with every object and allows you to get its class. To use the Object.prototype.toString() with every object, you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter called thisArg.\n\n\tvar toString = Object.prototype.toString;\n\n\ttoString.call(new Date);    // [object Date]\n\ttoString.call(new String);  // [object String]\n\ttoString.call(Math);        // [object Math]\n\n\t// Since JavaScript 1.8.5\n\ttoString.call(undefined);   // [object Undefined]\n\ttoString.call(null);        // [object Null]\n\n@return{String}returns a string representing object.\n*/\n\n\n\n\n\n/*\n@method valueOf\n#Summary\nThe valueOf() method returns the primitive value of the specified object.\n\n#Syntax\n\tobject.valueOf()\n#Description\nJavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\n\nBy default, the valueOf method is inherited by every object descended from Object. Every built-in core object overrides this method to return an appropriate value. If an object has no primitive value, valueOf returns the object itself, which is displayed as:\n\n\t[object Object]\nYou can use valueOf within your own code to convert a built-in object into a primitive value. When you create a custom object, you can override Object.prototype.valueOf() to call a custom method instead of the default Object method.\n\n##Overriding valueOf for custom objects\n\nYou can create a function to be called in place of the default valueOf method. Your function must take no arguments.\n\nSuppose you have an object type myNumberType and you want to create a valueOf method for it. The following code assigns a user-defined function to the object's valueOf method:\n\n\tmyNumberType.prototype.valueOf = function() { return customPrimitiveValue; };\nWith the preceding code in place, any time an object of type myNumberType is used in a context where it is to be represented as a primitive value, JavaScript automatically calls the function defined in the preceding code.\n\nAn object's valueOf method is usually invoked by JavaScript, but you can invoke it yourself as follows:\n\n\tmyNumber.valueOf()\nNote: Objects in string contexts convert via the toString() method, which is different from String objects converting to string primitives using valueOf. All objects have a string conversion, if only \"[object type]\". But many objects do not convert to number, boolean, or function.\n#Examples\n##Example: Using valueOf\n\n\to = new Object();\n\tmyVar = o.valueOf();      // [object Object]\n*/\n\n\n\n\n/*\n@method seal\n#Summary\nThe Object.seal() method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.\n\n#Syntax\n\tObject.seal(obj)\n\n#Description\nBy default, objects are extensible (new properties can be added to them). Sealing an object prevents new properties from being added and marks all existing properties as non-configurable. This has the effect of making the set of properties on the object fixed and immutable. Making all properties non-configurable also prevents them from being converted from data properties to accessor properties and vice versa, but it does not prevent the values of data properties from being changed. Attempting to delete or add properties to a sealed object, or to convert a data property to accessor or vice versa, will fail, either silently or by throwing a TypeError (most commonly, although not exclusively, when in strict mode code).\n\nThe prototype chain remains untouched. However, the __proto__  property is sealed as well.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed.\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.seal(obj);\n\n\tassert(o === obj);\n\tassert(Object.isSealed(obj) === true);\n\n\t// Changing property values on a sealed object still works.\n\tobj.foo = 'quux';\n\n\t// But you can't convert data properties to accessors, or vice versa.\n\tObject.defineProperty(obj, 'foo', { get: function() { return 'g'; } }); // throws a TypeError\n\n\t// Now any changes, other than to property values, will fail.\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\tdelete obj.foo; // silently doesn't delete the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors.\n\tfunction fail() {\n\t  'use strict';\n\t  delete obj.foo; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\tfail();\n\n\t// Attempted additions through Object.defineProperty will also throw.\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // changes existing property value\n\n@static \n\n@param  obj The object which should be sealed.\n*/\n\n/*\n\n@module javascript \n\n\n\n@class ObjectPrototype\n\nAdapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\n\nThe Object.prototype property represents the Object prototype object.\n\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden (except an Object with a null prototype, i.e. Object.create(null)). For example, other constructors' prototypes override the constructor property and provide their own toString() methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.\n\n*/\n\n\n\n/*\n\n\n\n@property {Function} constructor Specifies the function that creates an object's prototype.\n\n##Summary\nReturns a reference to the Object function that created the instance's prototype. Note that the value of this property is a reference to the function itself, not a string containing the function's name. The value is only read-only for primitive values such as 1, true and \"test\".\n\n##Description\n\nAll objects inherit a constructor property from their prototype:\n\n\tvar o = {};\n\to.constructor === Object; // true\n\n\tvar a = [];\n\ta.constructor === Array; // true\n\n\tvar n = new Number(3);\n\tn.constructor === Number; // true\n\n##Examples\n\n###Example: Displaying the constructor of an object\n\nThe following example creates a prototype, Tree, and an object of that type, theTree. The example then displays the constructor property for the object theTree.\n\n\tfunction Tree(name) {\n\t  this.name = name;\n\t}\n\n\tvar theTree = new Tree('Redwood');\n\tconsole.log('theTree.constructor is ' + theTree.constructor);\n\tThis example displays the following output:\n\n\ttheTree.constructor is function Tree(name) {\n\t  this.name = name;\n\t}\n\n###Example: Changing the constructor of an object\n\nThe following example shows how to modify constructor value of generic objects. Only true, 1 and \"test\" will not be affected as they have read-only native constructors. This example shows that it is not always safe to rely on the constructor property of an object.\n\n\tfunction Type () {}\n\n\tvar types = [\n\t  new Array(),\n\t  [],\n\t  new Boolean(),\n\t  true,             // remains unchanged\n\t  new Date(),\n\t  new Error(),\n\t  new Function(),\n\t  function () {},\n\t  Math,\n\t  new Number(),\n\t  1,                // remains unchanged\n\t  new Object(),\n\t  {},\n\t  new RegExp(),\n\t  /(?:)/,\n\t  new String(),\n\t  'test'            // remains unchanged\n\t];\n\tfor (var i = 0; i < types.length; i++) {\n\t  types[i].constructor = Type;\n\t  types[i] = [types[i].constructor, types[i] instanceof Type, types[i].toString()];\n\t}\n\tconsole.log(types.join('\\n'));\n\tThis example displays the following output:\n\n\tfunction Type() {},false,\n\tfunction Type() {},false,\n\tfunction Type() {},false,false\n\tfunction Boolean() {\n\t    [native code]\n\t},false,true\n\tfunction Type() {},false,Mon Sep 01 2014 16:03:49 GMT+0600\n\tfunction Type() {},false,Error\n\tfunction Type() {},false,function anonymous() {\n\n\t}\n\tfunction Type() {},false,function () {}\n\tfunction Type() {},false,[object Math]\n\tfunction Type() {},false,0\n\tfunction Number() {\n\t    [native code]\n\t},false,1\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,\n\tfunction String() {\n\t    [native code]\n\t},false,Ñ‚ÐµÑÑ‚\n\n*/\n\n\n\n\n\n\n\n/*\n@property {Object} __proto__ \nPoints to the object which was used as prototype when the object was instantiated.\n\n@property {Function} __noSuchMethod__ \nAllows a function to be defined that will be executed when an undefined object member is called as a method.\n*/\n\n",
    "classes": {
        "ideal.BaseObject": {
            "annotation": "class",
            "name": "BaseObject",
            "text": "",
            "commentRange": [
                0,
                36
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "ideal",
                "text": "",
                "commentRange": [
                    0,
                    36
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "ideal.BaseObject",
            "properties": {
                "creationDate": {
                    "annotation": "property",
                    "type": "{Date}",
                    "name": "creationDate",
                    "text": "",
                    "commentRange": [
                        148,
                        309
                    ],
                    "fileName": "ALL.js"
                },
                "name": {
                    "annotation": "property",
                    "type": "{String}",
                    "name": "name",
                    "text": "",
                    "commentRange": [
                        148,
                        309
                    ],
                    "fileName": "ALL.js"
                },
                "description": {
                    "annotation": "property",
                    "type": "{String}",
                    "name": "description",
                    "text": "",
                    "commentRange": [
                        148,
                        309
                    ],
                    "fileName": "ALL.js"
                },
                "owners": {
                    "annotation": "property",
                    "type": "{Object<String,User>}",
                    "name": "owners",
                    "text": "the owners, a map by owner id",
                    "commentRange": [
                        148,
                        309
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "ideal.ObjectPool": {
            "annotation": "class",
            "name": "ObjectPool",
            "text": "",
            "commentRange": [
                336,
                355
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "ideal",
                "text": "",
                "commentRange": [
                    0,
                    36
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "ideal.ObjectPool",
            "methods": {
                "loadObjects": {
                    "annotation": "method",
                    "name": "loadObjects",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{Array<String>}",
                            "name": "objects_ids",
                            "text": "",
                            "theRestString": "@return {Object<String,BaseObject>}"
                        },
                        {
                            "annotation": "return",
                            "type": "{Object<String,BaseObject>}",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        381,
                        473
                    ],
                    "fileName": "ALL.js",
                    "params": {
                        "objects_ids": {
                            "annotation": "param",
                            "type": "{Array<String>}",
                            "name": "objects_ids",
                            "text": "",
                            "commentRange": [
                                544,
                                581
                            ],
                            "fileName": "ALL.js"
                        }
                    }
                },
                "getOwners": {
                    "annotation": "method",
                    "name": "getOwners",
                    "text": "this method is useful for *blabla* blabla _blabla_ bab",
                    "commentRange": [
                        695,
                        769
                    ],
                    "fileName": "ALL.js"
                },
                "getState": {
                    "annotation": "method",
                    "name": "getState",
                    "text": "get's the current state of this pool",
                    "children": [
                        {
                            "annotation": "returns",
                            "type": "{#obj(id:String,objectDic:Object<String>)}",
                            "name": "bla",
                            "text": "bla bla",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        882,
                        1005
                    ],
                    "fileName": "ALL.js"
                }
            },
            "events": {
                "objectCreated": {
                    "annotation": "event",
                    "name": "objectCreated",
                    "text": "event fired when an object is created in this pool.",
                    "commentRange": [
                        1034,
                        1109
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "ideal.Thing": {
            "annotation": "class",
            "name": "Thing",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "BaseObject",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                1223,
                1289
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "ideal",
                "text": "",
                "commentRange": [
                    0,
                    36
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "ideal.Thing",
            "properties": {
                "importance": {
                    "annotation": "property",
                    "type": "{Number}",
                    "name": "importance",
                    "text": "",
                    "commentRange": [
                        1223,
                        1289
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "ideal.Action": {
            "annotation": "class",
            "name": "Action",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "BaseObject",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                1404,
                1444
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "ideal",
                "text": "",
                "commentRange": [
                    0,
                    36
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "ideal.Action",
            "methods": {
                "extract": {
                    "annotation": "method",
                    "name": "extract",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String|BaseObject|Array<BaseObject>}",
                            "name": "what",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        1558,
                        1927
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "Problems.Idea": {
            "annotation": "class",
            "name": "Idea",
            "text": "",
            "commentRange": [
                1558,
                1927
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "Problems",
                "text": "",
                "commentRange": [
                    1558,
                    1927
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "Problems.Idea"
        },
        "Problems.Problem": {
            "annotation": "class",
            "name": "Problem",
            "text": "",
            "commentRange": [
                1558,
                1927
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "Problems",
                "text": "",
                "commentRange": [
                    1558,
                    1927
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "Problems.Problem"
        },
        "life.Living": {
            "annotation": "class",
            "name": "Living",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "Thing",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                1558,
                1927
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "life",
                "text": "",
                "commentRange": [
                    1558,
                    1927
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "life.Living",
            "methods": {
                "breath": {
                    "annotation": "method",
                    "name": "breath",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{Number}",
                            "name": "size",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        1558,
                        1927
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "life.Animal": {
            "annotation": "class",
            "name": "Animal",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "Living",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                1558,
                1927
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "life",
                "text": "",
                "commentRange": [
                    1558,
                    1927
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "life.Animal",
            "methods": {
                "eat": {
                    "annotation": "method",
                    "name": "eat",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{Array<Food>}",
                            "name": "food",
                            "text": "",
                            "theRestString": "@return {Array<Energy>}"
                        },
                        {
                            "annotation": "return",
                            "type": "{Array<Energy>}",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        1558,
                        1927
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "life.Person": {
            "annotation": "class",
            "name": "Person",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "Animal",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                1558,
                1927
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "life",
                "text": "",
                "commentRange": [
                    1558,
                    1927
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "life.Person",
            "methods": {
                "walk": {
                    "annotation": "method",
                    "name": "walk",
                    "text": "",
                    "children": [
                        {
                            "annotation": "return",
                            "type": "{Action}",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        1558,
                        1927
                    ],
                    "fileName": "ALL.js"
                },
                "crossStreet": {
                    "annotation": "method",
                    "name": "crossStreet",
                    "text": "This try to be a markdown [text](http://google.com)\n\nAnother paragraph \n\n\tvar someMarkup = {\n\t\ta: 1\n\t,\tn: 2\n\t,\tg: function (e)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t};\n\nand some final text with a list\n\n1. First ordered list item\n2. Another item\n  * Unordered sub-list.\n1. Actual numbers don't matter, just that it's a number\n  1. Ordered sub-list\n  2. hello\n4. And another item.",
                    "commentRange": [
                        1928,
                        2316
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "problem1.TerranObject": {
            "annotation": "class",
            "name": "TerranObject",
            "text": "",
            "commentRange": [
                2319,
                2673
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "problem1",
                "text": "This is a description of planet earth city from the point of view of an alien observing us from a space ship.",
                "commentRange": [
                    2319,
                    2673
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "problem1.TerranObject"
        },
        "problem1.Person": {
            "annotation": "class",
            "name": "Person",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "TerranObject",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                2319,
                2673
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "problem1",
                "text": "This is a description of planet earth city from the point of view of an alien observing us from a space ship.",
                "commentRange": [
                    2319,
                    2673
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "problem1.Person"
        },
        "problem1.List": {
            "annotation": "class",
            "name": "List",
            "text": "This is just a semantic alias for javascript Array.",
            "children": [
                {
                    "annotation": "extends",
                    "name": "Array",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                2319,
                2673
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "problem1",
                "text": "This is a description of planet earth city from the point of view of an alien observing us from a space ship.",
                "commentRange": [
                    2319,
                    2673
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "problem1.List"
        },
        "problem1.Map": {
            "annotation": "class",
            "name": "Map",
            "text": "This is just a semantic alias for javascript Object.",
            "children": [
                {
                    "annotation": "extends",
                    "name": "Object",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                2319,
                2673
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "problem1",
                "text": "This is a description of planet earth city from the point of view of an alien observing us from a space ship.",
                "commentRange": [
                    2319,
                    2673
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "problem1.Map"
        },
        "problem1.Building": {
            "annotation": "class",
            "name": "Building",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "TerranObject",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                2675,
                2717
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "problem1",
                "text": "This is a description of planet earth city from the point of view of an alien observing us from a space ship.",
                "commentRange": [
                    2319,
                    2673
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "problem1.Building"
        },
        "problem1.Hospital": {
            "annotation": "class",
            "name": "Hospital",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "Building",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                2719,
                3278
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "problem1",
                "text": "This is a description of planet earth city from the point of view of an alien observing us from a space ship.",
                "commentRange": [
                    2319,
                    2673
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "problem1.Hospital",
            "constructors": [
                {
                    "annotation": "constructor",
                    "name": "n",
                    "text": "Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{Number}",
                            "name": "availableBeds",
                            "text": "Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        2719,
                        3278
                    ],
                    "fileName": "ALL.js",
                    "params": [
                        {
                            "annotation": "param",
                            "type": "{Number}",
                            "name": "availableBeds",
                            "text": "Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...",
                            "theRestString": ""
                        }
                    ],
                    "throws": []
                }
            ],
            "methods": {
                "getActiveDoctors": {
                    "annotation": "method",
                    "name": "getActiveDoctors",
                    "text": "",
                    "children": [
                        {
                            "annotation": "returns",
                            "type": "{List<Doctor>}",
                            "name": "the",
                            "text": "currently active doctors in this hospital",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        2719,
                        3278
                    ],
                    "fileName": "ALL.js"
                }
            },
            "properties": {
                "todayIngresedPatients": {
                    "annotation": "property",
                    "type": "{Array<Person>}",
                    "name": "todayIngresedPatients",
                    "text": "all the patiens that entered this hospital today",
                    "commentRange": [
                        2719,
                        3278
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "problem1.Doctor": {
            "annotation": "class",
            "name": "Doctor",
            "text": "",
            "children": [
                {
                    "annotation": "extend",
                    "name": "Person",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                2719,
                3278
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "problem1",
                "text": "This is a description of planet earth city from the point of view of an alien observing us from a space ship.",
                "commentRange": [
                    2319,
                    2673
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "problem1.Doctor",
            "properties": {
                "skills": {
                    "annotation": "property",
                    "type": "{Map<String,MedicalTopic>}",
                    "name": "skills",
                    "text": "",
                    "commentRange": [
                        2719,
                        3278
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "problem1.MedicalTopic": {
            "annotation": "class",
            "name": "MedicalTopic",
            "text": "Lorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum",
            "commentRange": [
                3280,
                4360
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "problem1",
                "text": "This is a description of planet earth city from the point of view of an alien observing us from a space ship.",
                "commentRange": [
                    2319,
                    2673
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "problem1.MedicalTopic",
            "methods": {
                "beUsed": {
                    "annotation": "method",
                    "name": "beUsed",
                    "text": "Lorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{Number}",
                            "name": "amount",
                            "text": "Excepteur sint occaecat *cupidatat*",
                            "theRestString": "@return {Array<MedicalTopic>}"
                        },
                        {
                            "annotation": "return",
                            "type": "{Array<MedicalTopic>}",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        3280,
                        4360
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "shortjsdoc.AbstractView": {
            "annotation": "class",
            "name": "AbstractView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "BackboneView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                18039,
                18194
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "this file add methods to Abstract Application for dealing with types and html markup.",
                "commentRange": [
                    18039,
                    18194
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.AbstractView",
            "methods": {
                "printTag": {
                    "annotation": "method",
                    "name": "printTag",
                    "text": "",
                    "commentRange": [
                        18233,
                        18251
                    ],
                    "fileName": "ALL.js"
                },
                "simpleName": {
                    "annotation": "method",
                    "name": "simpleName",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "name",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        18498,
                        18538
                    ],
                    "fileName": "ALL.js"
                },
                "makeLink": {
                    "annotation": "method",
                    "name": "makeLink",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{boolean}",
                            "name": "htmlAnchors",
                            "text": "will output anchor elements html",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        18626,
                        18706
                    ],
                    "fileName": "ALL.js"
                },
                "printType": {
                    "annotation": "method",
                    "name": "printType",
                    "text": "prints a type as html support generic@param {Object}context",
                    "children": [
                        {
                            "annotation": "return",
                            "type": "{String}",
                            "name": "the",
                            "text": "type html",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        19975,
                        20086
                    ],
                    "fileName": "ALL.js"
                },
                "printTypeAsString": {
                    "annotation": "method",
                    "name": "printTypeAsString",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{Array<Type>|Type}",
                            "name": "type",
                            "text": "",
                            "theRestString": "@return {String} the type html"
                        },
                        {
                            "annotation": "return",
                            "type": "{String}",
                            "name": "the",
                            "text": "type html",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        21709,
                        21798
                    ],
                    "fileName": "ALL.js"
                },
                "getTextHtml": {
                    "annotation": "method",
                    "name": "getTextHtml",
                    "text": "depends on lib/marked/",
                    "commentRange": [
                        22117,
                        22161
                    ],
                    "fileName": "ALL.js"
                },
                "printMethod": {
                    "annotation": "method",
                    "name": "printMethod",
                    "text": "",
                    "commentRange": [
                        22654,
                        22675
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "shortjsdoc.Application": {
            "annotation": "class",
            "name": "Application",
            "text": "",
            "commentRange": [
                5129,
                5512
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "children": [
                    {
                        "annotation": "author",
                        "text": ": sgurin",
                        "theRestString": ""
                    }
                ],
                "commentRange": [
                    5129,
                    5512
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.Application",
            "constructors": [
                {
                    "annotation": "constructor",
                    "name": "n",
                    "text": "Application",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "data",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        5129,
                        5512
                    ],
                    "fileName": "ALL.js",
                    "params": [
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "data",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "throws": []
                }
            ],
            "methods": {
                "start": {
                    "annotation": "method",
                    "name": "start",
                    "text": "an application loading it with given data.",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param data the output of passing jsindentator JsDocMaker."
                        },
                        {
                            "annotation": "param",
                            "name": "data",
                            "text": "the output of passing jsindentator JsDocMaker.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        7071,
                        7199
                    ],
                    "fileName": "ALL.js"
                },
                "showView": {
                    "annotation": "method",
                    "name": "showView",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{AbstractView}",
                            "name": "view",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        6457,
                        6502
                    ],
                    "fileName": "ALL.js"
                },
                "refreshWithNewModel": {
                    "annotation": "method",
                    "name": "refreshWithNewModel",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "data",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        6723,
                        6772
                    ],
                    "fileName": "ALL.js"
                },
                "showErrorView": {
                    "annotation": "method",
                    "name": "showErrorView",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "s",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        6932,
                        6973
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "shortjsdoc.ApplicationView": {
            "annotation": "class",
            "name": "ApplicationView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "AbstractView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                7305,
                7372
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    7305,
                    7372
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.ApplicationView"
        },
        "shortjsdoc.ClassView": {
            "annotation": "class",
            "name": "ClassView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "AbstractView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                7920,
                7981
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    7920,
                    7981
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.ClassView"
        },
        "shortjsdoc.HeaderView": {
            "annotation": "class",
            "name": "HeaderView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "AbstractView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                9104,
                9166
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    9104,
                    9166
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.HeaderView"
        },
        "shortjsdoc.IndexView": {
            "annotation": "class",
            "name": "IndexView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "AbstractView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                11054,
                11115
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    11054,
                    11115
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.IndexView"
        },
        "shortjsdoc.JsDocRouter": {
            "annotation": "class",
            "name": "JsDocRouter",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "BackboneRouter",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                11202,
                11267
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    11202,
                    11267
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.JsDocRouter",
            "methods": {
                "showView": {
                    "annotation": "method",
                    "name": "showView",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{AbstractView}",
                            "name": "view",
                            "text": "",
                            "theRestString": "@param {String} resourceName"
                        },
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "resourceName",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        11761,
                        11834
                    ],
                    "fileName": "ALL.js"
                },
                "showModule": {
                    "annotation": "method",
                    "name": "showModule",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "moduleName",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        12097,
                        12145
                    ],
                    "fileName": "ALL.js"
                },
                "showClass": {
                    "annotation": "method",
                    "name": "showClass",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "className",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        12541,
                        12587
                    ],
                    "fileName": "ALL.js"
                },
                "showMethod": {
                    "annotation": "method",
                    "name": "showMethod",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "method",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        12800,
                        12844
                    ],
                    "fileName": "ALL.js"
                },
                "showProperty": {
                    "annotation": "method",
                    "name": "showProperty",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "property",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        12963,
                        13011
                    ],
                    "fileName": "ALL.js"
                },
                "showEvent": {
                    "annotation": "method",
                    "name": "showEvent",
                    "text": "",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "event",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        13138,
                        13180
                    ],
                    "fileName": "ALL.js"
                },
                "showModules": {
                    "annotation": "method",
                    "name": "showModules",
                    "text": "",
                    "commentRange": [
                        13304,
                        13325
                    ],
                    "fileName": "ALL.js"
                },
                "showClasses": {
                    "annotation": "method",
                    "name": "showClasses",
                    "text": "",
                    "commentRange": [
                        13462,
                        13483
                    ],
                    "fileName": "ALL.js"
                },
                "showIndex": {
                    "annotation": "method",
                    "name": "showIndex",
                    "text": "",
                    "commentRange": [
                        13620,
                        13639
                    ],
                    "fileName": "ALL.js"
                },
                "showParse": {
                    "annotation": "method",
                    "name": "showParse",
                    "text": "",
                    "commentRange": [
                        13755,
                        13774
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "shortjsdoc.MethodView": {
            "annotation": "class",
            "name": "MethodView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "AbstractView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                13895,
                13957
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    13895,
                    13957
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.MethodView"
        },
        "shortjsdoc.ModuleView": {
            "annotation": "class",
            "name": "ModuleView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "AbstractView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                14694,
                14756
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    14694,
                    14756
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.ModuleView"
        },
        "shortjsdoc.ParseView": {
            "annotation": "class",
            "name": "ParseView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "AbstractView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                15185,
                15246
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    15185,
                    15246
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.ParseView"
        },
        "shortjsdoc.PropertyView": {
            "annotation": "class",
            "name": "PropertyView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "AbstractView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                15731,
                15795
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    15731,
                    15795
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.PropertyView"
        },
        "shortjsdoc.SourcesView": {
            "annotation": "class",
            "name": "SourcesView",
            "text": "",
            "children": [
                {
                    "annotation": "extends",
                    "name": "AbstractView",
                    "text": "",
                    "theRestString": ""
                }
            ],
            "commentRange": [
                16416,
                16479
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "shortjsdoc",
                "text": "",
                "commentRange": [
                    16416,
                    16479
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "shortjsdoc.SourcesView"
        },
        "Backbone.BackboneView": {
            "annotation": "class",
            "name": "BackboneView",
            "text": "",
            "commentRange": [
                23656,
                23890
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "Backbone",
                "text": "",
                "commentRange": [
                    23656,
                    23890
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "Backbone.BackboneView",
            "properties": {
                "$el": {
                    "annotation": "property",
                    "type": "{jQuery}",
                    "name": "$el",
                    "text": "",
                    "commentRange": [
                        23656,
                        23890
                    ],
                    "fileName": "ALL.js"
                },
                "$": {
                    "annotation": "property",
                    "type": "{jQuery}",
                    "name": "$",
                    "text": "",
                    "commentRange": [
                        23656,
                        23890
                    ],
                    "fileName": "ALL.js"
                },
                "el": {
                    "annotation": "property",
                    "type": "{HTMLElement}",
                    "name": "el",
                    "text": "",
                    "commentRange": [
                        23656,
                        23890
                    ],
                    "fileName": "ALL.js"
                }
            },
            "methods": {
                "render": {
                    "annotation": "method",
                    "name": "render",
                    "text": "",
                    "commentRange": [
                        23656,
                        23890
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "Backbone.BackboneRouter": {
            "annotation": "class",
            "name": "BackboneRouter",
            "text": "",
            "commentRange": [
                23656,
                23890
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "Backbone",
                "text": "",
                "commentRange": [
                    23656,
                    23890
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "Backbone.BackboneRouter"
        },
        "Backbone.BackboneModel": {
            "annotation": "class",
            "name": "BackboneModel",
            "text": "",
            "commentRange": [
                23656,
                23890
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "Backbone",
                "text": "",
                "commentRange": [
                    23656,
                    23890
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "Backbone.BackboneModel"
        },
        "jQuery.jQuery": {
            "annotation": "class",
            "name": "jQuery",
            "text": "a jQuery Object",
            "commentRange": [
                23656,
                23890
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "jQuery",
                "text": "",
                "commentRange": [
                    23656,
                    23890
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "jQuery.jQuery"
        },
        "javascript.Boolean": {
            "annotation": "class",
            "name": "Boolean",
            "text": "#Summary\nThe Boolean object is an object wrapper for a boolean value.\n\n#Constructor\n\tnew Boolean(value)\n\n#Description\nThe value passed as the first parameter is converted to a boolean value, if necessary. If value is omitted or is 0, -0, null, false, NaN, undefined, or the empty string (\"\"), the object has an initial value of false. All other values, including any object or the string \"false\", create an object with an initial value of true.\n\nDo not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.\n\nAny object whose value is not undefined or null, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement. For example, the condition in the following if statement evaluates to true:\n\n\tx = new Boolean(false);\n\tif (x) {\n\t  // . . . this code is executed\n\t}\n\tThis behavior does not apply to Boolean primitives. For example, the condition in the following if statement evaluates to false:\n\n\tx = false;\n\tif (x) {\n\t  // . . . this code is not executed\n\t}\nDo not use a Boolean object to convert a non-boolean value to a boolean value. Instead, use Boolean as a function to perform this task:\n\n\tx = Boolean(expression);     // preferred\n\tx = new Boolean(expression); // don't use\n\tIf you specify any object, including a Boolean object whose value is false, as the initial value of a Boolean object, the new Boolean object has a value of true.\n\n\tmyFalse = new Boolean(false);   // initial value of false\n\tg = new Boolean(myFalse);       // initial value of true\n\tmyString = new String(\"Hello\"); // string object\n\ts = new Boolean(myString);      // initial value of true\n\tDo not use a Boolean object in place of a Boolean primitive.\n\n#Properties\nFor properties available on Boolean instances, see Properties of Boolean instances.\n\nBoolean.length\nLength property whose value is 1.\nBoolean.prototype\nRepresents the prototype for the Boolean constructor.\n#Properties inherited from Function:\narity, caller, constructor, length, name\n##Methods\nFor methods available on Boolean instances, see Methods of Boolean instances.\n\nThe global Boolean object contains no methods of its own, however, it does inherit some methods through the prototype chain:\n\n#Methods inherited from Function:\napply, call, toSource, toString\n\n#Boolean instances\nAll Boolean instances inherit from Boolean.prototype. As with all constructors, the prototype object dictates instances' inherited properties and methods.\n\n#Properties\n\nBoolean.prototype.constructor\nReturns the function that created an instance's prototype. This is the Boolean function by default.\nProperties inherited from Object:\n__parent__, __proto__\n#Methods\n\nBoolean.prototype.toSource() \nReturns a string containing the source of the Boolean object; you can use this string to create an equivalent object. Overrides the Object.prototype.toSource() method.\nBoolean.prototype.toString()\nReturns a string of either \"true\" or \"false\" depending upon the value of the object. Overrides the Object.prototype.toString() method.\nBoolean.prototype.valueOf()\nReturns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.\n\n\n#Examples\nCreating Boolean objects with an initial value of false\n\n\tvar bNoParam = new Boolean();\n\tvar bZero = new Boolean(0);\n\tvar bNull = new Boolean(null);\n\tvar bEmptyString = new Boolean(\"\");\n\tvar bfalse = new Boolean(false);\n\tCreating Boolean objects with an initial value of true\n\n\tvar btrue = new Boolean(true);\n\tvar btrueString = new Boolean(\"true\");\n\tvar bfalseString = new Boolean(\"false\");\n\tvar bSuLin = new Boolean(\"Su Lin\");",
            "commentRange": [
                23892,
                27560
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "javascript",
                "text": "",
                "commentRange": [
                    23892,
                    27560
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "javascript.Boolean",
            "methods": {
                "valueOf": {
                    "annotation": "method",
                    "name": "valueOf",
                    "text": "#Summary\nThe valueOf() method returns the primitive value of a Boolean object.\n\n#Syntax\n\tbool.valueOf()\n\n#Description\nThe valueOf method of Boolean returns the primitive value of a Boolean object or literal Boolean as a Boolean data type.\n\nThis method is usually called internally by JavaScript and not explicitly in code.\n\n#Examples\n##Example: Using valueOf\n\n\tx = new Boolean();\n\tmyVar = x.valueOf()      // assigns false to myVar",
                    "commentRange": [
                        27563,
                        28016
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "javascript.Error": {
            "annotation": "class",
            "name": "Error",
            "text": "#Summary\nThe Error constructor creates an error object. Instances of Error objects are thrown when runtime errors occur. The Error object can also be used as a base objects for user-defined exceptions. See below for standard built-in error types.\n\n#Syntax\n\tnew Error([message[, fileName[,lineNumber]]])\n#Description\nRuntime errors result in new Error objects being created and thrown.\n\nThis page documents the use of the Error object itself and its use as a constructor function. For a list of properties and methods inherited by Error instances, see Error.prototype.\n\n#Error types\n\nBesides the generic Error constructor, there are six other core error constructors in JavaScript. For client-side exceptions, see Exception Handling Statements.\n\n\tEvalError\n\tCreates an instance representing an error that occurs regarding the global function eval().\n\tInternalError \n\tCreates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. \"too much recursion\".\n\tRangeError\n\tCreates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.\n\tReferenceError\n\tCreates an instance representing an error that occurs when de-referencing an invalid reference.\n\tSyntaxError\n\tCreates an instance representing a syntax error that occurs while parsing code in eval().\n\tTypeError\n\tCreates an instance representing an error that occurs when a variable or parameter is not of a valid type.\n\tURIError\n\tCreates an instance representing an error that occurs when encodeURI() or decodeURl() are passed invalid parameters.\n\n#Properties\nError.prototype\nAllows the addition of properties to Error instances.\n#Methods\nThe global Error object contains no methods of its own, however, it does inherit some methods through the prototype chain.\n\n#Error instances\nAll Error instances and instances of non-generic errors inherit from Error.prototype. As with all constructor functions, you can use the prototype of the constructor to add properties or methods to all instances created with that constructor.\n\n#Properties\n\n##Standard properties\n\nError.prototype.constructor\nSpecifies the function that created an instance's prototype.\n\tError.prototype.message\n\tError message.\n\tError.prototype.name\n\tError name.\n\n\n#Vendor-specific extensions\n\n##Non-standard\nThis feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.\n##Microsoft\n\n\tError.prototype.description\n\tError description. Similar to message.\n\tError.prototype.number\n\tError number.\n##Mozilla\n\n\tError.prototype.fileName\n\tPath to file that raised this error.\n\tError.prototype.lineNumber\n\tLine number in file that raised this error.\n\tError.prototype.columnNumber\n\tColumn number in line that raised this error.\n\tError.prototype.stack\n\tStack trace.\n\n#Examples\n##Example: Throwing a generic error\n\nUsually you create an Error object with the intention of raising it using the throw keyword. You can handle the error using the try...catch construct:\n\n\ttry {\n\t  throw new Error(\"Whoops!\");\n\t} catch (e) {\n\t  alert(e.name + \": \" + e.message);\n\t}\n\tExample: Handling a specific error\n\n\tYou can choose to handle only specific error types by testing the error type with the error's constructor property or, if you're writing for modern JavaScript engines, instanceof keyword:\n\n\ttry {\n\t  foo.bar();\n\t} catch (e) {\n\t  if (e instanceof EvalError) {\n\t    alert(e.name + \": \" + e.message);\n\t  } else if (e instanceof RangeError) {\n\t    alert(e.name + \": \" + e.message);\n\t  }\n\t  // ... etc\n\t}\n##Custom Error Types\n\nYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. The common way to do this is demonstrated below.\n\nNote that the thrown MyError will report incorrect lineNumber and fileName at least in Firefox.\nSee also the \"What's a good way to extend Error in JavaScript?\" discussion on Stackoverflow.\n\n\t// Create a new object, that prototypally inherits from the Error constructor.\n\tfunction MyError(message) {\n\t  this.name = \"MyError\";\n\t  this.message = message || \"Default Message\";\n\t}\n\tMyError.prototype = new Error();\n\tMyError.prototype.constructor = MyError;\n\n\ttry {\n\t  throw new MyError();\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"Default Message\"\n\t}\n\n\ttry {\n\t  throw new MyError(\"custom message\");\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"custom message\"\n\t}",
            "commentRange": [
                28018,
                32752
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "javascript",
                "text": "",
                "commentRange": [
                    28018,
                    32752
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "javascript.Error",
            "constructors": [
                {
                    "annotation": "constructor",
                    "name": "n",
                    "text": "Boolean",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "message",
                            "text": "Human-readable description of the error",
                            "theRestString": "@param {String} fileName The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.\n@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."
                        },
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "fileName",
                            "text": "The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.",
                            "theRestString": "@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."
                        },
                        {
                            "annotation": "param",
                            "type": "{Number}",
                            "name": "lineNumber",
                            "text": "The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        32754,
                        33194
                    ],
                    "fileName": "ALL.js",
                    "params": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "message",
                            "text": "Human-readable description of the error",
                            "theRestString": "@param {String} fileName The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.\n@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."
                        },
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "fileName",
                            "text": "The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.",
                            "theRestString": "@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."
                        },
                        {
                            "annotation": "param",
                            "type": "{Number}",
                            "name": "lineNumber",
                            "text": "The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation.",
                            "theRestString": ""
                        }
                    ],
                    "throws": []
                }
            ]
        },
        "javascript.Function": {
            "annotation": "class",
            "name": "Function",
            "text": "#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.",
            "commentRange": [
                33198,
                33427
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "javascript",
                "text": "",
                "commentRange": [
                    33198,
                    33427
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "javascript.Function",
            "properties": {
                "length": {
                    "annotation": "property",
                    "type": "{Number}",
                    "name": "length",
                    "text": "#Summary\nThe length property specifies the number of arguments expected by the function.\n\n#Description\nlength is a property of a function object, and indicates how many arguments the function expects, i.e. the number of formal parameters. This number does not include the rest parameter. By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.\n\nData property of the Function constructor\n\nThe Function constructor is itself a Function object. It's length data property has a value of 1. The property attributes are: Writable: false, Enumerable: false, Configurable: true.\n\nProperty of the Function prototype object\n\nThe length property of the Function prototype object has a value of 0.\n\n#Examples\n\tconsole.log ( Function.length ); //1\n\n\tconsole.log( (function ()        {}).length ); //0\n\tconsole.log( (function (a)       {}).length ); //1\n\tconsole.log( (function (a, b)    {}).length ); //2 etc. \n\tconsole.log( (function (...args) {}).length ); //0, rest parameter is no",
                    "commentRange": [
                        33430,
                        34502
                    ],
                    "fileName": "ALL.js"
                },
                "prototype": {
                    "annotation": "property",
                    "type": "{FunctionPrototype}",
                    "name": "prototype",
                    "text": "#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.",
                    "commentRange": [
                        34505,
                        34737
                    ],
                    "fileName": "ALL.js"
                }
            },
            "methods": {
                "apply": {
                    "annotation": "method",
                    "name": "apply",
                    "text": "The apply() method calls a function with a given this value and arguments provided as an array (or an array-like object).\n\nNote: While the syntax of this function is almost identical to that of call(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.apply(thisArg, [argsArray])\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object. With apply, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\napply is very similar to call(), except for the type of arguments it supports. You can use an arguments array instead of a named set of parameters. With apply, you can use an array literal, for example, fun.apply(this, ['eat', 'bananas']), or an Array object, for example, fun.apply(this, new Array('eat', 'bananas')).\n\nYou can also use arguments for the argsArray parameter. arguments is a local variable of a function. It can be used for all unspecified arguments of the called object. Thus, you do not have to know the arguments of the called object when you use the apply method. You can use arguments to pass all the arguments to the called object. The called object is then responsible for handling the arguments.\n\nSince ECMAScript 5th Edition you can also use any kind of object which is array-like, so in practice this means it's going to have a property length and integer properties in the range [0...length). As an example you can now use a NodeList or a own custom object like {'length': 2, '0': 'eat', '1': 'bananas'}.\n\nNote: Most browsers, including Chrome 14 and Internet Explorer 9, still do not accept array-like objects and will throw an exception.\n#Examples\nUsing apply to chain constructors\n\nYou can use apply to chain constructors for an object, similar to Java. In the following example we will create a global Function method called construct, which will make you able to use an array-like object with a constructor instead of an arguments list.\n\n\tFunction.prototype.construct = function (aArgs) {\n\t    var fConstructor = this, fNewConstr = function () { fConstructor.apply(this, aArgs); };\n\t    fNewConstr.prototype = fConstructor.prototype;\n\t    return new fNewConstr();\n\t};\n\nExample usage:\n\n\tfunction MyConstructor () {\n\t    for (var nProp = 0; nProp < arguments.length; nProp++) {\n\t        this[\"property\" + nProp] = arguments[nProp];\n\t    }\n\t}\n\n\tvar myArray = [4, \"Hello world!\", false];\n\tvar myInstance = MyConstructor.construct(myArray);\n\n\talert(myInstance.property1); // alerts \"Hello world!\"\n\talert(myInstance instanceof MyConstructor); // alerts \"true\"\n\talert(myInstance.constructor); // alerts \"MyConstructor\"\n\nNote: This non-native Function.construct method will not work with some native constructors (like Date, for example). In these cases you have to use the Function.bind method (for example, imagine to have an array like the following, to be used with Date constructor: [2012, 11, 4]; in this case you have to write something like: new (Function.prototype.bind.apply(Date, [null].concat([2012, 11, 4])))() â€“ anyhow this is not the best way to do things and probably should not be used in any production environment).\nUsing apply and built-in functions\n\nClever usage of apply allows you to use built-ins functions for some tasks that otherwise probably would have been written by looping over the array values. As an example here we are going to use Math.max/Math.min to find out the maximum/minimum value in an array.\n\n\t//min/max number in an array \n\tvar numbers = [5, 6, 2, 3, 7];\n\n\t//using Math.min/Math.max apply \n\tvar max = Math.max.apply(null, numbers); // This about equal to Math.max(numbers[0], ...) or Math.max(5, 6, ..) \n\tvar min = Math.min.apply(null, numbers);\n\n\t/ vs. simple loop based algorithm \n\tmax = -Infinity, min = +Infinity;\n\n\tfor (var i = 0; i < numbers.length; i++) {\n\t  if (numbers[i] > max)\n\t    max = numbers[i];\n\t  if (numbers[i] < min) \n\t    min = numbers[i];\n\t}\n\nBut beware: in using apply this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (think more than tens of thousands of arguments) vary across engines (JavaScriptCore has hard-coded argument limit of 65536), because the limit (indeed even the nature of any excessively-large-stack behavior) is unspecified. Some engines will throw an exception. More perniciously, others will arbitrarily limit the number of arguments actually passed to the applied function. (To illustrate this latter case: if such an engine had a limit of four arguments [actual limits are of course significantly higher], it would be as if the arguments 5, 6, 2, 3 had been passed to apply in the examples above, rather than the full array.) If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:\n\n\tfunction minOfArray(arr) {\n\t  var min = Infinity;\n\t  var QUANTUM = 32768;\n\n\t  for (var i = 0, len = arr.length; i < len; i += QUANTUM) {\n\t    var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len)));\n\t    min = Math.min(submin, min);\n\t  }\n\n\t  return min;\n\t}\n\n\tvar min = minOfArray([5, 6, 2, 3, 7]);\nUsing apply in \"monkey-patching\"\n\nApply can be the best way to monkey-patch a builtin function of Firefox, or JS libraries. Given someobject.foo function, you can modify the function in a somewhat hacky way, like so:\n\n\tvar originalfoo = someobject.foo;\n\tsomeobject.foo = function() {\n\t  //Do stuff before calling function\n\t  console.log(arguments);\n\t  //Call the function as it would have been called normally:\n\t  originalfoo.apply(this,arguments);\n\t  //Run stuff after, here.\n\t}\n\nThis method is especially handy where you want to debug events, or interface with something that has no API like the various .on([event]... events, such as those usable on the Devtools Inspector).",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "thisArg",
                            "text": "The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.",
                            "theRestString": "@param {Array} argsArray An array-like object, specifying the arguments with which fun should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.\n\n@returns the result of evaluating this function with given context and parameters"
                        },
                        {
                            "annotation": "param",
                            "type": "{Array}",
                            "name": "argsArray",
                            "text": "An array-like object, specifying the arguments with which fun should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.",
                            "theRestString": "@returns the result of evaluating this function with given context and parameters"
                        },
                        {
                            "annotation": "returns",
                            "name": "the",
                            "text": "result of evaluating this function with given context and parameters",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        34741,
                        41471
                    ],
                    "fileName": "ALL.js"
                },
                "bind": {
                    "annotation": "method",
                    "name": "bind",
                    "text": "#Summary\nThe bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.\n\n#Syntax\n\tfun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nThe bind() function creates a new function (a bound function) with the same function body (internal call property in ECMAScript 5 terms) as the function it is being called on (the bound function's target function) with the this value bound to the first argument of bind(), which cannot be overridden. bind() also accepts leading default arguments to provide to the target function when the bound function is called. A bound function may also be constructed using the new operator: doing so acts as though the target function had instead been constructed. The provided this value is ignored, while prepended arguments are provided to the emulated function.\n\n#Examples\nCreating a bound function\n\nThe simplest use of bind() is to make a function that, no matter how it is called, is called with a particular this value. A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g. by using that method in callback-based code). Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:\n\n\tthis.x = 9; \n\tvar module = {\n\t  x: 81,\n\t  getX: function() { return this.x; }\n\t};\n\n\tmodule.getX(); // 81\n\n\tvar getX = module.getX;\n\tgetX(); // 9, because in this case, \"this\" refers to the global object\n\n\t// create a new function with 'this' bound to module\n\tvar boundGetX = getX.bind(module);\n\tboundGetX(); // 81\n\n##Partial Functions\n\nThe next simplest use of bind() is to make a function with pre-specified initial arguments. These arguments (if any) follow the provided this value and are then inserted at the start of the arguments passed to the target function, followed by the arguments passed to the bound function, whenever the bound function is called.\n\n\tfunction list() {\n\t  return Array.prototype.slice.call(arguments);\n\t}\n\n\tvar list1 = list(1, 2, 3); // [1, 2, 3]\n\n\t//  Create a function with a preset leading argument\n\tvar leadingThirtysevenList = list.bind(undefined, 37);\n\n\tvar list2 = leadingThirtysevenList(); // [37]\n\tvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n##With setTimeout\n\nBy default within window.setTimeout(), the this keyword will be set to the window (or global) object. When working with class methods that require this to refer to class instances, you may explicitly bind this to the callback function, in order to maintain the instance.\n\n\tfunction LateBloomer() {\n\t  this.petalCount = Math.ceil( Math.random() * 12 ) + 1;\n\t}\n\n\t// declare bloom after a delay of 1 second\n\tLateBloomer.prototype.bloom = function() {\n\t  window.setTimeout( this.declare.bind( this ), 1000 );\n\t};\n\n\tLateBloomer.prototype.declare = function() {\n\t  console.log('I am a beautiful flower with ' + \n\t    this.petalCount + ' petals!');\n\t};\n\n##Bound functions used as constructors\n\nWarning: This section demonstrates JavaScript capabilities and documents some edge cases of the bind() method. The methods shown below are not the best way to do things and probably should not be used in any production environment.\nBound functions are automatically suitable for use with the new operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided this is ignored. However, provided arguments are still prepended to the constructor call:\n\n\tfunction Point(x, y) {\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\n\tPoint.prototype.toString = function() { \n\t  return this.x + \",\" + this.y; \n\t};\n\n\tvar p = new Point(1, 2);\n\tp.toString(); // \"1,2\"\n\n\n\tvar emptyObj = {};\n\tvar YAxisPoint = Point.bind(emptyObj, 0);\n\t// not supported in the polyfill below, works fine with native bind:\n\tvar YAxisPoint = Point.bind(null,0 );\n\n\tvar axisPoint = new YAxisPoint(5);\n\taxisPoint.toString(); //  \"0,5\"\n\n\taxisPoint instanceof Point; // true\n\taxisPoint instanceof YAxisPoint; // true\n\tnew Point(17, 42) instanceof YAxisPoint; // false\nNote that you need do nothing special to create a bound function for use with new. The corollary is that you need do nothing special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using new.\n\n\t// Example can be run directly in your JavaScript console\n\t// ...continuing from above\n\n\t// Can still be called as a normal function \n\t// (although usually this is undesired)\n\tYAxisPoint(13);\n\n\temptyObj.x + \",\" + emptyObj.y;\n\t// >  \"0,13\"\nIf you wish to support use of a bound function only using new, or only by calling it, the target function must enforce that restriction.\n\n##Creating shortcuts\n\nbind() is also helpful in cases where you want to create a shortcut to a function which requires a specific this value.\n\nTake Array.prototype.slice, for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:\n\n\tvar slice = Array.prototype.slice;\n\n\t// ...\n\n\tslice.call(arguments);\n\tWith bind(), this can be simplified. In the following piece of code, slice is a bound function to the call() function of Function.prototype, with the this value set to the slice() function of Array.prototype. This means that additional call() calls can be eliminated:\n\n\t// same as \"slice\" in the previous example\n\tvar unboundSlice = Array.prototype.slice;\n\tvar slice = Function.prototype.call.bind(unboundSlice);\n\n\t// ...\n\n\tslice(arguments);\n#Polyfill\nThe bind function is a recent addition to ECMA-262, 5th edition; as such it may not be present in all browsers. You can partially work around this by inserting the following code at the beginning of your scripts, allowing use of much of the functionality of bind() in implementations that do not natively support it.\n\n\tif (!Function.prototype.bind) {\n\t  Function.prototype.bind = function (oThis) {\n\t    if (typeof this !== \"function\") {\n\t      // closest thing possible to the ECMAScript 5\n\t      // internal IsCallable function\n\t      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\t    }\n\n\t    var aArgs = Array.prototype.slice.call(arguments, 1), \n\t        fToBind = this, \n\t        fNOP = function () {},\n\t        fBound = function () {\n\t          return fToBind.apply(this instanceof fNOP && oThis\n\t                 ? this\n\t                 : oThis,\n\t                 aArgs.concat(Array.prototype.slice.call(arguments)));\n\t        };\n\n\t    fNOP.prototype = this.prototype;\n\t    fBound.prototype = new fNOP();\n\n\t    return fBound;\n\t  };\n\t}\n\nSome of the many differences (there may well be others, as this list does not seriously attempt to be exhaustive) between this algorithm and the specified algorithm are:\n\nThe partial implementation relies Array.prototype.slice, Array.prototype.concat, Function.prototype.call and Function.prototype.apply, built-in methods to have their original values.\nThe partial implementation creates functions that do not have immutable \"poison pill\" caller and arguments properties that throw a TypeError upon get, set, or deletion. (This could be added if the implementation supports Object.defineProperty, or partially implemented [without throw-on-delete behavior] if the implementation supports the __defineGetter__ and __defineSetter__ extensions.)\nThe partial implementation creates functions that have a prototype property. (Proper bound functions have none.)\nThe partial implementation creates bound functions whose length property does not agree with that mandated by ECMA-262: it creates functions with length 0, while a full implementation, depending on the length of the target function and the number of pre-specified arguments, may return a non-zero length.\nIf you choose to use this partial implementation, you must not rely on those cases where behavior deviates from ECMA-262, 5th edition! With some care, however (and perhaps with additional modification to suit specific needs), this partial implementation may be a reasonable bridge to the time when bind() is widely implemented according to the specification.",
                    "children": [
                        {
                            "annotation": "param",
                            "name": "thisArg",
                            "text": "The value to be passed as the this parameter to the target function when the bound function is called. The value is ignored if the bound function is constructed using the new operator.",
                            "theRestString": "@param args Arguments to prepend to arguments provided to the bound function when invoking the target function."
                        },
                        {
                            "annotation": "param",
                            "name": "args",
                            "text": "Arguments to prepend to arguments provided to the bound function when invoking the target function.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        41479,
                        50163
                    ],
                    "fileName": "ALL.js"
                },
                "call": {
                    "annotation": "method",
                    "name": "call",
                    "text": "#Summary\nThe call() method calls a function with a given this value and arguments provided individually.\n\nNOTE: While the syntax of this function is almost identical to that of apply(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.call(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object.\n\nWith call, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\n#Examples\n##Using call to chain constructors for an object\n\nYou can use call to chain constructors for an object, similar to Java. In the following example, the constructor for the Product object is defined with two parameters, name and price. Two other functions Food and Toy invoke Product passing this and name and price. Product initializes the properties name and price, both specialized functions define the category.\n\n\tfunction Product(name, price) {\n\t  this.name = name;\n\t  this.price = price;\n\n\t  if (price < 0) {\n\t    throw RangeError('Cannot create product ' +\n\t                      this.name + ' with a negative price');\n\t  }\n\n\t  return this;\n\t}\n\n\tfunction Food(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'food';\n\t}\n\n\tFood.prototype = Object.create(Product.prototype);\n\n\tfunction Toy(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'toy';\n\t}\n\n\tToy.prototype = Object.create(Product.prototype);\n\n\tvar cheese = new Food('feta', 5);\n\tvar fun = new Toy('robot', 40);\n \n##Using call to invoke an anonymous function\n\nIn this purely constructed example, we create anonymous function and use call to invoke it on every object in an array. The main purpose of the anonymous function here is to add a print function to every object, which is able to print the right index of the object in the array. Passing the object as this value was not strictly necessary, but is done for explanatory purpose.\n\n\tvar animals = [\n\t  {species: 'Lion', name: 'King'},\n\t  {species: 'Whale', name: 'Fail'}\n\t];\n\n\tfor (var i = 0; i < animals.length; i++) {\n\t  (function (i) { \n\t    this.print = function () { \n\t      console.log('#' + i  + ' ' + this.species \n\t                  + ': ' + this.name); \n\t    } \n\t    this.print();\n\t  }).call(animals[i], i);\n\t}",
                    "children": [
                        {
                            "annotation": "param",
                            "name": "thisArg",
                            "text": "The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.",
                            "theRestString": "@param arg1,arg2,... Arguments for the object."
                        },
                        {
                            "annotation": "param",
                            "name": "arg1",
                            "text": ",arg2,... Arguments for the object.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        50170,
                        52939
                    ],
                    "fileName": "ALL.js"
                },
                "toString": {
                    "annotation": "method",
                    "name": "toString",
                    "text": "#Summary\nThe toString() method returns a string representing the source code of the function.\n\n#Syntax\n\tfunction.toString(indentation)\n#Description\nThe Function object overrides the toString method inherited from Object; it does not inherit Object.prototype.toString. For Function objects, the toString method returns a string representation of the object in the form of a function declaration. That is, toString decompiles the function, and the string returned includes the function keyword, the argument list, curly braces, and the source of the function body.\n\nJavaScript calls the toString method automatically when a Function is to be represented as a text value, e.g. when a function is concatenated with a string.",
                    "children": [
                        {
                            "annotation": "return",
                            "type": "{String}",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        52944,
                        53705
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "javascript.Object": {
            "annotation": "class",
            "name": "Object",
            "text": "Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
            "commentRange": [
                53707,
                53897
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "javascript",
                "text": "",
                "commentRange": [
                    53707,
                    53897
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "javascript.Object",
            "properties": {
                "prototype": {
                    "annotation": "property",
                    "type": "{ObjectPrototype}",
                    "name": "prototype",
                    "text": "",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        53707,
                        53897
                    ],
                    "fileName": "ALL.js"
                }
            },
            "methods": {
                "__defineGetter__": {
                    "annotation": "method",
                    "name": "__defineGetter__",
                    "text": "()  \nAssociates a function with a property that, when accessed, executes that function and returns its return value.",
                    "commentRange": [
                        53914,
                        54060
                    ],
                    "fileName": "ALL.js"
                },
                "hasOwnProperty": {
                    "annotation": "method",
                    "name": "hasOwnProperty",
                    "text": "#Summary\nThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n#Syntax\n\tobj.hasOwnProperty(prop)\n\n#Description\nEvery object descended from Object inherits the hasOwnProperty method. This method can be used to determine whether an object has the specified property as a direct property of that object; unlike the in operator, this method does not check down the object's prototype chain.\n\n#Examples\n##Example: Using hasOwnProperty to test for a property's existence\n\nThe following example determines whether the o object contains a property named prop:\n\n\to = new Object();\n\to.prop = 'exists';\n\n\tfunction changeO() {\n\t  o.newprop = o.prop;\n\t  delete o.prop;\n\t}\n\n\to.hasOwnProperty('prop');   // returns true\n\tchangeO();\n\to.hasOwnProperty('prop');   // returns false\n\tExample: Direct versus inherited properties\n\n\tThe following example differentiates between direct properties and properties inherited through the prototype chain:\n\n\to = new Object();\n\to.prop = 'exists';\n\to.hasOwnProperty('prop');             // returns true\n\to.hasOwnProperty('toString');         // returns false\n\to.hasOwnProperty('hasOwnProperty');   // returns false\n##Example: Iterating over the properties of an object\n\nThe following example shows how to iterate over the properties of an object without executing on inherit properties. Note that the for...in loop is already only iterating enumerable items, so one should not assume based on the lack of non-enumerable properties shown in the loop that hasOwnProperty itself is confined strictly to enumerable items (as with Object.getOwnPropertyNames()).\n\n\tvar buz = {\n\t  fog: 'stack'\n\t};\n\n\tfor (var name in buz) {\n\t  if (buz.hasOwnProperty(name)) {\n\t    alert('this is fog (' + name + ') for sure. Value: ' + buz[name]);\n\t  }\n\t  else {\n\t    alert(name); // toString or something else\n\t  }\n\t}\n##Example: hasOwnProperty as a property\n\nJavaScript does not protect the property name hasOwnProperty; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an external hasOwnProperty to get correct results:\n\n\tvar foo = {\n\t  hasOwnProperty: function() {\n\t    return false;\n\t  },\n\t  bar: 'Here be dragons'\n\t};\n\n\tfoo.hasOwnProperty('bar'); // always returns false\n\n\t// Use another Object's hasOwnProperty and call it with 'this' set to foo\n\t({}).hasOwnProperty.call(foo, 'bar'); // true\n\n\t// It's also possible to use the hasOwnProperty property from the Object prototype for this purpose\n\tObject.prototype.hasOwnProperty.call(foo, 'bar'); // true\nNote that in the last case there are no newly created objects.",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {String}prop The name of the property to test."
                        },
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "prop",
                            "text": "The name of the property to test.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        100790,
                        103512
                    ],
                    "fileName": "ALL.js"
                },
                "isPrototypeOf": {
                    "annotation": "method",
                    "name": "isPrototypeOf",
                    "text": "#Summary\nThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\nNote: isPrototypeOf differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n#Syntax\n\tprototypeObj.isPrototypeOf(obj)\n#Description\nThe isPrototypeOf method allows you to check whether or not an object exists within another object's prototype chain.\n\nFor example, consider the following prototype chain:\n\n\tfunction Fee() {\n\t  // ...\n\t}\n\n\tfunction Fi() {\n\t  // ...\n\t}\n\tFi.prototype = new Fee();\n\n\tfunction Fo() {\n\t  // ...\n\t}\n\tFo.prototype = new Fi();\n\n\tfunction Fum() {\n\t  // ...\n\t}\n\tFum.prototype = new Fo();\nLater on down the road, if you instantiate Fum and need to check if Fi's prototype exists within the Fum prototype chain, you could do this:\n\n\tvar fum = new Fum();\n\t// ...\n\n\tif (Fi.prototype.isPrototypeOf(fum)) {\n\t  // do something safe\n\t}\nThis, along with the instanceof operator particularly comes in handy if you have code that can only function when dealing with objects descended from a specific prototype chain, e.g., to guarantee that certain methods or properties will be present on that object.",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object} prototypeObj An object to be tested against each link in the prototype chain of the object argument.\n@param {Object}object The object whose prototype chain will be searched.\n@returns {boolean}"
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "prototypeObj",
                            "text": "An object to be tested against each link in the prototype chain of the object argument.",
                            "theRestString": "@param {Object}object The object whose prototype chain will be searched.\n@returns {boolean}"
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "object",
                            "text": "The object whose prototype chain will be searched.",
                            "theRestString": "@returns {boolean}"
                        },
                        {
                            "annotation": "returns",
                            "type": "{boolean}",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        103520,
                        105004
                    ],
                    "fileName": "ALL.js"
                },
                "propertyIsEnumerable": {
                    "annotation": "method",
                    "name": "propertyIsEnumerable",
                    "text": "#Summary\nThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n#Syntax\n\tobj.propertyIsEnumerable(prop)\n\n#Description\nEvery object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.\n\n#Examples\n##Example: A basic use of propertyIsEnumerable\n\nThe following example shows the use of propertyIsEnumerable on objects and arrays:\n\n\tvar o = {};\n\tvar a = [];\n\to.prop = 'is enumerable';\n\ta[0] = 'is enumerable';\n\n\to.propertyIsEnumerable('prop');   // returns true\n\ta.propertyIsEnumerable(0);        // returns true\n##Example: User-defined versus built-in objects\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n\tvar a = ['is enumerable'];\n\n\ta.propertyIsEnumerable(0);          // returns true\n\ta.propertyIsEnumerable('length');   // returns false\n\n\tMath.propertyIsEnumerable('random');   // returns false\n\tthis.propertyIsEnumerable('Math');     // returns false\n##Example: Direct versus inherited properties\n\n\tvar a = [];\n\ta.propertyIsEnumerable('constructor');         // returns false\n\n\tfunction firstConstructor() {\n\t  this.property = 'is not enumerable';\n\t}\n\n\tfirstConstructor.prototype.firstMethod = function() {};\n\n\tfunction secondConstructor() {\n\t  this.method = function method() { return 'is enumerable'; };\n\t}\n\n\tsecondConstructor.prototype = new firstConstructor;\n\tsecondConstructor.prototype.constructor = secondConstructor;\n\n\tvar o = new secondConstructor();\n\to.arbitraryProperty = 'is enumerable';\n\n\to.propertyIsEnumerable('arbitraryProperty');   // returns true\n\to.propertyIsEnumerable('method');              // returns true\n\to.propertyIsEnumerable('property');            // returns false\n\n\to.property = 'is enumerable';\n\n\to.propertyIsEnumerable('property');            // returns true\n\n\t// These return false as they are on the prototype which \n\t// propertyIsEnumerable does not consider (even though the last two\n\t// are iteratable with for-in)\n\to.propertyIsEnumerable('prototype');   // returns false (as of JS 1.8.1/FF3.6)\n\to.propertyIsEnumerable('constructor'); // returns false\n\to.propertyIsEnumerable('firstMethod'); // returns false",
                    "children": [
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "prop",
                            "text": "The name of the property to test.",
                            "theRestString": "@return {boolean}"
                        },
                        {
                            "annotation": "return",
                            "type": "{boolean}",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        105011,
                        107518
                    ],
                    "fileName": "ALL.js"
                },
                "toLocaleString": {
                    "annotation": "method",
                    "name": "toLocaleString",
                    "text": "#Summary\nThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n#Syntax\n\tobj.toLocaleString();\n#Description\nObject's toLocaleString returns the result of calling toString().\n\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. See the list below.\n\nObjects overriding toLocaleString\n\n\tArray: Array.prototype.toLocaleString()\n\tNumber: Number.prototype.toLocaleString()\n\tDate: Date.prototype.toLocaleString()",
                    "commentRange": [
                        107522,
                        108113
                    ],
                    "fileName": "ALL.js"
                },
                "toString": {
                    "annotation": "method",
                    "name": "toString",
                    "text": "#Summary\nThe toString() method returns a string representing object.\n\n#Syntax\n\tobj.toString()\n#Description\nEvery object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected. By default, the toString() method is inherited by every object descended from Object. If this method is not overridden in a custom object, toString() returns \"[object type]\", where type is the object type. The following code illustrates this:\n\n\tvar o = new Object();\n\to.toString();           // returns [object Object]\nNote: Starting in JavaScript 1.8.5 toString() called on null returns [object Null], and undefined returns [object Undefined], as defined in the 5th Edition of ECMAScript and a subsequent Errata. See Using toString to detect object type.\n#Examples\n##Example: Overriding the default toString method\n\nYou can create a function to be called in place of the default toString() method. The toString() method takes no arguments and should return a string. The toString() method you create can be any value you want, but it will be most useful if it carries information about the object.\n\nThe following code defines the Dog object type and creates theDog, an object of type Dog:\n\n\tfunction Dog(name, breed, color, sex) {\n\t  this.name = name;\n\t  this.breed = breed;\n\t  this.color = color;\n\t  this.sex = sex;\n\t}\n\n\ttheDog = new Dog('Gabby', 'Lab', 'chocolate', 'female');\nIf you call the toString() method on this custom object, it returns the default value inherited from Object:\n\n\ttheDog.toString(); // returns [object Object]\nThe following code creates and assigns dogToString() to override the default toString() method. This function generates a string containing the name, breed, color, and sex of the object, in the form \"property = value;\".\n\n\tDog.prototype.toString = function dogToString() {\n\t  var ret = 'Dog ' + this.name + ' is a ' + this.sex + ' ' + this.color + ' ' + this.breed;\n\t  return ret;\n\t}\n\nWith the preceding code in place, any time theDog is used in a string context, JavaScript automatically calls the dogToString() function, which returns the following string:\n\n\tDog Gabby is a female chocolate Lab\n\n##Example: Using toString() to detect object class\n\ntoString() can be used with every object and allows you to get its class. To use the Object.prototype.toString() with every object, you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter called thisArg.\n\n\tvar toString = Object.prototype.toString;\n\n\ttoString.call(new Date);    // [object Date]\n\ttoString.call(new String);  // [object String]\n\ttoString.call(Math);        // [object Math]\n\n\t// Since JavaScript 1.8.5\n\ttoString.call(undefined);   // [object Undefined]\n\ttoString.call(null);        // [object Null]",
                    "children": [
                        {
                            "annotation": "return",
                            "type": "{String}",
                            "name": "returns",
                            "text": "a string representing object.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        108117,
                        111082
                    ],
                    "fileName": "ALL.js"
                },
                "create": {
                    "annotation": "method",
                    "name": "create",
                    "text": "#Summary\nThe Object.create() method creates a new object with the specified prototype object and properties.\n\n#Syntax\n\tObject.create(proto[, propertiesObject])\n\n#Examples\n\n##Example: Classical inheritance with Object.create\n\nBelow is an example of how to use Object.create to achieve classical inheritance. This is for single inheritance, which is all that Javascript supports.\n\n\t// Shape - superclass\n\tfunction Shape() {\n\t  this.x = 0;\n\t  this.y = 0;\n\t}\n\n\t// superclass method\n\tShape.prototype.move = function(x, y) {\n\t  this.x += x;\n\t  this.y += y;\n\t  console.info('Shape moved.');\n\t};\n\n\t// Rectangle - subclass\n\tfunction Rectangle() {\n\t  Shape.call(this); // call super constructor.\n\t}\n\n\t// subclass extends superclass\n\tRectangle.prototype = Object.create(Shape.prototype);\n\tRectangle.prototype.constructor = Rectangle;\n\n\tvar rect = new Rectangle();\n\n\trect instanceof Rectangle; // true\n\trect instanceof Shape; // true\n\n\trect.move(1, 1); // Outputs, 'Shape moved.'\n\tIf you wish to inherit from multiple objects, then mixins are a possibility.\n\n\tfunction MyClass() {\n\t  SuperClass.call(this);\n\t  OtherSuperClass.call(this);\n\t}\n\n\tMyClass.prototype = Object.create(SuperClass.prototype); // inherit\n\tmixin(MyClass.prototype, OtherSuperClass.prototype); // mixin\n\n\tMyClass.prototype.myMethod = function() {\n\t  // do a thing\n\t};\n\nThe mixin function would copy the functions from the superclass prototype to the subclass prototype, the mixin function needs to be supplied by the user. An example of a mixin like function would be jQuery.extend.\n\n##Example: Using propertiesObject argument with Object.create\n\n\tvar o;\n\n\t// create an object with null as prototype\n\to = Object.create(null);\n\n\n\to = {};\n\t// is equivalent to:\n\to = Object.create(Object.prototype);\n\n\n\t// Example where we create an object with a couple of sample properties.\n\t// (Note that the second parameter maps keys to *property descriptors*.)\n\to = Object.create(Object.prototype, {\n\t  // foo is a regular 'value property'\n\t  foo: { writable: true, configurable: true, value: 'hello' },\n\t  // bar is a getter-and-setter (accessor) property\n\t  bar: {\n\t    configurable: false,\n\t    get: function() { return 10; },\n\t    set: function(value) { console.log('Setting `o.bar` to', value); }\n\t  }\n\t});\n\n\n\tfunction Constructor() {}\n\to = new Constructor();\n\t// is equivalent to:\n\to = Object.create(Constructor.prototype);\n\t// Of course, if there is actual initialization code in the\n\t// Constructor function, the Object.create cannot reflect it\n\n\n\t// create a new object whose prototype is a new, empty object\n\t// and a adding single property 'p', with value 42\n\to = Object.create({}, { p: { value: 42 } });\n\n\t// by default properties ARE NOT writable, enumerable or configurable:\n\to.p = 24;\n\to.p;\n\t// 42\n\n\to.q = 12;\n\tfor (var prop in o) {\n\t  console.log(prop);\n\t}\n\t// 'q'\n\n\tdelete o.p;\n\t// false\n\n\t// to specify an ES3 property\n\to2 = Object.create({}, {\n\t  p: {\n\t    value: 42,\n\t    writable: true,\n\t    enumerable: true,\n\t    configurable: true\n\t  }\n\t});\n\n##Polyfill\nThis polyfill covers the main use case which is creating a new object for which the prototype has been chosen but doesn't take the second argument into account.\n\n\tif (typeof Object.create != 'function') {\n\t  Object.create = (function() {\n\t    var Object = function() {};\n\t    return function (prototype) {\n\t      if (arguments.length > 1) {\n\t        throw Error('Second argument not supported');\n\t      }\n\t      if (typeof prototype != 'object') {\n\t        throw TypeError('Argument must be an object');\n\t      }\n\t      Object.prototype = prototype;\n\t      var result = new Object();\n\t      Object.prototype = null;\n\t      return result;\n\t    };\n\t  })();\n\t}",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object} proto The object which should be the prototype of the newly-created object.\n\n@param {Object} propertiesObject If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). @optional dummy @throws Throws a TypeError exception if the proto parameter isn't null or an object."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "proto",
                            "text": "The object which should be the prototype of the newly-created object.",
                            "theRestString": "@param {Object} propertiesObject If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). @optional dummy @throws Throws a TypeError exception if the proto parameter isn't null or an object."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "propertiesObject",
                            "text": "If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties().",
                            "theRestString": "@optional dummy @throws Throws a TypeError exception if the proto parameter isn't null or an object."
                        },
                        {
                            "annotation": "optional",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@throws Throws a TypeError exception if the proto parameter isn't null or an object."
                        },
                        {
                            "annotation": "throws",
                            "name": "Throws",
                            "text": "a TypeError exception if the proto parameter isn't null or an object.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        63738,
                        68040
                    ],
                    "fileName": "ALL.js"
                },
                "defineProperties": {
                    "annotation": "method",
                    "name": "defineProperties",
                    "text": "#Summary\nThe Object.defineProperties() method defines new or modifies existing properties directly on an object, returning the object.\n\n#Syntax\n\tObject.defineProperties(obj, props)\n\n#Description\nObject.defineProperties, in essence, defines all properties corresponding to the enumerable own properties of props on the object obj object.\n\n#Example\n\n\tObject.defineProperties(obj, {\n\t  \"property1\": {\n\t    value: true,\n\t    writable: true\n\t  },\n\t  \"property2\": {\n\t    value: \"Hello\",\n\t    writable: false\n\t  }\n\t  // etc. etc.\n\t});\n\n\n# Polyfill\n\nAssuming a pristine execution environment with all names and properties referring to their initial values, Object.defineProperties is almost completely equivalent (note the comment in isCallable) to the following reimplementation in JavaScript:\n\n\tfunction defineProperties(obj, properties) {\n\t  function convertToDescriptor(desc) {\n\t    function hasProperty(obj, prop) {\n\t      return Object.prototype.hasOwnProperty.call(obj, prop);\n\t    }\n\n\t    function isCallable(v) {\n\t      // NB: modify as necessary if other values than functions are callable.\n\t      return typeof v === \"function\";\n\t    }\n\n\t    if (typeof desc !== \"object\" || desc === null)\n\t      throw new TypeError(\"bad desc\");\n\n\t    var d = {};\n\n\t    if (hasProperty(desc, \"enumerable\"))\n\t      d.enumerable = !!obj.enumerable;\n\t    if (hasProperty(desc, \"configurable\"))\n\t      d.configurable = !!obj.configurable;\n\t    if (hasProperty(desc, \"value\"))\n\t      d.value = obj.value;\n\t    if (hasProperty(desc, \"writable\"))\n\t      d.writable = !!desc.writable;\n\t    if (hasProperty(desc, \"get\")) {\n\t      var g = desc.get;\n\n\t      if (!isCallable(g) && typeof g !== \"undefined\")\n\t        throw new TypeError(\"bad get\");\n\t      d.get = g;\n\t    }\n\t    if (hasProperty(desc, \"set\")) {\n\t      var s = desc.set;\n\t      if (!isCallable(s) && typeof s !== \"undefined\")\n\t        throw new TypeError(\"bad set\");\n\t      d.set = s;\n\t    }\n\n\t    if ((\"get\" in d || \"set\" in d) && (\"value\" in d || \"writable\" in d))\n\t      throw new TypeError(\"identity-confused descriptor\");\n\n\t    return d;\n\t  }\n\n\t  if (typeof obj !== \"object\" || obj === null)\n\t    throw new TypeError(\"bad obj\");\n\n\t  properties = Object(properties);\n\n\t  var keys = Object.keys(properties);\n\t  var descs = [];\n\n\t  for (var i = 0; i < keys.length; i++)\n\t    descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);\n\n\t  for (var i = 0; i < descs.length; i++)\n\t    Object.defineProperty(obj, descs[i][0], descs[i][1]);\n\n\t  return obj;\n\t}",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object} obj The object on which to define or modify properties.\n@param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "obj",
                            "text": "The object on which to define or modify properties.",
                            "theRestString": "@param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "props",
                            "text": "An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        68049,
                        70801
                    ],
                    "fileName": "ALL.js"
                },
                "defineProperty": {
                    "annotation": "method",
                    "name": "defineProperty",
                    "text": "#Summary\nThe Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\n\n#Syntax\nObject.defineProperty(obj, prop, descriptor)\n\n#Description\nThis method allows precise addition to or modification of a property on an object. Normal property addition through assignment creates properties which show up during property enumeration (for...in loop or Object.keys method), whose values may be changed, and which may be deleted. This method allows these extra details to be changed from their defaults.\n\nProperty descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both.\n\nBoth data and accessor descriptors are objects. They share the following optional keys:\n\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\nDefaults to false.\n\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\nDefaults to false.\nA data descriptor also has the following optional keys:\n\n###value\nThe value associated with the property. Can be any valid JavaScript value (number, object, function, etc).\nDefaults to undefined.\nwritable\ntrue if and only if the value associated with the property may be changed with an assignment operator.\nDefaults to false.\nAn accessor descriptor also has the following optional keys:\n\n###get\nA function which serves as a getter for the property, or undefined if there is no getter. The function return will be used as the value of property.\nDefaults to undefined.\n\n###set\nA function which serves as a setter for the property, or undefined if there is no setter. The function will receive as only argument the new value being assigned to the property.\nDefaults to undefined.\nBear in mind that these options are not necessarily own properties so, if inherited, will be considered too. In order to ensure these defaults are preserved you might freeze the Object.prototype upfront, specify all options explicitly, or point to null as __proto__ property.\n\n\t// using __proto__\n\tObject.defineProperty(obj, 'key', {\n\t  __proto__: null, // no inherited properties\n\t  value: 'static'  // not enumerable\n\t                   // not configurable\n\t                   // not writable\n\t                   // as defaults\n\t});\n\n\t// being explicit\n\tObject.defineProperty(obj, 'key', {\n\t  enumerable: false,\n\t  configurable: false,\n\t  writable: false,\n\t  value: 'static'\n\t});\n\n\t// recycling same object\n\tfunction withValue(value) {\n\t  var d = withValue.d || (\n\t    withValue.d = {\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false,\n\t      value: null\n\t    }\n\t  );\n\t  d.value = value;\n\t  return d;\n\t}\n\t// ... and ...\n\tObject.defineProperty(obj, 'key', withValue('static'));\n\n\t// if freeze is available, prevents the code to add\n\t// value, get, set, enumerable, writable, configurable\n\t// to the Object prototype\n\t(Object.freeze || Object)(Object.prototype);\n\n#Examples\n\nIf you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see additional examples.\n\n##Example: Creating a property\n\nWhen the property specified doesn't exist in the object, Object.defineProperty() creates a new property as described. Fields may be omitted from the descriptor, and default values for those fields are imputed. All of the Boolean-valued fields default to false. The value, get, and set fields default to undefined. A property which is defined without get/set/value/writable is called â€œgenericâ€ and is â€œtypedâ€ as a data descriptor.\n\n\tvar o = {}; // Creates a new object\n\n\t// Example of an object property added with defineProperty with a data property descriptor\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: true,\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\t// 'a' property exists in the o object and its value is 37\n\n\t// Example of an object property added with defineProperty with an accessor property descriptor\n\tvar bValue = 38;\n\tObject.defineProperty(o, 'b', {\n\t  get: function() { return bValue; },\n\t  set: function(newValue) { bValue = newValue; },\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\to.b; // 38\n\t// 'b' property exists in the o object and its value is 38\n\t// The value of o.b is now always identical to bValue, unless o.b is redefined\n\n\t// You cannot try to mix both:\n\tObject.defineProperty(o, 'conflict', {\n\t  value: 0x9f91102,\n\t  get: function() { return 0xdeadbeef; }\n\t});\n\t// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors\n\n##Example: Modifying a property\n\nWhen the property already exists, Object.defineProperty() attempts to modify the property according to the values in the descriptor and the object's current configuration. If the old descriptor had its configurable attribute set to false (the property is said to be â€œnon-configurableâ€), then no attribute besides writable can be changed. In that case, it is also not possible to switch back and forth between the data and accessor property types.\n\nIf a property is non-configurable, its writable attribute can only be changed to false.\n\nA TypeError is thrown when attempts are made to change non-configurable property attributes (besides the writable attribute) unless the current and new values are the same.\n\n##Writable attribute\n\nWhen the writable property attribute is set to false, the property is said to be â€œnon-writableâ€. It cannot be reassigned.\n\n\tvar o = {}; // Creates a new object\n\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: false\n\t});\n\n\tconsole.log(o.a); // logs 37\n\to.a = 25; // No error thrown (it would throw in strict mode, even if the value had been the same)\n\tconsole.log(o.a); // logs 37. The assignment didn't work.\n\nAs seen in the example, trying to write into the non-writable property doesn't change it but doesn't throw an error either.\n\n##Enumerable attribute\n\nThe enumerable property attribute defines whether the property shows up in a for...in loop and Object.keys() or not.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', { value: 1, enumerable: true });\n\tObject.defineProperty(o, 'b', { value: 2, enumerable: false });\n\tObject.defineProperty(o, 'c', { value: 3 }); // enumerable defaults to false\n\to.d = 4; // enumerable defaults to true when creating a property by setting it\n\n\tfor (var i in o) {\n\t  console.log(i);\n\t}\n\t// logs 'a' and 'd' (in undefined order)\n\n\tObject.keys(o); // ['a', 'd']\n\n\to.propertyIsEnumerable('a'); // true\n\to.propertyIsEnumerable('b'); // false\n\to.propertyIsEnumerable('c'); // false\n\tConfigurable attribute\n\n\tThe configurable attribute controls at the same time whether the property can be deleted from the object and whether its attributes (other than writable) can be changed.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', {\n\t  get: function() { return 1; },\n\t  configurable: false\n\t});\n\n\tObject.defineProperty(o, 'a', { configurable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { enumerable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { set: function() {} }); // throws a TypeError (set was undefined previously)\n\tObject.defineProperty(o, 'a', { get: function() { return 1; } }); // throws a TypeError (even though the new get does exactly the same thing)\n\tObject.defineProperty(o, 'a', { value: 12 }); // throws a TypeError\n\n\tconsole.log(o.a); // logs 1\n\tdelete o.a; // Nothing happens\n\tconsole.log(o.a); // logs 1\n\n\nIf the configurable attribute of o.a had been true, none of the errors would be thrown and the property would be deleted at the end.\n\n##Example: Adding properties and default values\n\nIt's important to consider the way default values of attributes are applied. There is often a difference between simply using dot notation to assign a value and using Object.defineProperty(), as shown in the example below.\n\n\tvar o = {};\n\n\to.a = 1;\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: true,\n\t  configurable: true,\n\t  enumerable: true\n\t});\n\n\n\t// On the other hand,\n\tObject.defineProperty(o, 'a', { value: 1 });\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: false,\n\t  configurable: false,\n\t  enumerable: false\n\t});\n\n\n##Example: Custom Setters and Getters\n\nExample below shows how to implement a self-archiving object. When temperature property is set, the archive array gets a log entry.\n\n\tfunction Archiver() {\n\t  var temperature = null;\n\t  var archive = [];\n\n\t  Object.defineProperty(this, 'temperature', {\n\t    get: function() {\n\t      console.log('get!');\n\t      return temperature;\n\t    },\n\t    set: function(value) {\n\t      temperature = value;\n\t      archive.push({ val: temperature });\n\t    }\n\t  });\n\n\t  this.getArchive = function() { return archive; };\n\t}\n\n\tvar arc = new Archiver();\n\tarc.temperature; // 'get!'\n\tarc.temperature = 11;\n\tarc.temperature = 13;\n\tarc.getArchive(); // [{ val: 11 }, { val: 13 }]",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object} obj The object on which to define the property.\n@param {String} prop The name of the property to be defined or modified.\n@param {Object} descriptor The descriptor for the property being defined or modified."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "obj",
                            "text": "The object on which to define the property.",
                            "theRestString": "@param {String} prop The name of the property to be defined or modified.\n@param {Object} descriptor The descriptor for the property being defined or modified."
                        },
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "prop",
                            "text": "The name of the property to be defined or modified.",
                            "theRestString": "@param {Object} descriptor The descriptor for the property being defined or modified."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "descriptor",
                            "text": "The descriptor for the property being defined or modified.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        70813,
                        80307
                    ],
                    "fileName": "ALL.js"
                },
                "freeze": {
                    "annotation": "method",
                    "name": "freeze",
                    "text": "#Summary\nThe Object.freeze() method freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen.\n\n#Syntax\nObject.freeze(obj)\n\n#Description\nNothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail, either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode).\n\nValues cannot be changed for data properties. Accessor properties (getters and setters) work the same (and still give the illusion that you are changing the value). Note that values that are objects can still be modified, unless they are also frozen.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.freeze(obj);\n\n\tassert(Object.isFrozen(obj) === true);\n\n\t// Now any changes will fail\n\tobj.foo = 'quux'; // silently does nothing\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors\n\tfunction fail(){\n\t  'use strict';\n\t  obj.foo = 'sparky'; // throws a TypeError\n\t  delete obj.quaxxor; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\n\tfail();\n\n\t// Attempted changes through Object.defineProperty will also throw\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // throws a TypeError\n\tThe following example shows that object values in a frozen object can be mutated (freeze is shallow).\n\n\tobj = {\n\t  internal: {}\n\t};\n\n\tObject.freeze(obj);\n\tobj.internal.a = 'aValue';\n\n\tobj.internal.a // 'aValue'\n\n\t// To make obj fully immutable, freeze each object in obj.\n\t// To do so, we use this function.\n\n\tfunction deepFreeze(o) {\n\t  var prop, propKey;\n\t  Object.freeze(o); // First freeze the object.\n\t  for (propKey in o) {\n\t    prop = o[propKey];\n\t    if (!o.hasOwnProperty(propKey) || !(typeof prop === 'object') || Object.isFrozen(prop)) {\n\t      // If the object is on the prototype, not an object, or is already frozen,\n\t      // skip it. Note that this might leave an unfrozen reference somewhere in the\n\t      // object if there is an already frozen object containing an unfrozen object.\n\t      continue;\n\t    }\n\n\t    deepFreeze(prop); // Recursively call deepFreeze.\n\t  }\n\t}\n\n\tobj2 = {\n\t  internal: {}\n\t};\n\n\tdeepFreeze(obj2);\n\tobj2.internal.a = 'anotherValue';\n\tobj2.internal.a; // undefined",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param obj The object to freeze."
                        },
                        {
                            "annotation": "param",
                            "name": "obj",
                            "text": "The object to freeze.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        80318,
                        83164
                    ],
                    "fileName": "ALL.js"
                },
                "getOwnPropertyDescriptor": {
                    "annotation": "method",
                    "name": "getOwnPropertyDescriptor",
                    "text": "#Summary\nThe Object.getOwnPropertyDescriptor() method returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object.\n\n#Syntax\n\tObject.getOwnPropertyDescriptor(obj, prop)\n\n#Description\nThis method permits examination of the precise description of a property. A property in JavaScript consists of a string-valued name and a property descriptor. Further information about property descriptor types and their attributes can be found in Object.defineProperty().\n\nA property descriptor is a record with some of the following attributes:\n\n###value\nThe value associated with the property (data descriptors only).\n###writable\ntrue if and only if the value associated with the property may be changed (data descriptors only).\n###get\nA function which serves as a getter for the property, or undefined if there is no getter (accessor descriptors only).\n###set\nA function which serves as a setter for the property, or undefined if there is no setter (accessor descriptors only).\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\n\n#Examples\n\n\tvar o, d;\n\n\to = { get foo() { return 17; } };\n\td = Object.getOwnPropertyDescriptor(o, 'foo');\n\t// d is { configurable: true, enumerable: true, get: , set: undefined }\n\n\to = { bar: 42 };\n\td = Object.getOwnPropertyDescriptor(o, 'bar');\n\t// d is { configurable: true, enumerable: true, value: 42, writable: true }\n\n\to = {};\n\tObject.defineProperty(o, 'baz', { value: 8675309, writable: false, enumerable: false });\n\td = Object.getOwnPropertyDescriptor(o, 'baz');\n\t// d is { value: 8675309, writable: false, enumerable: false, configurable: false }",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object}obj The object in which to look for the property.\n@param {String}prop The name of the property whose description is to be retrieved.\n@returns A property descriptor of the given property if it exists on the object, undefined otherwise."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "obj",
                            "text": "The object in which to look for the property.",
                            "theRestString": "@param {String}prop The name of the property whose description is to be retrieved.\n@returns A property descriptor of the given property if it exists on the object, undefined otherwise."
                        },
                        {
                            "annotation": "param",
                            "type": "{String}",
                            "name": "prop",
                            "text": "The name of the property whose description is to be retrieved.",
                            "theRestString": "@returns A property descriptor of the given property if it exists on the object, undefined otherwise."
                        },
                        {
                            "annotation": "returns",
                            "name": "A",
                            "text": "property descriptor of the given property if it exists on the object, undefined otherwise.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        83175,
                        85390
                    ],
                    "fileName": "ALL.js"
                },
                "getOwnPropertyNames": {
                    "annotation": "method",
                    "name": "getOwnPropertyNames",
                    "text": "#Summary\nThe Object.getOwnPropertyNames() method returns an array of all properties (enumerable or not) found directly upon a given object.\n\n#Syntax\nObject.getOwnPropertyNames(obj)\n\n#Description\nObject.getOwnPropertyNames returns an array whose elements are strings corresponding to the enumerable and non-enumerable properties found directly upon obj. The ordering of the enumerable properties in the array is consistent with the ordering exposed by a for...in loop (or by Object.keys) over the properties of the object. The ordering of the non-enumerable properties in the array, and among the enumerable properties, is not defined.\n\n#Examples\n##Example: Using getOwnPropertyNames\n\n\tvar arr = ['a', 'b', 'c'];\n\tprint(Object.getOwnPropertyNames(arr).sort()); // prints '0,1,2,length'\n\n\t// Array-like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tprint(Object.getOwnPropertyNames(obj).sort()); // prints '0,1,2'\n\n\t// Printing property names and values using Array.forEach\n\tObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n\t  print(val + ' -> ' + obj[val]);\n\t});\n\t// prints\n\t// 0 -> a\n\t// 1 -> b\n\t// 2 -> c\n\n\t// non-enumerable property\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: false } });\n\tmy_obj.foo = 1;\n\n\tprint(Object.getOwnPropertyNames(my_obj).sort()); // prints 'foo,getFoo'\n\nIf you want only the enumerable properties, see Object.keys() or use a for...in loop (although note that this will return enumerable properties not found directly upon that object but also along the prototype chain for the object unless the latter is filtered with hasOwnProperty()).\n\nItems on the prototype chain are not listed:\n\n\tfunction ParentClass() {}\n\tParentClass.prototype.inheritedMethod = function() {};\n\n\tfunction ChildClass() {\n\t  this.prop = 5;\n\t  this.method = function() {};\n\t}\n\tChildClass.prototype = new ParentClass;\n\tChildClass.prototype.prototypeMethod = function() {};\n\n\talert(\n\t  Object.getOwnPropertyNames(\n\t    new ChildClass() // ['prop', 'method']\n\t  )\n\t);\n\n##Example: Get Non-Enumerable Only\n\nThis uses the Array.prototype.filter() function to remove the enumerable keys (obtained with Object.keys()) from a list of all keys (obtained with Object.getOwnPropertyNames) leaving only the non-enumerable keys.\n\n\tvar target = myObject;\n\tvar enum_and_nonenum = Object.getOwnPropertyNames(target);\n\tvar enum_only = Object.keys(target);\n\tvar nonenum_only = enum_and_nonenum.filter(function(key) {\n\t  var indexInEnum = enum_only.indexOf(key);\n\t  if (indexInEnum == -1) {\n\t    // not found in enum_only keys mean the key is non-enumerable,\n\t    // so return true so we keep this in the filter\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t});\n\n\tconsole.log(nonenum_only);",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object} obj The object whose enumerable and non-enumerable own properties are to be returned."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "obj",
                            "text": "The object whose enumerable and non-enumerable own properties are to be returned.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        85401,
                        88300
                    ],
                    "fileName": "ALL.js"
                },
                "isExtensible": {
                    "annotation": "method",
                    "name": "isExtensible",
                    "text": "#Summary\nThe Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it).\n\n#Syntax\n\tObject.isExtensible(obj)\n\n#Description\nObjects are extensible by default: they can have new properties added to them, and (in engines that support __proto__  their __proto__ property) can be modified. An object can be marked as non-extensible using Object.preventExtensions(), Object.seal(), or Object.freeze().\n\n#Examples\n\t// New objects are extensible.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Sealed objects are by definition non-extensible.\n\tvar sealed = Object.seal({});\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// Frozen objects are also by definition non-extensible.\n\tvar frozen = Object.freeze({});\n\tassert(Object.isExtensible(frozen) === false);\n\tNotes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n\n\t> Object.isExtensible(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isExtensible(1)\n\tfalse",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object} obj The object which should be checked.\n@return {boolean}"
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "obj",
                            "text": "The object which should be checked.",
                            "theRestString": "@return {boolean}"
                        },
                        {
                            "annotation": "return",
                            "type": "{boolean}",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        88311,
                        89712
                    ],
                    "fileName": "ALL.js"
                },
                "isFrozen": {
                    "annotation": "method",
                    "name": "isFrozen",
                    "text": "#Summary\nThe Object.isFrozen() determines if an object is frozen.\n\n#Syntax\n\tObject.isFrozen(obj)\n\n#Description\nAn object is frozen if and only if it is not extensible, all its properties are non-configurable, and all its data properties (that is, properties which are not accessor properties with getter or setter components) are non-writable.\n\n#Examples\n\t// A new object is extensible, so it is not frozen.\n\tassert(Object.isFrozen({}) === false);\n\n\t// An empty object which is not extensible is vacuously frozen.\n\tvar vacuouslyFrozen = Object.preventExtensions({});\n\tassert(Object.isFrozen(vacuouslyFrozen) === true);\n\n\t// A new object with one property is also extensible, ergo not frozen.\n\tvar oneProp = { p: 42 };\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// Preventing extensions to the object still doesn't make it frozen,\n\t// because the property is still configurable (and writable).\n\tObject.preventExtensions(oneProp);\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// ...but then deleting that property makes the object vacuously frozen.\n\tdelete oneProp.p;\n\tassert(Object.isFrozen(oneProp) === true);\n\n\t// A non-extensible object with a non-writable but still configurable property is not frozen.\n\tvar nonWritable = { e: 'plep' };\n\tObject.preventExtensions(nonWritable);\n\tObject.defineProperty(nonWritable, 'e', { writable: false }); // make non-writable\n\tassert(Object.isFrozen(nonWritable) === false);\n\n\t// Changing that property to non-configurable then makes the object frozen.\n\tObject.defineProperty(nonWritable, 'e', { configurable: false }); // make non-configurable\n\tassert(Object.isFrozen(nonWritable) === true);\n\n\t// A non-extensible object with a non-configurable but still writable property also isn't frozen.\n\tvar nonConfigurable = { release: 'the kraken!' };\n\tObject.preventExtensions(nonConfigurable);\n\tObject.defineProperty(nonConfigurable, 'release', { configurable: false });\n\tassert(Object.isFrozen(nonConfigurable) === false);\n\n\t// Changing that property to non-writable then makes the object frozen.\n\tObject.defineProperty(nonConfigurable, 'release', { writable: false });\n\tassert(Object.isFrozen(nonConfigurable) === true);\n\n\t// A non-extensible object with a configurable accessor property isn't frozen.\n\tvar accessor = { get food() { return 'yum'; } };\n\tObject.preventExtensions(accessor);\n\tassert(Object.isFrozen(accessor) === false);\n\n\t// ...but make that property non-configurable and it becomes frozen.\n\tObject.defineProperty(accessor, 'food', { configurable: false });\n\tassert(Object.isFrozen(accessor) === true);\n\n\t// But the easiest way for an object to be frozen is if Object.freeze has been called on it.\n\tvar frozen = { 1: 81 };\n\tassert(Object.isFrozen(frozen) === false);\n\tObject.freeze(frozen);\n\tassert(Object.isFrozen(frozen) === true);\n\n\t// By definition, a frozen object is non-extensible.\n\tassert(Object.isExtensible(frozen) === false);\n\n\t// Also by definition, a frozen object is sealed.\n\tassert(Object.isSealed(frozen) === true);\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n\n\t> Object.isFrozen(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isFrozen(1)\n\ttrue                          // ES6 code",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object}obj The object which should be checked.\n@returns boolean"
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "obj",
                            "text": "The object which should be checked.",
                            "theRestString": "@returns boolean"
                        },
                        {
                            "annotation": "returns",
                            "name": "boolean",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        89717,
                        93157
                    ],
                    "fileName": "ALL.js"
                },
                "isSealed": {
                    "annotation": "method",
                    "name": "isSealed",
                    "text": "#Summary\nThe Object.isSealed() method determines if an object is sealed.\n\n#Syntax\n\tObject.isSealed(obj)\n#Description\nReturns true if the object is sealed, otherwise false. An object is sealed if it is not extensible and if all its properties are non-configurable and therefore not removable (but not necessarily non-writable).\n\n#Examples\n\t// Objects aren't sealed by default.\n\tvar empty = {};\n\tassert(Object.isSealed(empty) === false);\n\n\t// If you make an empty object non-extensible, it is vacuously sealed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isSealed(empty) === true);\n\n\t// The same is not true of a non-empty object, unless its properties are all non-configurable.\n\tvar hasProp = { fee: 'fie foe fum' };\n\tObject.preventExtensions(hasProp);\n\tassert(Object.isSealed(hasProp) === false);\n\n\t// But make them all non-configurable and the object becomes sealed.\n\tObject.defineProperty(hasProp, 'fee', { configurable: false });\n\tassert(Object.isSealed(hasProp) === true);\n\n\t// The easiest way to seal an object, of course, is Object.seal.\n\tvar sealed = {};\n\tObject.seal(sealed);\n\tassert(Object.isSealed(sealed) === true);\n\n\t// A sealed object is, by definition, non-extensible.\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// A sealed object might be frozen, but it doesn't have to be.\n\tassert(Object.isFrozen(sealed) === true); // all properties also non-writable\n\n\tvar s2 = Object.seal({ p: 3 });\n\tassert(Object.isFrozen(s2) === false); // 'p' is still writable\n\n\tvar s3 = Object.seal({ get p() { return 0; } });\n\tassert(Object.isFrozen(s3) === true); // only configurability matters for accessor properties\n\n#Notes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n\n\t> Object.isSealed(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isSealed(1)\n\ttrue                          // ES6 code",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object} obj The object which should be checked.\n@returns {boolean}"
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "obj",
                            "text": "The object which should be checked.",
                            "theRestString": "@returns {boolean}"
                        },
                        {
                            "annotation": "returns",
                            "type": "{boolean}",
                            "text": "",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        93163,
                        95245
                    ],
                    "fileName": "ALL.js"
                },
                "keys": {
                    "annotation": "method",
                    "name": "keys",
                    "text": "#Summary\nThe Object.keys() method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n#Syntax\n\tObject.keys(obj)\n\n#Examples\n\tvar arr = ['a', 'b', 'c'];\n\tconsole.log(Object.keys(arr)); // console: ['0', '1', '2']\n\n\t// array like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tconsole.log(Object.keys(obj)); // console: ['0', '1', '2']\n\n\t// array like object with random key ordering\n\tvar an_obj = { 100: 'a', 2: 'b', 7: 'c' };\n\tconsole.log(Object.keys(an_obj)); // console: ['2', '7', '100']\n\n\t// getFoo is property which isn't enumerable\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\n\tmy_obj.foo = 1;\n\n\tconsole.log(Object.keys(my_obj)); // console: ['foo']\nIf you want all properties, even not enumerables, see Object.getOwnPropertyNames().\n\n#Polyfill\nTo add compatible Object.keys support in older environments that do not natively support it, copy the following snippet:\n\n\t// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n\tif (!Object.keys) {\n\t  Object.keys = (function() {\n\t    'use strict';\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty,\n\t        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n\t        dontEnums = [\n\t          'toString',\n\t          'toLocaleString',\n\t          'valueOf',\n\t          'hasOwnProperty',\n\t          'isPrototypeOf',\n\t          'propertyIsEnumerable',\n\t          'constructor'\n\t        ],\n\t        dontEnumsLength = dontEnums.length;\n\n\t    return function(obj) {\n\t      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n\t        throw new TypeError('Object.keys called on non-object');\n\t      }\n\n\t      var result = [], prop, i;\n\n\t      for (prop in obj) {\n\t        if (hasOwnProperty.call(obj, prop)) {\n\t          result.push(prop);\n\t        }\n\t      }\n\n\t      if (hasDontEnumBug) {\n\t        for (i = 0; i < dontEnumsLength; i++) {\n\t          if (hasOwnProperty.call(obj, dontEnums[i])) {\n\t            result.push(dontEnums[i]);\n\t          }\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t  }());\n\t}\nPlease note that the above code includes non-enumerable keys in IE7 (and maybe IE8), when passing in an object from a different window.\n\nFor a simple browser polyfill, see Javascript - Object.keys Browser Compatibility.",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object} obj The object whose enumerable own properties are to be returned.\n@returns {Array<String>} method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "obj",
                            "text": "The object whose enumerable own properties are to be returned.",
                            "theRestString": "@returns {Array<String>} method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."
                        },
                        {
                            "annotation": "returns",
                            "type": "{Array<String>}",
                            "name": "method",
                            "text": "returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        95253,
                        98093
                    ],
                    "fileName": "ALL.js"
                },
                "preventExtensions": {
                    "annotation": "method",
                    "name": "preventExtensions",
                    "text": "#Summary\nThe Object.preventExtensions() method prevents new properties from ever being added to an object (i.e. prevents future extensions to the object).\n\n#Syntax\n\tObject.preventExtensions(obj)\n\n#Description\nAn object is extensible if new properties can be added to it. Object.preventExtensions() marks an object as no longer extensible, so that it will never have properties beyond the ones it had at the time it was marked as non-extensible. Note that the properties of a non-extensible object, in general, may still be deleted. Attempting to add new properties to a non-extensible object will fail, either silently or by throwing a TypeError (most commonly, but not exclusively, when in strict mode).\n\nObject.preventExtensions() only prevents addition of own properties. Properties can still be added to the object prototype. However, calling Object.preventExtensions() on an object will also prevent extensions on its __proto__  property.\n\nIf there is a way to turn an extensible object to a non-extensible one, there is no way to do the opposite in ECMAScript 5.\n\n#Examples\n\t// Object.preventExtensions returns the object being made non-extensible.\n\tvar obj = {};\n\tvar obj2 = Object.preventExtensions(obj);\n\tassert(obj === obj2);\n\n\t// Objects are extensible by default.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Object.defineProperty throws when adding a new property to a non-extensible object.\n\tvar nonExtensible = { removable: true };\n\tObject.preventExtensions(nonExtensible);\n\tObject.defineProperty(nonExtensible, 'new', { value: 8675309 }); // throws a TypeError\n\n\t// In strict mode, attempting to add new properties to a non-extensible object throws a TypeError.\n\tfunction fail() {\n\t  'use strict';\n\t  nonExtensible.newProperty = 'FAIL'; // throws a TypeError\n\t}\n\tfail();\n\n\t// EXTENSION (only works in engines supporting __proto__\n\t// (which is deprecated. Use Object.getPrototypeOf instead)):\n\t// A non-extensible object's prototype is immutable.\n\tvar fixed = Object.preventExtensions({});\n\tfixed.__proto__ = { oh: 'hai' }; // throws a TypeError\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return it.\n\n\t> Object.preventExtensions(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.preventExtensions(1)\n\t1                             // ES6 code",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param {Object}obj The object which should be made non-extensible."
                        },
                        {
                            "annotation": "param",
                            "type": "{Object}",
                            "name": "obj",
                            "text": "The object which should be made non-extensible.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        98102,
                        100782
                    ],
                    "fileName": "ALL.js"
                },
                "valueOf": {
                    "annotation": "method",
                    "name": "valueOf",
                    "text": "#Summary\nThe valueOf() method returns the primitive value of the specified object.\n\n#Syntax\n\tobject.valueOf()\n#Description\nJavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\n\nBy default, the valueOf method is inherited by every object descended from Object. Every built-in core object overrides this method to return an appropriate value. If an object has no primitive value, valueOf returns the object itself, which is displayed as:\n\n\t[object Object]\nYou can use valueOf within your own code to convert a built-in object into a primitive value. When you create a custom object, you can override Object.prototype.valueOf() to call a custom method instead of the default Object method.\n\n##Overriding valueOf for custom objects\n\nYou can create a function to be called in place of the default valueOf method. Your function must take no arguments.\n\nSuppose you have an object type myNumberType and you want to create a valueOf method for it. The following code assigns a user-defined function to the object's valueOf method:\n\n\tmyNumberType.prototype.valueOf = function() { return customPrimitiveValue; };\nWith the preceding code in place, any time an object of type myNumberType is used in a context where it is to be represented as a primitive value, JavaScript automatically calls the function defined in the preceding code.\n\nAn object's valueOf method is usually invoked by JavaScript, but you can invoke it yourself as follows:\n\n\tmyNumber.valueOf()\nNote: Objects in string contexts convert via the toString() method, which is different from String objects converting to string primitives using valueOf. All objects have a string conversion, if only \"[object type]\". But many objects do not convert to number, boolean, or function.\n#Examples\n##Example: Using valueOf\n\n\to = new Object();\n\tmyVar = o.valueOf();      // [object Object]",
                    "commentRange": [
                        111088,
                        113125
                    ],
                    "fileName": "ALL.js"
                },
                "seal": {
                    "annotation": "method",
                    "name": "seal",
                    "text": "#Summary\nThe Object.seal() method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.\n\n#Syntax\n\tObject.seal(obj)\n\n#Description\nBy default, objects are extensible (new properties can be added to them). Sealing an object prevents new properties from being added and marks all existing properties as non-configurable. This has the effect of making the set of properties on the object fixed and immutable. Making all properties non-configurable also prevents them from being converted from data properties to accessor properties and vice versa, but it does not prevent the values of data properties from being changed. Attempting to delete or add properties to a sealed object, or to convert a data property to accessor or vice versa, will fail, either silently or by throwing a TypeError (most commonly, although not exclusively, when in strict mode code).\n\nThe prototype chain remains untouched. However, the __proto__  property is sealed as well.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed.\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.seal(obj);\n\n\tassert(o === obj);\n\tassert(Object.isSealed(obj) === true);\n\n\t// Changing property values on a sealed object still works.\n\tobj.foo = 'quux';\n\n\t// But you can't convert data properties to accessors, or vice versa.\n\tObject.defineProperty(obj, 'foo', { get: function() { return 'g'; } }); // throws a TypeError\n\n\t// Now any changes, other than to property values, will fail.\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\tdelete obj.foo; // silently doesn't delete the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors.\n\tfunction fail() {\n\t  'use strict';\n\t  delete obj.foo; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\tfail();\n\n\t// Attempted additions through Object.defineProperty will also throw.\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // changes existing property value",
                    "children": [
                        {
                            "annotation": "static",
                            "name": "dummy",
                            "text": "",
                            "theRestString": "@param  obj The object which should be sealed."
                        },
                        {
                            "annotation": "param",
                            "name": "obj",
                            "text": "The object which should be sealed.",
                            "theRestString": ""
                        }
                    ],
                    "commentRange": [
                        113130,
                        115471
                    ],
                    "fileName": "ALL.js"
                }
            }
        },
        "javascript.ObjectPrototype": {
            "annotation": "class",
            "name": "ObjectPrototype",
            "text": "Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\n\nThe Object.prototype property represents the Object prototype object.\n\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden (except an Object with a null prototype, i.e. Object.create(null)). For example, other constructors' prototypes override the constructor property and provide their own toString() methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.",
            "commentRange": [
                115473,
                116227
            ],
            "fileName": "ALL.js",
            "module": {
                "annotation": "module",
                "name": "javascript",
                "text": "",
                "commentRange": [
                    115473,
                    116227
                ],
                "fileName": "ALL.js"
            },
            "absoluteName": "javascript.ObjectPrototype",
            "properties": {
                "constructor": {
                    "annotation": "property",
                    "type": "{Function}",
                    "name": "constructor",
                    "text": "Specifies the function that creates an object's prototype.\n\n##Summary\nReturns a reference to the Object function that created the instance's prototype. Note that the value of this property is a reference to the function itself, not a string containing the function's name. The value is only read-only for primitive values such as 1, true and \"test\".\n\n##Description\n\nAll objects inherit a constructor property from their prototype:\n\n\tvar o = {};\n\to.constructor === Object; // true\n\n\tvar a = [];\n\ta.constructor === Array; // true\n\n\tvar n = new Number(3);\n\tn.constructor === Number; // true\n\n##Examples\n\n###Example: Displaying the constructor of an object\n\nThe following example creates a prototype, Tree, and an object of that type, theTree. The example then displays the constructor property for the object theTree.\n\n\tfunction Tree(name) {\n\t  this.name = name;\n\t}\n\n\tvar theTree = new Tree('Redwood');\n\tconsole.log('theTree.constructor is ' + theTree.constructor);\n\tThis example displays the following output:\n\n\ttheTree.constructor is function Tree(name) {\n\t  this.name = name;\n\t}\n\n###Example: Changing the constructor of an object\n\nThe following example shows how to modify constructor value of generic objects. Only true, 1 and \"test\" will not be affected as they have read-only native constructors. This example shows that it is not always safe to rely on the constructor property of an object.\n\n\tfunction Type () {}\n\n\tvar types = [\n\t  new Array(),\n\t  [],\n\t  new Boolean(),\n\t  true,             // remains unchanged\n\t  new Date(),\n\t  new Error(),\n\t  new Function(),\n\t  function () {},\n\t  Math,\n\t  new Number(),\n\t  1,                // remains unchanged\n\t  new Object(),\n\t  {},\n\t  new RegExp(),\n\t  /(?:)/,\n\t  new String(),\n\t  'test'            // remains unchanged\n\t];\n\tfor (var i = 0; i < types.length; i++) {\n\t  types[i].constructor = Type;\n\t  types[i] = [types[i].constructor, types[i] instanceof Type, types[i].toString()];\n\t}\n\tconsole.log(types.join('\\n'));\n\tThis example displays the following output:\n\n\tfunction Type() {},false,\n\tfunction Type() {},false,\n\tfunction Type() {},false,false\n\tfunction Boolean() {\n\t    [native code]\n\t},false,true\n\tfunction Type() {},false,Mon Sep 01 2014 16:03:49 GMT+0600\n\tfunction Type() {},false,Error\n\tfunction Type() {},false,function anonymous() {\n\n\t}\n\tfunction Type() {},false,function () {}\n\tfunction Type() {},false,[object Math]\n\tfunction Type() {},false,0\n\tfunction Number() {\n\t    [native code]\n\t},false,1\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,\n\tfunction String() {\n\t    [native code]\n\t},false,Ñ‚ÐµÑÑ‚",
                    "commentRange": [
                        116231,
                        118959
                    ],
                    "fileName": "ALL.js"
                },
                "__noSuchMethod__": {
                    "annotation": "property",
                    "type": "{Function}",
                    "name": "__noSuchMethod__",
                    "text": "Allows a function to be defined that will be executed when an undefined object member is called as a method.",
                    "commentRange": [
                        118967,
                        119234
                    ],
                    "fileName": "ALL.js"
                }
            }
        }
    },
    "modules": {
        "ideal": {
            "annotation": "module",
            "name": "ideal",
            "text": "",
            "commentRange": [
                0,
                36
            ],
            "fileName": "ALL.js"
        },
        "Problems": {
            "annotation": "module",
            "name": "Problems",
            "text": "",
            "commentRange": [
                1558,
                1927
            ],
            "fileName": "ALL.js"
        },
        "life": {
            "annotation": "module",
            "name": "life",
            "text": "",
            "commentRange": [
                1558,
                1927
            ],
            "fileName": "ALL.js"
        },
        "problem1": {
            "annotation": "module",
            "name": "problem1",
            "text": "This is a description of planet earth city from the point of view of an alien observing us from a space ship.",
            "commentRange": [
                2319,
                2673
            ],
            "fileName": "ALL.js"
        },
        "shortjsdoc": {
            "annotation": "module",
            "name": "shortjsdoc",
            "text": "",
            "commentRange": [
                4362,
                4445
            ],
            "fileName": "ALL.js"
        },
        "Backbone": {
            "annotation": "module",
            "name": "Backbone",
            "text": "",
            "commentRange": [
                23656,
                23890
            ],
            "fileName": "ALL.js"
        },
        "jQuery": {
            "annotation": "module",
            "name": "jQuery",
            "text": "",
            "commentRange": [
                23656,
                23890
            ],
            "fileName": "ALL.js"
        },
        "javascript": {
            "annotation": "module",
            "name": "javascript",
            "text": "",
            "commentRange": [
                23892,
                27560
            ],
            "fileName": "ALL.js"
        }
    }
}
