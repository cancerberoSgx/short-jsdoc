{"source":"\n\n//@filename {Foo} fileName ALL.js\n\n//@module ideal\n//@class BaseObject \nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n//@property {Date} creationDate\n//@property {String} name\n//@property {String} description\n//@property {Object<String,User>} owners the owners, a map by owner id\nfunction BaseObject(){};\n\n//@class ObjectPool\nfunction ObjectPool(){};\n//@method loadObjects @param {Array<String>} objects_ids @return {Object<String,BaseObject>}\nObjectPool.prototype.getOwners = function(objects_ids){return null;}\n\n// @param {Array<String>} objects_ids\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n// @method getState0 @returns {a:B231,c:D231,s:String}\n// @method getState2 @returns {a:B231,c:D231}\n// @method getState3 @re turns {#obj(color:String)}\n// @method getState4 @returns {name:String,colors:Array<Color>,car:Car}\n// @method getState get's the current state of this pool\n// @returns {id:String,objectDic:Object<String>} bla bla bla\nvar getState=function(){};\n\n\n\n//@method getOwners this method is useful for *blabla* blabla _blabla_ bab\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n\n\n// @event objectCreated event fired when an object is created in this pool.\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n\n//@class Thing @extends BaseObject\n//@property {Number} importance\n\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n\n/** @class Action @extends BaseObject */\n\nvar s = 'these are just js sample sentences'; \nif(typeof sentence === 'undefined')\n{\n\tconsole.log('alert'); \n}\n\n//@method extract @param {String|BaseObject|Array<BaseObject>} what\n\n// @module ideasAndProblems67\n\n// @class Idea\n\n// @class Problem @extends Idea\n\n// @param {Number} complexity\n\n// @class IdealProblem @extends Problem\n\n// @class MathProblem @extends IdealProblem\n\n// @property {Object<String,Equation>} equations\n\n\n\n// @class Equation\n\n// @method resolve invoke this method to solve the equation \n\n// @throws {EquationError} kja shkdj ahsd\n\n//@event afterThatHappens triggered when you-know-who comes the handler must be a ....\n// @returns {Solution} because we are very practical\n// @class Solution\n\n// @class EquationError @extends Error\n\n/* \n\n@module pretty.names_9 lorem ipsum liprim trogus\n\n@class A.Real.World.Name_123 lorem ipsum liprim trogus\n\n@class Other.Real.Name_234 lorem ipsum liprim trogus @extends A.Real.World.Name_123 \n\n@property {Array<A.Real.World.Name_123>} children lorem ipsum liprim trogus\n\n\n*/\n\n//@module life\n//@class Living @extends Thing\n//@method breath @param {Number} size\n\n//@class Animal @extends Living\n//@method eat @param {Array<Food>} food @return {Array<Energy>}\n\n//@class Person @extends Animal\n//@method walk @return {Action}\n/*@method crossStreet\n\nThis try to be a markdown [text](http://google.com)\n\nAnother paragraph \n\n\tvar someMarkup = {\n\t\ta: 1\n\t,\tn: 2\n\t,\tg: function (e)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t};\n\nand some final text with a list\n\n1. First ordered list item\n2. Another item\n  * Unordered sub-list.\n1. Actual numbers don't matter, just that it's a number\n  1. Ordered sub-list\n  2. hello\n4. And another item.\n*/\n\n\n// @module problem1 This is a description of planet earth city from the point of view of an alien observing us from a space ship.\n//@class TerranObject\n// @class Person @extends TerranObject\n\n//@class List This is just a semantic alias for javascript Array. @extends Array\n//@class Map This is just a semantic alias for javascript Object. @extends Object\n\n/*@class Building @extends TerranObject */\n\n//@class Hospital @extends Building\n//@constructor Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit... \n//@param {Number} availableBeds\n//Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...\n//@method getActiveDoctors @returns {List<Doctor>} the currently active doctors in this hospital\n//@property {Array<Person>} todayIngresedPatients all the patiens that entered this hospital today\n\n// @class Doctor @extend Person\n// @property {Map<String,MedicalTopic>} skills\n\n/*\n\n@class MedicalTopic\nLorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum\n\n\n@method beUsed \n\nLorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum\n\n@throws {MedicalException} if there is any medical issue stuff...\n@param {Number} amount Excepteur sint occaecat *cupidatat* \n\n@return {Array<MedicalTopic>}\n\n\n\n\n@class MedicalException @extends Error\n*/\n\n(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n//     Underscore.js 1.7.0\n//     http://underscorejs.org\n//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    concat           = ArrayProto.concat,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.7.0';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var createCallback = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  _.iteratee = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return createCallback(value, context, argCount);\n    if (_.isObject(value)) return _.matches(value);\n    return _.property(value);\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    if (obj == null) return obj;\n    iteratee = createCallback(iteratee, context);\n    var i, length = obj.length;\n    if (length === +length) {\n      for (i = 0; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    if (obj == null) return [];\n    iteratee = _.iteratee(iteratee, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length),\n        currentKey;\n    for (var index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {\n    if (obj == null) obj = [];\n    iteratee = createCallback(iteratee, context, 4);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index = 0, currentKey;\n    if (arguments.length < 3) {\n      if (!length) throw new TypeError(reduceError);\n      memo = obj[keys ? keys[index++] : index++];\n    }\n    for (; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {\n    if (obj == null) obj = [];\n    iteratee = createCallback(iteratee, context, 4);\n    var keys = obj.length !== + obj.length && _.keys(obj),\n        index = (keys || obj).length,\n        currentKey;\n    if (arguments.length < 3) {\n      if (!index) throw new TypeError(reduceError);\n      memo = obj[keys ? keys[--index] : --index];\n    }\n    while (index--) {\n      currentKey = keys ? keys[index] : index;\n      memo = iteratee(memo, obj[currentKey], currentKey, obj);\n    }\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var result;\n    predicate = _.iteratee(predicate, context);\n    _.some(obj, function(value, index, list) {\n      if (predicate(value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    if (obj == null) return results;\n    predicate = _.iteratee(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(_.iteratee(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    if (obj == null) return true;\n    predicate = _.iteratee(predicate, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index, currentKey;\n    for (index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    if (obj == null) return false;\n    predicate = _.iteratee(predicate, context);\n    var keys = obj.length !== +obj.length && _.keys(obj),\n        length = (keys || obj).length,\n        index, currentKey;\n    for (index = 0; index < length; index++) {\n      currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (obj.length !== +obj.length) obj = _.values(obj);\n    return _.indexOf(obj, target) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matches(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matches(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = obj.length === +obj.length ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = obj.length === +obj.length ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = obj && obj.length === +obj.length ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (obj.length !== +obj.length) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = _.iteratee(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = _.iteratee(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = _.iteratee(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = low + high >>> 1;\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return obj.length === +obj.length ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = _.iteratee(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    if (n < 0) return [];\n    return slice.call(array, 0, n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return slice.call(array, Math.max(array.length - n, 0));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, output) {\n    if (shallow && _.every(input, _.isArray)) {\n      return concat.apply(output, input);\n    }\n    for (var i = 0, length = input.length; i < length; i++) {\n      var value = input[i];\n      if (!_.isArray(value) && !_.isArguments(value)) {\n        if (!strict) output.push(value);\n      } else if (shallow) {\n        push.apply(output, value);\n      } else {\n        flatten(value, shallow, strict, output);\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (array == null) return [];\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = _.iteratee(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = array.length; i < length; i++) {\n      var value = array[i];\n      if (isSorted) {\n        if (!i || seen !== value) result.push(value);\n        seen = value;\n      } else if (iteratee) {\n        var computed = iteratee(value, i, array);\n        if (_.indexOf(seen, computed) < 0) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (_.indexOf(result, value) < 0) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true, []));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    if (array == null) return [];\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = array.length; i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(slice.call(arguments, 1), true, true, []);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function(array) {\n    if (array == null) return [];\n    var length = _.max(arguments, 'length').length;\n    var results = Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(arguments, i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, length = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    for (; i < length; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var idx = array.length;\n    if (typeof from == 'number') {\n      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);\n    }\n    while (--idx >= 0) if (array[idx] === item) return idx;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Reusable constructor function for prototype setting.\n  var Ctor = function(){};\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    args = slice.call(arguments, 2);\n    bound = function() {\n      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n      Ctor.prototype = func.prototype;\n      var self = new Ctor;\n      Ctor.prototype = null;\n      var result = func.apply(self, args.concat(slice.call(arguments)));\n      if (_.isObject(result)) return result;\n      return self;\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    return function() {\n      var position = 0;\n      var args = boundArgs.slice();\n      for (var i = 0, length = args.length; i < length; i++) {\n        if (args[i] === _) args[i] = arguments[position++];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return func.apply(this, args);\n    };\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = hasher ? hasher.apply(this, arguments) : key;\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last > 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed before being called N times.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      } else {\n        func = null;\n      }\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    var source, prop;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      source = arguments[i];\n      for (prop in source) {\n        if (hasOwnProperty.call(source, prop)) {\n            obj[prop] = source[prop];\n        }\n      }\n    }\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj, iteratee, context) {\n    var result = {}, key;\n    if (obj == null) return result;\n    if (_.isFunction(iteratee)) {\n      iteratee = createCallback(iteratee, context);\n      for (key in obj) {\n        var value = obj[key];\n        if (iteratee(value, key, obj)) result[key] = value;\n      }\n    } else {\n      var keys = concat.apply([], slice.call(arguments, 1));\n      obj = new Object(obj);\n      for (var i = 0, length = keys.length; i < length; i++) {\n        key = keys[i];\n        if (key in obj) result[key] = obj[key];\n      }\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    for (var i = 1, length = arguments.length; i < length; i++) {\n      var source = arguments[i];\n      for (var prop in source) {\n        if (obj[prop] === void 0) obj[prop] = source[prop];\n      }\n    }\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n    // Objects with different constructors are not equivalent, but `Object`s\n    // from different frames are.\n    var aCtor = a.constructor, bCtor = b.constructor;\n    if (\n      aCtor !== bCtor &&\n      // Handle Object.create(x) cases\n      'constructor' in a && 'constructor' in b &&\n      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n        _.isFunction(bCtor) && bCtor instanceof bCtor)\n    ) {\n      return false;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size, result;\n    // Recursively compare objects and arrays.\n    if (className === '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size === b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      size = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      result = _.keys(b).length === size;\n      if (result) {\n        while (size--) {\n          // Deep compare each member\n          key = keys[size];\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.\n  if (typeof /./ !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = function(key) {\n    return function(obj) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.\n  _.matches = function(attrs) {\n    var pairs = _.pairs(attrs), length = pairs.length;\n    return function(obj) {\n      if (obj == null) return !length;\n      obj = new Object(obj);\n      for (var i = 0; i < length; i++) {\n        var pair = pairs[i], key = pair[0];\n        if (pair[1] !== obj[key] || !(key in obj)) return false;\n      }\n      return true;\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = createCallback(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return void 0;\n    var value = object[property];\n    return _.isFunction(value) ? object[property]() : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n\n},{}],2:[function(require,module,exports){\nvar JsDocMaker = require('./class'); \nvar _ = require('underscore'); \n\n// BINDING / post processing\n\n//@class TypeBinding a datatype with an association between types names in source code and parsed class nodes. \n//It support generic types (recursive)\n//@property {TypeBinding} type\n//@property {Array<TypeBinding>} params - the generic types params array. For example the params for {Map<String,Apple>} is [StringBynding]\n//@property {String} nativeTypeUrl - if this is a native type - this \n\n\n//@class JsDocMaker\n//@method parseTypeString @return {TypeBinding} or nulll in case the given type cannot be parsed\n//TODO: support multiple generics and generics anidation like in\nJsDocMaker.prototype.parseTypeString = function(typeString, baseClass)\n{\n\tif(!typeString || !baseClass)\n\t{\n\t\treturn null;\n\t}\n\t//first remove the '{}'\n\ttypeString = JsDocMaker.stringFullTrim(typeString); \n\tvar inner = /^{([^}]+)}$/.exec(typeString);\n\tif(!inner || inner.length<2)\n\t{\n\t\treturn null;\n\t}\n\ttypeString = inner[1]; \n\ttypeString = typeString.replace(/\\s+/gi, '');\n\tvar ret = this.parseSingleTypeString(typeString, baseClass); \n\tif(ret && ret.length===1)\n\t{\n\t\treturn ret[0]; \n\t}\n\telse\n\t{\t\n\t\treturn ret;\t\n\t}\t\n}; \n\n// @method parseSingleTypeString @param {String} typeStr\nJsDocMaker.prototype.parseSingleTypeString = function(typeStr, baseClass)\n{\n\tvar a = typeStr.split('|'), ret = [], self = this;\n\n\t_(a).each(function(typeString)\n\t{\n\t\n\t\t// is this a custom type, like #custom(1,2) ? \n\n\t\tvar regex = /^#(\\w+)\\(([^\\()]+)\\)/\n\t\t,\tcustomType = regex.exec(typeString)\n\t\t,\ttype_binded = null\n\t\t,\ttype = null;\n\n\t\tif(customType && customType.length === 3)\n\t\t{\n\t\t\tvar parserName = customType[1];\n\t\t\tvar parserInput = customType[2]; \n\t\t\tvar parser = self.typeParsers[parserName]; \n\t\t\tif(parser)\n\t\t\t{\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tvar parsed = parser.parse(parserInput, baseClass);\n\t\t\t\t\tif(parsed)\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO bind type ? \n\t\t\t\t\t\t//BIG PROBLEM HERE - this code executes at parsing time and here we are binding - do this binding in a post processing ast\n\t\t\t\t\t\t//TODO probably all this code should be moved to postprocessing ast phase and here we only dump the original type string.\n\t\t\t\t\t\ttype_binded = self.bindParsedType(parsed, baseClass); \n\t\t\t\t\t\tret.push(type_binded); \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch(ex)\n\t\t\t\t{\n\t\t\t\t\tself.error('Invalid Custom Type: '+typeString, ', baseClass: ', JSON.stringify(baseClass)); \n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t//it is a literal object type, like {a:String,b:Number}? \n\n\t\telse if(typeString.indexOf(':')!==-1 && typeString.indexOf('#')===-1 ) //and is not a custom type #cus\n\t\t{\n\t\t\ttype = null; \n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar props = JsDocMaker.parseType(typeString);\n\t\t\t\ttype = {name: 'Object', properties: props}; \n\t\t\t\ttype_binded = self.bindParsedType(type, baseClass);\n\t\t\t\tret.push(type_binded); \n\t\t\t}\n\t\t\tcatch(ex)\n\t\t\t{\n\t\t\t\tself.error('Invalid Type: '+typeString, ', baseClass: ', JSON.stringify(baseClass)); \n\t\t\t}\t\n\t\t}\n\n\n\t\t// it is a generic type like Array<String> ? \n\n\t\telse if(typeString.indexOf('<')!==-1)\n\t\t{\n\t\t\ttype = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\ttype = JsDocMaker.parseType(typeString);\n\t\t\t\ttype_binded = self.bindParsedType(type, baseClass);\n\t\t\t\tret.push(type_binded); \n\t\t\t}\n\t\t\tcatch(ex)\n\t\t\t{\n\t\t\t\tself.error('Invalid Type: '+typeString, ', baseClass: ', JSON.stringify(baseClass)); \n\t\t\t}\t\n\t\t}\n\n\t\telse\n\t\t{\t\n\t\t\tret.push(self.bindClass(typeString, baseClass));\t\n\t\t}\n\t}) ; \n\n\treturn ret;\n}; \n\n//@method bindParsedType merges the data of JsDocMaker.parseType with bindings of current jsdoc. recursive!\n//@param {Object} typeObject @param {Object} baseClass @return {Object}\nJsDocMaker.prototype.bindParsedType = function(typeObject, baseClass)\n{\n\tvar c = null, out = typeObject, self=this;\n\tif(typeObject && _(typeObject).isString())\n\t{\n\t\tc = this.bindClass(typeObject, baseClass); \n\t\tout = {name: typeObject}; \n\t}\n\telse if(typeObject && typeObject.name)\n\t{\n\n\t\t//recurse on params for generic types like M<T,K>!\n\t\tif(out.params)\n\t\t{\t\t\t\n\t\t\tvar new_params = [];\n\n\t\t\tc = this.bindClass(typeObject.name, baseClass); \n\n\t\t\t_(out.params).each(function(param)\n\t\t\t{\n\t\t\t\tvar new_param = self.bindParsedType(param, baseClass);\n\t\t\t\tnew_params.push(new_param);\n\t\t\t}); \n\t\t\tout.params = new_params;\t\n\t\t}\n\n\t\t//recurse on properties for literal object type like name:String,config:Config\n\t\tif(out.properties)\n\t\t{\n\t\t\tvar new_properties = {};\n\t\t\t_(out.properties).each(function(value, name)\n\t\t\t{\n\t\t\t\tvar new_property = self.bindParsedType(value, baseClass);\n\t\t\t\tnew_properties[name] = new_property; \n\t\t\t}); \n\t\t\tout.properties = new_properties;\t\n\t\t}\n\t}\n\tif(c)\n\t{\n\t\t_(out).extend(c);\n\t}\n\treturn out;\n}; \n\n//@method bindClass @param {String}name @param {Object} baseClass\n//TODO: using a internal map this could be done faster\nJsDocMaker.prototype.bindClass = function(name, baseClass)\n{\n\t//search all classes that matches the name\n\tvar classesWithName = _(_(this.data.classes).values()).filter(function(c)\n\t{\n\t\treturn c.name===name;//JsDocMaker.stringEndsWith(c.name, name); \n\t});\n\t//search classes of the module\n\tvar moduleClasses = _(classesWithName).filter(function(c)\n\t{\n\t\treturn JsDocMaker.startsWith(c.module.name, baseClass.module.name); \n\t}); \n\n\t//TODO: performance - classesWithName could be compauted only if moduleClasses is empty\n\n\tvar c = moduleClasses.length ? moduleClasses[0] : classesWithName[0]; \n\n\tif(!c)\n\t{\n\t\t//TODO: look at native types\n\t\tvar nativeType = this.getNativeTypeUrl ? this.getNativeTypeUrl(name) : null;\n\t\tvar o = {name:name}; \n\t\tif(nativeType)\n\t\t{\n\t\t\to.nativeTypeUrl = nativeType; \n\t\t}\n\t\telse\n\t\t{\n\t\t\to.error = 'NAME_NOT_FOUND'; \n\t\t}\n\t\treturn o;\t\t\n\t}\n\telse\n\t{\n\t\treturn c;\n\t}\n}; \n\n// @method simpleName @param {String} name @return {String}\nJsDocMaker.prototype.simpleName = function(name)\n{\n\tvar a = name.split(JsDocMaker.ABSOLUTE_NAME_SEPARATOR);\n\treturn a[a.length-1]; \n}; \n\n\n\n\n\n\n\n},{\"./class\":3,\"underscore\":1}],3:[function(require,module,exports){\n// @class JsDocMaker\n// Main jsdoc parser utility. It accepts a valid js source code String and returns a JavaScript object with a jsdoc AST, this is an object\n// with classes and modules array that users can use to easily access jsdocs information, for example, parsed.classes.Apple.methods.getColor\n// use the parseFile method for this! This will return the AST, if you want to perform more enrichment and type binding, then use \n// postProccess and postProccessBinding methods after.\n\nvar _ = require('underscore'); \n\nvar JsDocMaker = function(options)\n{\t\n\t//@property {Object<String,String>} customNativeTypes name to url map that the user can modify to register new native types b givin its url.\n\tthis.customNativeTypes = this.customNativeTypes || {};\n\tthis.annotationRegexp = /(\\s+@\\w+)/gi;\n\tthis.typeParsers = {};\n\tthis.inputSource = [];\n\tthis.options = options || {};\n}; \n\n\nJsDocMaker.DEFAULT_CLASS = 'Object'; \nJsDocMaker.DEFAULT_MODULE = '__DefaultModule'; \nJsDocMaker.ABSOLUTE_NAME_SEPARATOR = '.'; \nJsDocMaker.MULTIPLE_TEXT_SEPARATOR = '\\n\\n'; \n\n//expose\n/* jshint evil:true*/\nif(typeof(window) !== 'undefined')\n{\n\twindow.JsDocMaker = JsDocMaker; \n}\n\n\n//@method require perform an intelligent require n browser&nodejs, needed for esprima. Ugly :(\nJsDocMaker.require = function(name)\n{\n\treturn (typeof(window) != 'undefined' && window[name]) ? window[name] : require(name);\n}; \n\nmodule.exports = JsDocMaker; \n},{\"underscore\":1}],4:[function(require,module,exports){\n'strict mode'; \n\nvar JsDocMaker = require('./class'); \n\nrequire('./util'); \n\nrequire('./parse'); \n\nrequire('./preprocess'); \n\nrequire('./postprocess'); \n\nrequire('./binding'); \nrequire('./type-parsing'); \n\nmodule.exports = JsDocMaker;\n},{\"./binding\":2,\"./class\":3,\"./parse\":5,\"./postprocess\":6,\"./preprocess\":7,\"./type-parsing\":8,\"./util\":9}],5:[function(require,module,exports){\nvar JsDocMaker = require('./class'); \nvar esprima = JsDocMaker.require('esprima');\nvar _ = require('underscore'); \n\n//PARSING AND PREPROCESSING\n\n//@property {Array<Function>}commentPreprocessors\nJsDocMaker.prototype.commentPreprocessors = []; \n\n//@method jsdoc the public method to parse all the added files with addFile. @return {Object} the parsed object @param {String} source . Optional\nJsDocMaker.prototype.jsdoc = function(source)\n{\n\t//@property {Array<String>} all the input added included @filename annotations\n\tsource = source || this.inputSource.join('');\n\tthis.data = this.data || {}; \n\tthis.data.source = source;\n\n\t// @property {EsprimaSyntax} the Sprima Syntax object of the current pased file.\t\n\tthis.syntax = esprima.parse(source, {\n\t\traw: true\n\t,\trange: true\n\t,\tcomment: true\t\t\n\t});\n\n\tthis.parse(this.syntax.comments);\n\n\treturn this.data;\n}; \n\n//@method parseFile a public method for parsing a single file. Note if you want to parse more than one file please use addFile() and the jsdoc() \n//@return {Object} the parsed object @param {String} source @param {String} filename\nJsDocMaker.prototype.parseFile = function(source, fileName)\n{\n\tthis.addFile(source, fileName); \n\treturn this.jsdoc(); \n}; \n\n//@method addFile @param {String}source the source code of the file @param  {String} the file name\nJsDocMaker.prototype.addFile = function(source, fileName)\n{\n\tthis.inputSource.push('\\n\\n//@filename {Foo} fileName ' + fileName+'\\n\\n');\n\tthis.inputSource.push(source);\n}; \n\n//@property {String} ignoreCommentPrefix\nJsDocMaker.prototype.ignoreCommentPrefix = '?';\n\n//@method parse\t@return {Array} array of class description - with methods, and methods containing params. \nJsDocMaker.prototype.parse = function(comments)\n{\n\tvar self = this\n\t,\tcurrentClass = null\n\t,\tcurrentMethod = null\n\t,\tcurrentModule = null\n\t,\tcurrentFile = null;\n\n\tthis.comments = comments;\n\tthis.data = this.data || {}; \n\tthis.data.classes = this.data.classes || {}; \n\tthis.data.modules = this.data.modules || {}; \n\tthis.data.filenames = this.data.filenames || {}; \n\n\t_(this.commentPreprocessors).each(function(preprocessor)\n\t{\n\t\tpreprocessor.apply(self, [self]); \n\t});\n\n\t_(this.comments).each(function(node)\n\t{\n\t\tvar regex = /((?:@class)|(?:@method)|(?:@property)|(?:@method)|(?:@module)|(?:@event)|(?:@constructor)|(?:@filename))/gi; \n\t\tvar a = JsDocMaker.splitAndPreserve(node.value || '', regex); \n\t\ta = _(a).filter(function(v)  //delete empties and trim\n\t\t{\n\t\t\treturn JsDocMaker.stringTrim(v);\n\t\t});\n\t\t\n\t\t_(a).each(function(value)\n\t\t{\n\t\t\tvar parsed_array = self.parseUnit(value, node);\n\t\t\t_(parsed_array).each(function(parsed)\n\t\t\t{\n\t\t\t\tparsed.commentRange = node.range;\n\t\t\t\tparsed.file = currentFile;\n\n\t\t\t\tdelete parsed.theRestString; \n\n\t\t\t\t//Note: here is the (only) place were the 'primary tags' are implemented \n\t\t\t\t//We get primary tags like class,module,method,property and form the first primary AST (a module contains classes which contain methods and properties)\n\t\t\t\t//All the other annotations are treated as secondary, this means they will be assigned as childresn to the last primary annotation.\n\n\t\t\t\tif(parsed.annotation === 'class') \n\t\t\t\t{\n\t\t\t\t\t//allow classes without modules - asignated to a defulat module\n\t\t\t\t\tif (!currentModule)\n\t\t\t\t\t{\n\t\t\t\t\t\tcurrentModule = {name: JsDocMaker.DEFAULT_MODULE};\n\t\t\t\t\t}\n\n\t\t\t\t\tparsed.module = currentModule; \n\t\t\t\t\tparsed.absoluteName = currentModule.name + JsDocMaker.ABSOLUTE_NAME_SEPARATOR + parsed.name;\n\n\t\t\t\t\t//if the class was already defined we want to preserve all the definitions texts\n\t\t\t\t\tif(self.data.classes[parsed.absoluteName])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(self.data.classes[parsed.absoluteName].text !== parsed.text)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tself.data.classes[parsed.absoluteName].text += JsDocMaker.MULTIPLE_TEXT_SEPARATOR + parsed.text; \n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrentClass = self.data.classes[parsed.absoluteName]; \n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tself.data.classes[parsed.absoluteName] = parsed; \n\t\t\t\t\t\tdelete self.data.classes[parsed.name];\n\t\t\t\t\t\tcurrentClass = parsed; \n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(parsed.annotation === 'filename') \n\t\t\t\t{\n\t\t\t\t\tcurrentFile = parsed; \n\t\t\t\t\tcurrentFile.fileName = parsed.text; \n\t\t\t\t}\n\n\t\t\t\telse if(parsed.annotation === 'module')\n\t\t\t\t{\t\n\t\t\t\t\tcurrentModule = parsed;\n\n\t\t\t\t\t//if the module was already defined we want to preserve all the definitions texts\n\t\t\t\t\tif(self.data.modules[currentModule.name])\n\t\t\t\t\t{\n\t\t\t\t\t\tif(self.data.modules[currentModule.name].text !== currentModule.text)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tself.data.modules[currentModule.name].text += JsDocMaker.MULTIPLE_TEXT_SEPARATOR + currentModule.text; \n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tself.data.modules[currentModule.name] = currentModule; \n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//the rest are all children of class : \n\n\t\t\t\t//? we treat @method as equivalent as @constructor\n\t\t\t\telse if (parsed.annotation === 'method' && currentClass)\n\t\t\t\t{\n\t\t\t\t\tcurrentClass.methods = currentClass.methods || {};\n\t\t\t\t\tcurrentClass.methods[parsed.name] = parsed;\n\t\t\t\t\tcurrentMethod = parsed;\n\t\t\t\t}\n\t\t\t\telse if(parsed.annotation === 'constructor' && currentClass)\n\t\t\t\t{\n\t\t\t\t\tcurrentClass.constructors = currentClass.constructors || [];\n\t\t\t\t\tcurrentClass.constructors.push(parsed); \n\t\t\t\t\tcurrentMethod = parsed; \n\t\t\t\t}\n\n\t\t\t\t//? @property and @event are treated similarly\n\t\t\t\telse if(parsed.annotation === 'property' && currentClass)\n\t\t\t\t{\n\t\t\t\t\tcurrentClass.properties = currentClass.properties || {};\n\t\t\t\t\tcurrentClass.properties[parsed.name] = parsed;\n\t\t\t\t}\n\t\t\t\telse if(parsed.annotation === 'event' && currentClass)\n\t\t\t\t{\n\t\t\t\t\tcurrentClass.events = currentClass.events || {};\n\t\t\t\t\tcurrentClass.events[parsed.name] = parsed;\n\t\t\t\t}\n\n\t\t\t\t//? @param is children of @method\n\t\t\t\telse if(parsed.annotation === 'param' && currentClass)\n\t\t\t\t{\n\t\t\t\t\tif(!currentMethod)\n\t\t\t\t\t{\n\t\t\t\t\t\tself.error('param before method: ', parsed);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tcurrentMethod.params = currentMethod.params || {};\n\t\t\t\t\t\tcurrentMethod.params[parsed.name] = parsed; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}); \n\t\t});\n\t\t\n\t}); \n};\n\n// @method {Unit} parseUnit parse a simple substring like '@annotation {Type} a text' into an object {annotation, type, text} object.\n// syntax: @method {String} methodName blabla @return {Number} blabla @param {Object} p1 blabla\nJsDocMaker.prototype.parseUnit = function(str, comment)\n{\n\t// TODO: split str into major units and then do the parsing\n\tvar parsed = this.parseUnitSimple(str, comment); \n\tif(!parsed)\n\t{\n\t\treturn null;\n\t}\n\tvar ret = [parsed];\n\tif(parsed.theRestString)\n\t{\n\t\tvar s = parsed.theRestString; \n\t\tvar child;\n\t\twhile((child = this.parseUnitSimple(s, comment)))\n\t\t{\n\t\t\tif(child.annotation === 'class') {\n\t\t\t\tret.push(child); \n\t\t\t\tparsed = child;\n\t\t\t}\n\t\t\telse\n\t\t\t{\t\t\t\t\t\n\t\t\t\tparsed.children = parsed.children || []; \n\t\t\t\tparsed.children.push(child); \n\t\t\t}\n\t\t\ts = child.theRestString; \n\t\t}\n\t}\n\treturn ret; \n}; \n\n//@method parseUnitSimple @param {String} str @param {ASTSprimaNode} comment\nJsDocMaker.prototype.parseUnitSimple = function(str, comment) \n{\t\n\tif(!str)\n\t{\n\t\treturn null;\n\t}\n\tvar result;\n\tvar regexp = null; \n\n\tif(comment.type==='Line')\n\t{\n\t\tstr = JsDocMaker.stringFullTrim(str); \n\t\tregexp = /\\s*@(\\w+)\\s*(\\{[\\w<>\\|, #:\\(\\)\\.]+\\}){0,1}\\s*([\\w\\._\\$]+){0,1}(.*)\\s*/i; \n\t\tresult = regexp.exec(str);\n\t}\n\telse\n\t{\n\t\tstr = JsDocMaker.stringTrim(str); \n\t\tregexp = /\\s*@(\\w+)\\s*(\\{[\\w<>\\|, #:\\(\\)\\.]+\\}){0,1}\\s*([\\w\\._\\$]+){0,1}([.\\s\\w\\W]*)/gmi;\n\t\t//TODO: I have to put this regexp inline here - if not the second time I call exec on the instance it won't match. This is because the 'g' modifier.\n\t\tresult = regexp.exec(str); \n\t}\n\tif(!result || result.length<4)\n\t{\n\t\treturn null;  \n\t}\n\tvar text = result[4] || '';\n\t\t\n\tvar splitted = JsDocMaker.splitAndPreserve(text, this.annotationRegexp) || [''];  \n\ttext = splitted[0]; \n\tsplitted.splice(0,1); \n\tvar ret = {\n\t\tannotation: result[1]\n\t,\ttype: result[2]\n\t,\tname: result[3]\n\t,\ttext: JsDocMaker.stringTrim(text||'')\n\t,\ttheRestString: JsDocMaker.stringTrim(splitted.join(''))\n\t};\n\n\treturn ret;\n}; \n\n},{\"./class\":3,\"underscore\":1}],6:[function(require,module,exports){\nvar JsDocMaker = require('./class'); \nvar _ = require('underscore'); \n\n//POST PROCESSING\n\n\n//@property {Array<Function>}postProccessors\nJsDocMaker.prototype.postProccessors = []; \n\n// @method postProccess so the data is already parsed but we want to normalize some \n// children like @extend and @ module to be properties of the unit instead children.\n// Also we enforce explicit  parent reference, this is a class must reference its \n// parent module and a method muest reference its parent class. Also related to this \n// is the fullname property that will return an unique full name in the format \n// '$MODULE.$CLASS.$METHOD'. We assume that a module contains unique named classes and \n// that classes contain unique named properties and methods. \nJsDocMaker.prototype.postProccess = function()\n{\n\tvar self = this;\n\n\t// set params and throws of constructors\n\t_(self.data.classes).each(function(c)\n\t{\n\t\t_(c.constructors).each(function(co){\n\t\t\tco.params = _(co.children||[]).filter(function(child)\n\t\t\t{\n\t\t\t\treturn child.annotation === 'param'; \n\t\t\t});\n\n\t\t\tco.throws = _(co.children||[]).filter(function(child)\n\t\t\t{\n\t\t\t\treturn child.annotation === 'throw' || child.annotation === 'throws'; \n\t\t\t});\n\t\t}); \n\t}); \n}; \n\n\n//@method postProccessBinding precondion: call postProccess() first. We separated the post proccessing in two because we shouln't do JSON.stringify() after we bind types because of recursive loops. \nJsDocMaker.prototype.postProccessBinding = function()\n{\n\tif(this.literalObjectInstall)\n\t{\n\t\tthis.literalObjectInstall(); \n\t}\n\tvar self = this;\n\t\n\t//at this points we have all our modules and classes - now we normalize extend, methods and params and also do the type binding. \n\t_(self.data.classes).each(function(c)\n\t{\n\t\t//class.extends property\n\t\tvar extend = _(c.children||[]).find(function(child)\n\t\t{\n\t\t\treturn child.annotation === 'extend' || child.annotation === 'extends'; \n\t\t}); \n\n\t\tif(!extend) // All classes must extend something\n\t\t{\n\t\t\textend = c.extends = (self.bindClass(JsDocMaker.DEFAULT_CLASS, c) || {error: 'NAME_NOT_FOUND', name: JsDocMaker.DEFAULT_CLASS});\n\t\t}\n\t\telse \n\t\t{\n\t\t\tc.extends = self.bindClass(extend.name, c);\n\t\t\tc.children = _(c.children).without(extend);\t//TODO: why we would want to do this? - remove this line\n\t\t}\n\n\n\t\t//setup methods & constructors\n\n\t\tvar methods = _(c.methods).clone() || {};\n\t\tif(c.constructors) \n        {\n            for (var i = 0; i < c.constructors.length; i++) \n            {\n                var cname = 'constructor ' + i;\n                methods[cname] = c.constructors[i]; //using invalid method name\n                c.constructors[i].name = i+'';\n            }\n        }\n\n\t\t_(methods).each(function(method)\n\t\t{\n\t\t\t//method.param property\n\t\t\tvar params = _(method.children||[]).filter(function(child)\n\t\t\t{\n\t\t\t\tchild.text = JsDocMaker.stringTrim(child.text||''); \n\t\t\t\treturn child.annotation === 'param'; \n\t\t\t}); \n\t\t\tmethod.params = params; \n\n\t\t\tmethod.ownerClass = c.absoluteName;\t\t\t\t\n\t\t\tmethod.absoluteName = c.absoluteName + JsDocMaker.ABSOLUTE_NAME_SEPARATOR + method.name; \n\n\t\t\t_(method.params).each(function(param)\n\t\t\t{\n\t\t\t\tif(_(param.type).isString())\n\t\t\t\t{\n\t\t\t\t\tparam.typeOriginalString = param.type; \n\t\t\t\t\tparam.type = self.parseTypeString(param.type, c) || param.type;\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}); \n\n\t\t\t//method throws property\n\t\t\tvar throw$ = _(method.children||[]).filter(function(child)\n\t\t\t{\n\t\t\t\t// child.text = JsDocMaker.stringTrim(child.text||''); \n\t\t\t\treturn child.annotation === 'throw' || child.annotation === 'throws'; \n\t\t\t}); \n\t\t\tmethod.throws = throw$; \n\t\t\t// method.ownerClass = c.absoluteName;\t\t\t\t\n\t\t\t// method.absoluteName = c.absoluteName + JsDocMaker.ABSOLUTE_NAME_SEPARATOR + method.name; \n\t\t\t_(method.throws).each(function(t)\n\t\t\t{\n\t\t\t\t//because @throws doesn't have a name it breaks our simple grammar, so we merge the name with its text.\n\t\t\t\tt.text = (t.name ? t.name+' ' : '') + (t.text||''); \n\t\t\t\tif(_(t.type).isString())\n\t\t\t\t{\n\t\t\t\t\tt.typeOriginalString = t.type; \n\t\t\t\t\tt.type = self.parseTypeString(t.type, c) || t.type;\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}); \n\n\t\t\t//method.returns property\n\t\t\tvar returns = _(method.children||[]).filter(function(child)\n\t\t\t{\n\t\t\t\tchild.text = JsDocMaker.stringTrim(child.text||''); \n\t\t\t\treturn child.annotation === 'returns' || child.annotation === 'return'; \n\t\t\t}); \n\t\t\tmethod.returns = returns.length ? returns[0] : {name:'',type:''};\n\n\t\t\t//because @returns doesn't have a name it breaks our simple grammar, so we merge the name with its text.\n\t\t\tmethod.returns.text = (method.returns.name ? method.returns.name+' ' : '') + (method.returns.text||''); \n\n\t\t\tif(_(method.returns.type).isString())\n\t\t\t{\n\t\t\t\tmethod.returns.type = self.parseTypeString(method.returns.type, c) || method.returns.type;\t\t\t\t\t\t\n\t\t\t}\n\n\t\t\tif(self.installModifiers)\n\t\t\t{\n\t\t\t\tself.installModifiers(method); \n\t\t\t}\n\t\t});\n\n\t\t//setup properties\n\t\tvar propertySetup = function(prop)\n\t\t{\n\t\t\tprop.ownerClass = c.absoluteName;\n\t\t\tprop.absoluteName = c.absoluteName + JsDocMaker.ABSOLUTE_NAME_SEPARATOR + prop.name; \n\t\t\tif(self.installModifiers)\n\t\t\t{\n\t\t\t\tself.installModifiers(prop); \n\t\t\t}\n\t\t\tif(_(prop.type).isString())\n\t\t\t{\n\t\t\t\tprop.type = self.parseTypeString(prop.type, c) || prop.type;\n\t\t\t}\t\n\t\t}; \n\t\t_(c.properties).each(propertySetup);\n\t\t_(c.events).each(propertySetup);\n\t});\n};\n\n},{\"./class\":3,\"underscore\":1}],7:[function(require,module,exports){\nvar JsDocMaker = require('./class'); \nvar _ = require('underscore'); \n\n//COMMENT PREPROCESSORS\n\n//@method preprocessComments do an initial preprocesing on the comments erasing those marked to be ignored, and fixing its text to support alternative syntax.\nJsDocMaker.prototype.preprocessComments = function()\n{\n\t//we do the parsing block by block,\n\tfor (var i = 0; i < this.comments.length; i++) \n\t{\n\t\tvar node = this.comments[i]; \n\t\tnode.value = node.value || ''; \n\n\t\t// fix styled comment blocks with '*' as new line prefix\n\t\tif(node.type === 'Block')\n\t\t{\n\t\t\t// Note: syntax /** - not necesary to implement\n\t\t\tnode.value = node.value.replace(/\\n \\*/gi, '\\n');\n\t\t}\n\n\t\t// remove comments that starts with ignoreCommentPrefix\n\t\tif(JsDocMaker.startsWith(JsDocMaker.stringTrim(node.value), this.ignoreCommentPrefix))\n\t\t{\n\t\t\t//if \\n * is detected it is fixed to not count the decorative '*'\n\t\t\tthis.comments.splice(i, 1); //remove this node\n\t\t}\n\t}\n}; \n//install it as comment preprocessor plugin!\nJsDocMaker.prototype.commentPreprocessors.push(JsDocMaker.prototype.preprocessComments); \n\n\n//@method fixUnamedAnnotations - our regexp format expect an anotation with a name. So for enabling unamed annotations we do this dirty fix, this is add a name to \n//precondition\nJsDocMaker.prototype.fixUnamedAnnotations = function()\n{\n\t_(this.comments).each(function(node)\n\t{\n\t\tif(node.value)\n\t\t{\n\t\t\tnode.value = node.value.replace(/@constructor/gi, '@constructor n'); \n\t\t\t// node.value = node.value.replace(/@throw/gi, '@throws n'); \n\t\t\t// node.value = node.value.replace(/@throws/gi, '@throws n'); \n\t\t\tnode.value = node.value.replace(/(@\\w+)\\s*$/gi, '$1 dummy ');\n\t\t\tnode.value = node.value.replace(/(@\\w+)\\s+(@\\w+)/gi, '$1 dummy $2');\n\t\t}\n\t});\n};\n//install it as comment preprocessor plugin!\nJsDocMaker.prototype.commentPreprocessors.push(JsDocMaker.prototype.fixUnamedAnnotations); \n\n\n// @method unifyLineComments unify adjacents Line comment nodes into one in the ns.syntax.coments generated after visiting. \nJsDocMaker.prototype.unifyLineComments = function()\n{\n\tvar i = 0;\n\t\n\t//@property {String} lineCommentSeparator used to separate each Line comment type text\n\tthis.lineCommentSeparator = this.lineCommentSeparator || ' '; \n\n\twhile(i < this.comments.length - 1)\n\t{\n\t\tvar c = this.comments[i]\n\t\t,\tnext = this.comments[i+1]; \n\n\t\tvar sss = JsDocMaker.stringFullTrim(this.data.source.substring(c.range[1], next.range[0])); \n\t\tif (c.type==='Line' && next.type==='Line' && !sss)\n\t\t{\n\t\t\tc.value += ' ' + this.lineCommentSeparator + ' ' + next.value; \n\t\t\tc.range[1] = next.range[1]; \n\t\t\tthis.comments.splice(i+1, 1); \n\t\t}\n\t\telse\n\t\t{\n\t\t\ti++;\n\t\t}\n\t}\n}; \n\n//install it as comment preprocessor plugin!\nJsDocMaker.prototype.commentPreprocessors.push(JsDocMaker.prototype.unifyLineComments); \n\n},{\"./class\":3,\"underscore\":1}],8:[function(require,module,exports){\nvar JsDocMaker = require('./class'); \nvar shortjsdocParseLiteralObject = require('../objectTypeParser/parser.js');\nvar _ = require('underscore'); \n\n//TYPE PARSING\n\n//@method parseType parse a type string like 'Map<String,Array<Apple>>' or 'String' and return an object like {name: 'Map',params:['String',{name: 'Array',params:['Apple']}]}. This is the default type parser. \n//It depends on type parser file typeParser.js @static\nJsDocMaker.parseType = function(s)\n{\n\tvar parsed, ss;\n\tif(s.indexOf(':')!==-1)\n\t{\n\t\tss = '{'+s+'}'; \n\t\tparsed = JsDocMaker.parseLiteralObjectType(ss);\n\t}\n\telse\n\t{\n\t\tss ='{name:'+s+'}'; \n\t\tparsed = JsDocMaker.parseLiteralObjectType(ss);\n\t\tparsed = parsed.name; \n\t}\t\n\treturn parsed;\n}; \n\n// @method parse a object literal type string like '' @return {Object} the parsed object @static\nJsDocMaker.parseLiteralObjectType = function(s)\n{\n\tvar parsed = shortjsdocParseLiteralObject.parse(s);\t\n\tvar obj = eval('(' + parsed + ')'); \n\treturn obj;\n}; \n\nJsDocMaker.prototype.registerTypeParser = function(typeParser)\n{\n\tthis.typeParsers = this.typeParsers || {};\n\tthis.typeParsers[typeParser.name] = typeParser; \n}; \n\n\n},{\"../objectTypeParser/parser.js\":11,\"./class\":3,\"underscore\":1}],9:[function(require,module,exports){\nvar JsDocMaker = require('./class'); \nvar _ = require('underscore'); \n\n// STATIC UTILITIES\n\n// @method splitAndPreserve search for given regexp and split the given string but preserving the matches\n// @param {Regexp} regexp must contain a capturing group (like /(\\s+@\\w+)/gi)\n// @return {Array of string}\n// @static\nJsDocMaker.splitAndPreserve = function(string, replace)\n{\n\tstring = string || '';\n\tvar marker = '_%_%_';\n\tvar splitted = string.replace(replace, marker+'$1');\n\tif(splitted.length<2)\n\t{\n\t\treturn null; //TODO: notify error?\n\t}\n\tsplitted = splitted.split(marker);\n\treturn splitted; \n}; \n\n//@method stringFullTrim @param {String} s @static\nJsDocMaker.stringFullTrim = function(s)\n{\n\treturn (s||'').replace(/(?:(?:^|\\n)\\s+|\\s+(?:$|\\n))/g,'').replace(/\\s+/g,' ');\n};\n//@method stringTrim @param {String} s @static\nJsDocMaker.stringTrim = function(str)\n{\n\tvar whitespace = ' \\n\\r\\t\\f\\x0b\\xa0\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u3000';\n\tfor (var i = 0; i < str.length; i++) {\n\t\tif (whitespace.indexOf(str.charAt(i)) === -1) {\n\t\t\tstr = str.substring(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (i = str.length - 1; i >= 0; i--) {\n\t\tif (whitespace.indexOf(str.charAt(i)) === -1) {\n\t\t\tstr = str.substring(0, i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn whitespace.indexOf(str.charAt(0)) === -1 ? str : '';\n};\n//@method stringEndsWith @static\nJsDocMaker.stringEndsWith = function(str, suffix) \n{\n\tstr = str || '';\n\treturn str.indexOf(suffix, str.length - suffix.length) !== -1;\n}; \n//@method stringEndsWith @static\nJsDocMaker.startsWith = function(s, prefix)\n{\n\ts = s || '';\n\treturn s.indexOf(prefix)===0;\n}; \n\n//@mmethod error @param {String}msg\nJsDocMaker.prototype.error = function(msg)\n{\n\tconsole.error('Error detected: ' + msg); \n\tthrow msg;\n}; \n\n\n\n},{\"./class\":3,\"underscore\":1}],10:[function(require,module,exports){\n'strict mode'; \n\nvar JsDocMaker = require('./core/main'); \n\nrequire('./plugin/main.js'); \n\n\n// console.log('SEBAAA22', JsDocMaker)\n\nmodule.exports = JsDocMaker;\n\n},{\"./core/main\":4,\"./plugin/main.js\":14}],11:[function(require,module,exports){\n/*\n\nThis is a syntax definition compiled to JavaScript that parses an expression like \n\n  {name:String,colors:Map<String,Array<String>>}\n\nHow to work with this file ? open the following syntax into http://pegjs.org/online. \nThen make sure it returns the parse() function in the global 'shortjsdocParseLiteralObject'\n\n\nstart\n  = \"{\" exprs:(EXPR)+ [,]* \"}\" {return '{' + exprs.join(',') + '}'; }\n\nEXPR\n  = name:NAME \":\" value:(VALUE) [,]* {return name + ':' + value; }\n\nVALUE\n  = type:TYPE / name:NAME [,]* {if(typeof name !== 'undefined'){return name;}}\n\nTYPE\n  = name:NAME \"<\" list:(LIST_OF_NAMES)+ \">\" {return '{name: '+ name +',params:['+list.join(',')+']}'; }\n\nNAME\n  = name:[a-zA-z1-9_.]+ {return '\\''+name.join('')+'\\''; }\n\nLIST_OF_NAMES\n  = type:TYPE / name:NAME [,]* {\n  if(typeof name !== 'undefined'){\n  return name; \n  }\n}\n\n*/\nmodule.exports = (function() {\n  /*\n   * Generated by PEG.js 0.8.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function SyntaxError(message, expected, found, offset, line, column) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.offset   = offset;\n    this.line     = line;\n    this.column   = column;\n\n    this.name     = \"SyntaxError\";\n  }\n\n  peg$subclass(SyntaxError, Error);\n\n  function parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {},\n\n        peg$FAILED = {},\n\n        peg$startRuleIndices = { start: 0 },\n        peg$startRuleIndex   = 0,\n\n        peg$consts = [\n          peg$FAILED,\n          \"{\",\n          { type: \"literal\", value: \"{\", description: \"\\\"{\\\"\" },\n          [],\n          /^[,]/,\n          { type: \"class\", value: \"[,]\", description: \"[,]\" },\n          \"}\",\n          { type: \"literal\", value: \"}\", description: \"\\\"}\\\"\" },\n          function(exprs) {return '{' + exprs.join(',') + '}'; },\n          \":\",\n          { type: \"literal\", value: \":\", description: \"\\\":\\\"\" },\n          function(name, value) {return name + ':' + value; },\n          function(name) {if(typeof name !== 'undefined'){return name;}},\n          \"<\",\n          { type: \"literal\", value: \"<\", description: \"\\\"<\\\"\" },\n          \">\",\n          { type: \"literal\", value: \">\", description: \"\\\">\\\"\" },\n          function(name, list) {return '{name: '+ name +',params:['+list.join(',')+']}'; },\n          /^[a-zA-z1-9_.]/,\n          { type: \"class\", value: \"[a-zA-z1-9_.]\", description: \"[a-zA-z1-9_.]\" },\n          function(name) {return '\\''+name.join('')+'\\''; },\n          function(name) {\n            if(typeof name !== 'undefined'){\n            return name; \n            }\n          }\n        ],\n\n        peg$bytecode = [\n          peg$decode(\"!.!\\\"\\\"2!3\\\"+o$ #7!+&$,#&7!\\\"\\\"\\\"  +V% #0$\\\"\\\"1!3%,)&0$\\\"\\\"1!3%\\\"+8%.&\\\"\\\"2&3'+(%4$6($!\\\"%$$#  $##  $\\\"#  \\\"#  \"),\n          peg$decode(\"!7$+a$.)\\\"\\\"2)3*+Q%7\\\"+G% #0$\\\"\\\"1!3%,)&0$\\\"\\\"1!3%\\\"+)%4$6+$\\\"#!%$$#  $##  $\\\"#  \\\"#  \"),\n          peg$decode(\"7#*Q \\\"!7$+F$ #0$\\\"\\\"1!3%,)&0$\\\"\\\"1!3%\\\"+(%4\\\"6,\\\"!!%$\\\"#  \\\"#  \"),\n          peg$decode(\"!7$+b$.-\\\"\\\"2-3.+R% #7%+&$,#&7%\\\"\\\"\\\"  +9%./\\\"\\\"2/30+)%4$61$\\\"#!%$$#  $##  $\\\"#  \\\"#  \"),\n          peg$decode(\"! #02\\\"\\\"1!33+,$,)&02\\\"\\\"1!33\\\"\\\"\\\"  +' 4!64!! %\"),\n          peg$decode(\"7#*Q \\\"!7$+F$ #0$\\\"\\\"1!3%,)&0$\\\"\\\"1!3%\\\"+(%4\\\"65\\\"!!%$\\\"#  \\\"#  \")\n        ],\n\n        peg$currPos          = 0,\n        peg$reportedPos      = 0,\n        peg$cachedPos        = 0,\n        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleIndices)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$reportedPos, peg$currPos);\n    }\n\n    function offset() {\n      return peg$reportedPos;\n    }\n\n    function line() {\n      return peg$computePosDetails(peg$reportedPos).line;\n    }\n\n    function column() {\n      return peg$computePosDetails(peg$reportedPos).column;\n    }\n\n    function expected(description) {\n      throw peg$buildException(\n        null,\n        [{ type: \"other\", description: description }],\n        peg$reportedPos\n      );\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, peg$reportedPos);\n    }\n\n    function peg$computePosDetails(pos) {\n      function advance(details, startPos, endPos) {\n        var p, ch;\n\n        for (p = startPos; p < endPos; p++) {\n          ch = input.charAt(p);\n          if (ch === \"\\n\") {\n            if (!details.seenCR) { details.line++; }\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n        }\n      }\n\n      if (peg$cachedPos !== pos) {\n        if (peg$cachedPos > pos) {\n          peg$cachedPos = 0;\n          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };\n        }\n        advance(peg$cachedPosDetails, peg$cachedPos, pos);\n        peg$cachedPos = pos;\n      }\n\n      return peg$cachedPosDetails;\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, pos) {\n      function cleanupExpected(expected) {\n        var i = 1;\n\n        expected.sort(function(a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\n          return s\n            .replace(/\\\\/g,   '\\\\\\\\')\n            .replace(/\"/g,    '\\\\\"')\n            .replace(/\\x08/g, '\\\\b')\n            .replace(/\\t/g,   '\\\\t')\n            .replace(/\\n/g,   '\\\\n')\n            .replace(/\\f/g,   '\\\\f')\n            .replace(/\\r/g,   '\\\\r')\n            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return '\\\\x0' + hex(ch); })\n            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return '\\\\x'  + hex(ch); })\n            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return '\\\\u0' + hex(ch); })\n            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return '\\\\u'  + hex(ch); });\n        }\n\n        var expectedDescs = new Array(expected.length),\n            expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1\n          ? expectedDescs.slice(0, -1).join(\", \")\n              + \" or \"\n              + expectedDescs[expected.length - 1]\n          : expectedDescs[0];\n\n        foundDesc = found ? \"\\\"\" + stringEscape(found) + \"\\\"\" : \"end of input\";\n\n        return \"Expected \" + expectedDesc + \" but \" + foundDesc + \" found.\";\n      }\n\n      var posDetails = peg$computePosDetails(pos),\n          found      = pos < input.length ? input.charAt(pos) : null;\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new SyntaxError(\n        message !== null ? message : buildMessage(expected, found),\n        expected,\n        found,\n        pos,\n        posDetails.line,\n        posDetails.column\n      );\n    }\n\n    function peg$decode(s) {\n      var bc = new Array(s.length), i;\n\n      for (i = 0; i < s.length; i++) {\n        bc[i] = s.charCodeAt(i) - 32;\n      }\n\n      return bc;\n    }\n\n    function peg$parseRule(index) {\n      var bc    = peg$bytecode[index],\n          ip    = 0,\n          ips   = [],\n          end   = bc.length,\n          ends  = [],\n          stack = [],\n          params, i;\n\n      function protect(object) {\n        return Object.prototype.toString.apply(object) === \"[object Array]\" ? [] : object;\n      }\n\n      while (true) {\n        while (ip < end) {\n          switch (bc[ip]) {\n            case 0:\n              stack.push(protect(peg$consts[bc[ip + 1]]));\n              ip += 2;\n              break;\n\n            case 1:\n              stack.push(peg$currPos);\n              ip++;\n              break;\n\n            case 2:\n              stack.pop();\n              ip++;\n              break;\n\n            case 3:\n              peg$currPos = stack.pop();\n              ip++;\n              break;\n\n            case 4:\n              stack.length -= bc[ip + 1];\n              ip += 2;\n              break;\n\n            case 5:\n              stack.splice(-2, 1);\n              ip++;\n              break;\n\n            case 6:\n              stack[stack.length - 2].push(stack.pop());\n              ip++;\n              break;\n\n            case 7:\n              stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n              ip += 2;\n              break;\n\n            case 8:\n              stack.pop();\n              stack.push(input.substring(stack[stack.length - 1], peg$currPos));\n              ip++;\n              break;\n\n            case 9:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (stack[stack.length - 1]) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 10:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (stack[stack.length - 1] === peg$FAILED) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 11:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (stack[stack.length - 1] !== peg$FAILED) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 12:\n              if (stack[stack.length - 1] !== peg$FAILED) {\n                ends.push(end);\n                ips.push(ip);\n\n                end = ip + 2 + bc[ip + 1];\n                ip += 2;\n              } else {\n                ip += 2 + bc[ip + 1];\n              }\n\n              break;\n\n            case 13:\n              ends.push(end);\n              ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n              if (input.length > peg$currPos) {\n                end = ip + 3 + bc[ip + 1];\n                ip += 3;\n              } else {\n                end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n                ip += 3 + bc[ip + 1];\n              }\n\n              break;\n\n            case 14:\n              ends.push(end);\n              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n                end = ip + 4 + bc[ip + 2];\n                ip += 4;\n              } else {\n                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                ip += 4 + bc[ip + 2];\n              }\n\n              break;\n\n            case 15:\n              ends.push(end);\n              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n              if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n                end = ip + 4 + bc[ip + 2];\n                ip += 4;\n              } else {\n                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                ip += 4 + bc[ip + 2];\n              }\n\n              break;\n\n            case 16:\n              ends.push(end);\n              ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n              if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n                end = ip + 4 + bc[ip + 2];\n                ip += 4;\n              } else {\n                end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n                ip += 4 + bc[ip + 2];\n              }\n\n              break;\n\n            case 17:\n              stack.push(input.substr(peg$currPos, bc[ip + 1]));\n              peg$currPos += bc[ip + 1];\n              ip += 2;\n              break;\n\n            case 18:\n              stack.push(peg$consts[bc[ip + 1]]);\n              peg$currPos += peg$consts[bc[ip + 1]].length;\n              ip += 2;\n              break;\n\n            case 19:\n              stack.push(peg$FAILED);\n              if (peg$silentFails === 0) {\n                peg$fail(peg$consts[bc[ip + 1]]);\n              }\n              ip += 2;\n              break;\n\n            case 20:\n              peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];\n              ip += 2;\n              break;\n\n            case 21:\n              peg$reportedPos = peg$currPos;\n              ip++;\n              break;\n\n            case 22:\n              params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);\n              for (i = 0; i < bc[ip + 3]; i++) {\n                params[i] = stack[stack.length - 1 - params[i]];\n              }\n\n              stack.splice(\n                stack.length - bc[ip + 2],\n                bc[ip + 2],\n                peg$consts[bc[ip + 1]].apply(null, params)\n              );\n\n              ip += 4 + bc[ip + 3];\n              break;\n\n            case 23:\n              stack.push(peg$parseRule(bc[ip + 1]));\n              ip += 2;\n              break;\n\n            case 24:\n              peg$silentFails++;\n              ip++;\n              break;\n\n            case 25:\n              peg$silentFails--;\n              ip++;\n              break;\n\n            default:\n              throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n          }\n        }\n\n        if (ends.length > 0) {\n          end = ends.pop();\n          ip = ips.pop();\n        } else {\n          break;\n        }\n      }\n\n      return stack[0];\n    }\n\n    peg$result = peg$parseRule(peg$startRuleIndex);\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({ type: \"end\", description: \"end of input\" });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);\n    }\n  }\n\n  return {\n    SyntaxError: SyntaxError,\n    parse:       parse\n  };\n})();\n},{}],12:[function(require,module,exports){\nvar JsDocMaker = require('../core/class'); \nvar _ = require('underscore'); \n\n// INHERITED methods&properties postproccessing. Optional\n\n//@method postProccessInherited calculates inherited methods&properties and put it in class'properties inheritedMethods and inheritedProperties\nJsDocMaker.prototype.postProccessInherited = function()\n{\n\tvar self = this;\n\t_(self.data.classes).each(function(c)\n\t{\n\t\tc.inherited\t= c.inherited || {}; \n\t\tvar inheritedData = {}; \n\n\t\tc.inherited.methods = c.inherited.methods || {};\n\t\tself.extractInherited(c, c.extends, 'method', inheritedData);\n\t\t_(c.inherited.methods).extend(inheritedData); \n\n\t\tinheritedData = {}; \n\t\tc.inherited.properties = c.inherited.properties || {};\n\t\tself.extractInherited(c, c.extends, 'property', inheritedData);\n\t\t_(c.inherited.properties).extend(inheritedData); \n\n\t\tinheritedData = {}; \n\t\tc.inherited.events = c.inherited.events || {};\n\t\tself.extractInherited(c, c.extends, 'event', inheritedData);\n\t\t_(c.inherited.events).extend(inheritedData); \n\t});\n};\n\n//@method extractInherited @param baseClass @param c @param what @para data\nJsDocMaker.prototype.extractInherited = function(baseClass, c, what, data)\n{\n\tvar self = this;\n\tif(!c || c.nativeTypeUrl)\n\t{\n\t\treturn;\n\t}\n\twhat = what || 'method'; \n\tif(what === 'method')\n\t{\t\t\n\t\t_(c.methods).each(function(method, name)\n\t\t{\n\t\t\tbaseClass.methods = baseClass.methods || {};\n\t\t\tif(!baseClass.methods[name])\n\t\t\t{\n\t\t\t\tdata[name] = method;\n\t\t\t\t// TODO: here we can act and clone the inherited nodes and add more info about the owner\n\t\t\t\t// data[name].inherited = true; \n\t\t\t\t// data[name].inheritedFrom = c; \n\t\t\t}\n\t\t});\n\t}\n\telse if(what === 'property')\n\t{\n\t\t_(c.properties).each(function(p, name)\n\t\t{\n\t\t\tbaseClass.properties = baseClass.properties || {};\n\t\t\tif(!baseClass.properties[name])\n\t\t\t{\n\t\t\t\tdata[name] = p;\n\t\t\t\t// TODO: here we can act and clone the inherited nodes and add more info about the owner\n\t\t\t\t// data[name].inherited = true; \n\t\t\t\t// data[name].inheritedFrom = c; \n\t\t\t}\n\t\t});\n\t}\n\telse if(what === 'event')\n\t{\n\t\t_(c.events).each(function(p, name)\n\t\t{\n\t\t\tbaseClass.events = baseClass.events || {};\n\t\t\tif(!baseClass.events[name])\n\t\t\t{\n\t\t\t\tdata[name] = p;\n\t\t\t\t// TODO: here we can act and clone the inherited nodes and add more info about the owner\t\n\t\t\t\t// data[name].inherited = true; \n\t\t\t\t// data[name].inheritedFrom = c; \n\t\t\t}\n\t\t});\n\t}\n\n\tif(c.extends && c !== c.extends) //recurse!\n\t{\n\t\tself.extractInherited(baseClass, c.extends, what, data);\n\t}\n};\n\n//@method isClassOwner utility method for knowing if a property is defined in given class or is inherithed\n//@static @param aClass @param prop\nJsDocMaker.classOwnsProperty = function(aClass, prop)\n{\n\tvar result = prop.absoluteName && aClass.absoluteName && prop.absoluteName.indexOf(aClass.absoluteName) === 0; \n\treturn result;\n}; \n\n},{\"../core/class\":3,\"underscore\":1}],13:[function(require,module,exports){\nvar JsDocMaker = require('../core/class'); \nvar _ = require('underscore'); \n\n// this should be commented\n// it is an exmaple of a plugin that parse literal types like @param {#obj({p1:P1,p2:P2,...})} param1\n\n// CUSTOM TPE PLUGIN literalObjectParse - requires literalObjectParser.js - it adds support \n// for the custom type syntax #obj({p1:P1,p2:P2,...})to express literal objects\n// syntax: {#obj(prop1:String,prop2:Array<Apple>)}\n// DEPRECATED - turn it into a unit test showing an  example of plugin \n// @method literalObjectParse\nJsDocMaker.prototype.literalObjectParse = function(s, baseClass)\n{\n\tvar parsed = null\n\t,\tself=this\n\t,\tproperties = {};\n\ttry\n\t{\n\t\tvar result  = JsDocMaker.parseLiteralObjectType('{' + s + '}');\n\t\t_(result).each(function(value, key)\n\t\t{\n\t\t\tvar valueBinded = self.bindParsedType(value, baseClass);\n\t\t\tproperties[key] = valueBinded; \n\t\t}); \n\t}\n\tcatch(ex)\n\t{\n\t\tJsDocMaker.prototype.error('Failed to parse literal object ' + s);\n\t\tthrow ex;\n\t}\n\treturn {\n\t\tname: 'Object'\n\t,\tproperties: properties\n\t,\tpropertiesOriginal: parsed\n\t}; \n};\n\nJsDocMaker.prototype.literalObjectInstall = function()\n{\t\n\tthis.typeParsers = this.typeParsers || {}; \n\tvar parser = {\n\t\tname: 'obj'\n\t,\tparse: _(this.literalObjectParse).bind(this)\n\t};\n\tthis.registerTypeParser(parser); \n}; \n\n\n},{\"../core/class\":3,\"underscore\":1}],14:[function(require,module,exports){\n'strict mode'; \n\nvar JsDocMaker = require('../core/main.js'); \n\nrequire('./native-types.js'); \nrequire('./modifiers.js'); \nrequire('./inherited.js');\nrequire('./util.js');\nrequire('./literal-object.js');\n\nmodule.exports = JsDocMaker; \n},{\"../core/main.js\":4,\"./inherited.js\":12,\"./literal-object.js\":13,\"./modifiers.js\":15,\"./native-types.js\":16,\"./util.js\":17}],15:[function(require,module,exports){\nvar JsDocMaker = require('../core/class'); \nvar _ = require('underscore'); \n\n//MODIFIERS postproccessing- like static, private, final. Optional module\n\n//@property {Array<String>}MODIFIERS @static\nJsDocMaker.MODIFIERS = ['static', 'private', 'final', 'deprecated', 'experimental', 'optional', 'abstract']; \n//@method installModifiers sets the property modifiers to the node according its children\nJsDocMaker.prototype.installModifiers = function(node)\n{\n\tnode.modifiers = node.modifiers || []; \n\t_(node.children).each(function(child)\n\t{\n\t\tif(_(JsDocMaker.MODIFIERS).contains(child.annotation))\n\t\t{\n\t\t\tnode.modifiers.push(child.annotation); \n\t\t}\n\t});\n}; \n\n},{\"../core/class\":3,\"underscore\":1}],16:[function(require,module,exports){\nvar JsDocMaker = require('../core/class'); \nvar _ = require('underscore'); \n\n// NATIVE TYPES LINKING / post processing. Optional\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\nJsDocMaker.NATIVE_TYPES = ['String', 'Object', 'Array', 'Date', 'Regex', 'Function', \n\t'Boolean', 'Error', 'TypeError', 'Number']; \n\n//@method getNativeTypeUrl @returns {String}an url if given name match a native types or undefined otherwise\nJsDocMaker.prototype.getNativeTypeUrl = function(name)\n{\n\tif(_(JsDocMaker.NATIVE_TYPES).contains(name))\n\t{\n\t\treturn 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/' + name;\n\t}\n\n\tvar customTypeUrl;\n\t_(this.customNativeTypes).each(function(val, key)\n\t{\n\t\tif(key===name)\n\t\t{\n\t\t\t//TODO: support wildcard like $(name) for inserting the name in the given url dynamically\n\t\t\tcustomTypeUrl = val;\n\t\t}\n\t});\n\treturn customTypeUrl;\n}; \n\n},{\"../core/class\":3,\"underscore\":1}],17:[function(require,module,exports){\nvar JsDocMaker = require('../core/class'); \nvar _ = require('underscore'); \n\n//@method recurseAST An utility method that can be used in extensions to visit all the ast nodes with given function \n//@param {Function} fn\nJsDocMaker.prototype.recurseAST = function(fn)\n{\n\tvar self = this;\n\t_(self.data.classes).each(function(c)\n\t{\n\t\t_(c.methods).each(function(m)\n\t\t{\n\t\t\tfn.apply(m, [m]); \n\t\t\t//TODO: params\n\t\t}); \n\n\t\t_(c.properties).each(function(p)\n\t\t{\n\t\t\tfn.apply(p, [p]); \n\t\t}); \n\t\t//TODO: events\n\t});\n\t_(self.data.modules).each(function(m)\n\t{\n\t\tfn.apply(m, [m]); \n\t});\n}; \n\n\n},{\"../core/class\":3,\"underscore\":1}]},{},[10]);\n\n\n//@module shortjsdoc\n//@class AbstractView @extend Backbone.View @module shortjsdoc\n\nvar AbstractView = Backbone.View.extend({\n\n\ttagName: 'div'\n\n,\tinitialize: function(application) \n\t{\n\t\tthis.application = application;\n\t}\n\n\t//@method renderIn renders this view in given parent element @param {jQuery} $parent\n,\trenderIn: function($parent)\n\t{\n\t\tvar template = this.application.templates[this.template]; \n\t\tif(template)\n\t\t{\t\t\t\n\t\t\tvar html = template.apply(this, []); \n\t\t\tthis.$el.html(html);\n\t\t\t$parent.append(this.$el); \n\t\t}\n\t\tthis.afterRender();\n\t\treturn this;\n\t}\n\n\t//@method render implemented to comply with Backbone View contract\n,\trender: function()\n\t{\n\t\treturn this.renderIn(jQuery(this.el)); \n\t}\n\n\n,\tafterRender: function()\n\t{\n\t\tthis.renderSource(); \n\t}\n\n,\tsetTitle: function(t)\n\t{\n\t\t// var self = this;\n\t\tthis.title = t;\n\t\tsetTimeout(function()\n\t\t{\n\t\t\tdocument.title = t; \n\t\t}, 200);\n\t}\n});\n\n\n\n//@module shortjsdoc\n// this is the main class for all the application\n// utilities for rendering jsdoc data generated by jsdocgenerator1 js-indentator plugin\n// using backbone. The user should provide with underscore templates. \n// @class AbstractView @extend Backbone.View @module shortjsdoc\n// @author: sgurin\n\n//@class Application \n/*\n@constructor Application \n\n@param {Object} data is the data.json object outputed by running \n\t\n\tvar maker = new JsDocMaker();\n\tmaker.parseFile(myCodeString);\n\tmaker.postProccess();\n\tvar data = maker.data; \n*/\nvar Application = function(data)\n{\n\t//@property {String} textFormat  can be markdown or html. default: markdown\n\tthis.textFormat = 'markdown'; \n\t\n\t//@property {Object} templates The templates dictionary (given by template-output.js)\n\tthis.templates = shortjsdoc; \n\n\t/*@property {Object} data is the data.json object outputed by running:\t\n\n\t\tvar maker = new JsDocMaker();\n\t\tmaker.parseFile(myCodeString);\n\t\tmaker.postProccess();\n\t\tvar data = maker.data; \n\t*/\n\tthis.data = data; \n\n\n\t//@property {JsDocMaker} maker the JsDocMaker instance we will use for loading the parsed data and doing some post processing stage (type binding and so)\n\tthis.maker = new JsDocMaker();\n\tthis.maker.data = data;\t\n\n\tthis.maker.postProccess();\n\tthis.maker.postProccessBinding();\n\tthis.maker.postProccessInherited(); // <-- important - explicitly ask the framework to calculate inherited methods&properties\n\n\n\twindow.shortjsdocdata = data;//for debugging only\n\t\n\tif(jQuery('#mainContainer').size()===0)\n\t{\n\t\tjQuery('body').append('<div id=\"mainContainer\"></div>'); \n\t}\n\tthis.$containerEl = jQuery('#mainContainer'); \n};\n\n_(Application.prototype).extend({\n\n\t//@method start starts the application by instantiating routers and history and navigating to the index.\n\tstart: function()\n\t{\t\t\n\t\tthis.router = new JsDocRouter(this);\n\t\tBackbone.history.start();\n\t\tvar navigateTo = Backbone.history.getHash() || 'index'; \n\t\tBackbone.history.navigate(navigateTo, {trigger: true});\n\t}\n\n\t//@method showView @param {AbstractView} view\n,\tshowView: function(view)\n\t{\n\t\tthis.applicationView = this.applicationView || new ApplicationView(this); \n\t\tthis.currentView = view;\n\t\tthis.$containerEl.empty();\n\t\tthis.applicationView.renderIn(this.$containerEl);\n\t}\n\n\t//@method refreshWithNewModel @param {Object}data\n,\trefreshWithNewModel: function(data)\n\t{\n\t\tthis.data = data; \n\t\tBackbone.history.navigate('#index', {trigger: true}); \n\t\tthis.showView(this.currentView);\n\t}\n\n\t//@method showErrorView @param {String}s \n,\tshowErrorView: function(s) \n\t{\n\t\tthis.$containerEl.empty().append('<h1>'+s+'</h1>'); \n\t}\n\n});\n\n//@method start an application loading it with given data. @static\n//@param data the output of passing jsindentator JsDocMaker. \nApplication.startApplication = function(data)\n{\n\tvar app = new Application(data); \n\tapp.start();\n}; \n  \n\n//@module shortjsdoc\n//@class ApplicationView @extends AbstractView\nvar ApplicationView = AbstractView.extend({\n\n\tclassName: 'application-view'\n\n,\ttemplate: 'application'\n\n,\tinitialize: function(application) \n\t{\n\t\tthis.application = application;\n\t}\n\n,\trenderIn: function($el)\n\t{\n\t\tAbstractView.prototype.renderIn.apply(this, arguments); \n\n\t\tthis.headerView = this.headerView || new HeaderView(this.application);\n\t\tthis.headerView.renderIn(this.$('[data-type=\"header-container\"]')); \n\n\t\tthis.mainView = this.application.currentView; \n\n\t\tthis.mainView.renderIn(this.$('[data-type=\"main-view-container\"]')); \n\n\t\tdocument.title = this.title || window.location.href + '';\n\t}\n\n});\n\n//@module shortjsdoc\n//@class ClassView @extends AbstractView\n\nvar ClassView = AbstractView.extend({\n\n\tclassName: 'class-view'\n\n,\ttemplate: 'class'\n\n,\tinitialize: function(application, className, options) \n\t{\n\t\tthis.application = application;\n\t\tthis.jsdoc = this.application.data.classes[className]; \n\t\tif(!this.jsdoc)\n\t\t{\n\t\t\tthis.resourceNotFound = true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.jsdoc.textHtml = this.getTextHtml(this.jsdoc);\t\n\n\t\tthis.options = options || {};\n\t\tthis.options.inherited = this.options.inherited ? parseInt(this.options.inherited, 10) : 0;\n\n\t\tthis.methods = this.jsdoc.methods;\n\t\tif(this.options.inherited)\n\t\t{\n\t\t\tthis.methods = _(_(this.methods).clone()).extend(this.jsdoc.inherited.methods); \n\t\t}\n\n\t\tthis.properties = this.jsdoc.properties;\n\t\tif(this.options.inherited)\n\t\t{\n\t\t\tthis.properties = _(_(this.properties).clone()).extend(this.jsdoc.inherited.properties); \n\t\t}\n\t\t//TODO: I'm sorry for the following code:\n\t\tvar self = this; setTimeout(function(){document.title = self.jsdoc.name + 'Class ';}, 200);\n\t\t\n\t}\n\n/*\n,\tcomputeHierarchy: function()\n\t{\n\t\tvar hierarchy = [];\n\t\tvar c = this.jsdoc;\n\t\tdo \n\t\t{\n\t\t\thierarchy = [c].concat(hierarchy);\n\t\t\tif(c.name===this.jsdoc.name)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile( (c = c.extends) ); \n\t\treturn hierarchy;\n\t}\n*/\n});\n\n//@module shortjsdoc\n//@class HeaderView @extends AbstractView\nvar HeaderView = AbstractView.extend({\n\n\tclassName: 'header-view'\n\n,\ttemplate: 'header'\n\n,\tinitialize: function(application) \n\t{\n\t\tthis.application = application;\n\t}\n\t\n,\trenderIn: function()\n\t{\n\t\tAbstractView.prototype.renderIn.apply(this, arguments); \n\t\tthis.installTypeAhead();\n\t}\n\n,\tinstallTypeAhead: function()\n\t{\n\t\tthis.classes = this.application.data.classes;\n\t\tthis.modules = this.application.data.modules;\n\n\t\tthis.typeahead = $('.main-header .typeahead1').typeahead({\n\t\t\thint: true,\n\t\t\thighlight: true,\n\t\t\tminLength: 1\n\t\t},\t{\n\t\t\tname: 'jsdoc',\n\t\t\tdisplayKey: 'value',\n\t\t\tsource: this.substringMatcher()\n\t\t});\n\n\t\tvar self = this;\n\t\tthis.typeahead.on('typeahead:selected', function()\n\t\t{\n\t\t\tself.handleSearchSelection.apply(self, arguments);\n\t\t});\n\t}\n\n,\thandleSearchSelection: function(event, object, dataset)\n\t{\n\t\tvar href = this.makeLink(object.node);\n\t\tBackbone.history.navigate(href, {trigger: true}); \n\t}\n\n,\tsearch: function(q)\n\t{\n\t\tvar self=this,matches = []\n\n\t\t// regex used to determine if a string contains the substring `q`\n\t\t,\tsubstrRegex = new RegExp(q, 'i');\n\n\t\t// iterate through the pool of strings and for any string that\n\t\t// contains the substring `q`, add it to the `matches` array\n\t\t_(self.classes).each(function (c)\n\t\t{\n\t\t\tif (substrRegex.test(c.name)) \n\t\t\t{\n\t\t\t\tmatches.push({ value: c.name, node: c });\n\t\t\t}\n\t\t\t_(c.methods).each(function (m)\n\t\t\t{\n\t\t\t\tif (substrRegex.test(m.name)) \n\t\t\t\t{\n\t\t\t\t\tmatches.push({ value: m.name, node: m });\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}); \n\t\t}); \n\n\t\t_(self.modules).each(function (m)\n\t\t{\n\t\t\tif (substrRegex.test(m.name)) \n\t\t\t{\n\t\t\t\tmatches.push({ value: m.name, node: m });\n\t\t\t}\n\t\t}); \n\n\t\treturn matches;\n\t}\n\n,\tsubstringMatcher: function() \n\t{\n\t\tvar self = this;\n\t\treturn function findMatches(q, cb) \n\t\t{\n\t\t\tvar matches;\n\t\t\t// an array that will be populated with substring matches\n\t\t\tmatches = self.search(q);\t\t\t\n\t\t\tcb(matches);\n\t\t};\n\t}\n\n});\n\n\n//@module shortjsdoc\n//@class IndexView @extends AbstractView\nvar IndexView = AbstractView.extend({\n\n\tclassName: 'index'\n\n,\ttemplate: 'index'\n\n});\n\n//@module shortjsdoc\n//@class JsDocRouter @extends BackboneRouter\nvar JsDocRouter = Backbone.Router.extend({\n\n\troutes: {\n\t\t'class/:class': 'showClass'\n\t,\t'class/:class?:options': 'showClass'\n\n\t,\t'module/:module': 'showModule'\n\n\t,\t'method/:method': 'showMethod'\n\t,\t'constructor/:method': 'showMethod'\n\n\t,\t'property/:property': 'showProperty'\n\t,\t'event/:event': 'showEvent'\n\n\t,\t'index': 'showIndex'\n\t,\t'modules': 'showModules'\n\t,\t'classes': 'showClasses'\n\n\t,\t'parse': 'showParse'\n\t}\n\n,\tinitialize: function(application) \n\t{\n\t\tthis.application=application;\n\t}\n\n\t//@method showView @param {AbstractView}view @param {String} resourceName\n,\tshowView: function(view, resourceName)\n\t{\n\t\tresourceName = resourceName||'Resource'; \n\t\tif(view.resourceNotFound)\n\t\t{\n\t\t\tthis.application.showErrorView(resourceName+' '+resourceName+' not found!'); \n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.application.showView(view); \n\t\t}\n\t}\n\n\t//@method showModule  @param {String} moduleName\n,\tshowModule: function(moduleName) \n\t{\n\t\tvar view = new ModuleView(this.application, moduleName);\n\t\tthis.showView(view); \n\t}\n\n\t//method parseOptions @return {Object<String,String>}\n,\tparseOptions: function(options)\n\t{\n\t\tvar params = {};\n\t\t_(options.split('&')).each(function(p)\n\t\t{\n\t\t\tvar a = p.split('='); \n\t\t\tif (a.length >= 2)\n\t\t\t{\n\t\t\t\tparams[a[0]] = a[1]; \n\t\t\t}\n\t\t}); \n\t\treturn params;\n\t}\n\n\t//@method showClass  @param {String} className\n,\tshowClass: function(className, options) \n\t{\n\t\toptions = options || '';\n\t\tvar params = this.parseOptions(options);\t\t\n\t\tvar view = new ClassView(this.application, className, params);\n\t\tthis.showView(view); \n\t}\n\n\t//@method showMethod  @param {String} method\n,\tshowMethod: function(method)\n\t{\n\t\tvar view = new MethodView(this.application, method);\n\t\tthis.showView(view); \n\t}\n\n\t//@method showProperty  @param {String} property\n,\tshowProperty: function(property)\n\t{\n\t\tvar view = new PropertyView(this.application, property);\n\t\tthis.showView(view); \n\t}\n\n\t//@method showEvent  @param {String} event\n,\tshowEvent: function(event)\n\t{\n\t\tvar view = new PropertyView(this.application, event, true);\n\t\tthis.showView(view); \n\t}\n\n\t//@method showModules\n,\tshowModules: function()\n\t{\n\t\tvar view = new AbstractView(this.application);\n\t\tview.template = 'modules';\n\t\tthis.showView(view);\n\t}\n\t\n\t//@method showClasses\n,\tshowClasses: function()\n\t{\n\t\tvar view = new AbstractView(this.application);\n\t\tview.template = 'classes';\n\t\tthis.showView(view);\n\t}\n\t\n\t//@method showIndex\n,\tshowIndex: function() \n\t{\n\t\tvar view = new IndexView(this.application);\n\t\tthis.application.showView(view); \n\t}\n\n\t//@method showParse\n,\tshowParse: function() \n\t{\n\t\tvar view = new ParseView(this.application);\n\t\tthis.application.showView(view); \n\t}\n\n});\n\n\n//@module shortjsdoc\n//@class MethodView @extends AbstractView\nvar MethodView = AbstractView.extend({\n\n\tclassName: 'method-view'\n\n,\ttemplate: 'method'\n\n,\tinitialize: function(application, methodName) \n\t{\n\t\tthis.application = application;\n\n\t\tvar className = this.getClassName(methodName);\n\t\t// var propertySimpleName = a[2];\n\t\tvar methodSimpleName = this.getSimpleName(methodName);\n\t\t\n\t\t// var a = methodName.split('.');\n\t\t// var className = a[0] + '.' + a[1]; \n\t\tvar class_ = this.application.data.classes[className];\n\t\t// var methodSimpleName = a[2];\n\t\tif(!isNaN(parseInt(methodSimpleName, 10)))\n\t\t{\n\t\t\tthis.jsdoc = class_.constructors[parseInt(methodSimpleName, 10)]; \n\t\t\tthis.isConstructor = true;\n\t\t}\n\t\telse\n\t\t{\t\t\t\n\t\t\tthis.jsdoc = class_.methods[methodSimpleName]; \n\t\t\tthis.isConstructor = false;\n\t\t}\n\t\tif(!this.jsdoc)\n\t\t{\n\t\t\tthis.resourceNotFound = true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.jsdoc.textHtml = this.getTextHtml(this.jsdoc);\n\t\tthis.ownerClass = this.application.data.classes[this.jsdoc.ownerClass]; \n\t}\n\n});\n\n\n\n//@module shortjsdoc\n//@class ModuleView @extends AbstractView\nvar ModuleView = AbstractView.extend({\n\n\tclassName: 'module'\n\n,\ttemplate: 'module'\n\n,\tinitialize: function(application, moduleName) \n\t{\n\t\tthis.application = application;\n\t\tthis.jsdoc = this.application.data.modules[moduleName]; \n\t\tthis.classes = _( _(this.application.data.classes).values() ).filter(function(c){\n\t\t\treturn c.module.name === moduleName; \n\t\t}); \n\t\t\n\t\tthis.jsdoc.textHtml = this.getTextHtml(this.jsdoc);\t\n\t}\n\n});\n\n//@module shortjsdoc\n//@class ParseView @extends AbstractView\nvar ParseView = AbstractView.extend({\n\n\tclassName: 'parse'\n\n,\tevents: {\n\t\t'click [data-action=\"inputcode_doit\"]': 'inputCodeDoit'\n\t}\n\n,\ttemplate: 'parse'\n\n,\tinputCodeDoit: function()\n\t{\n\t\tvar code = this.$('[data-type=\"inputcode\"]').val();\n\t\tvar maker = this.application.maker;\n\t\tmaker.parseFile(code, 'textarea');\t\t\n\t\tmaker.postProccess();\n\t\t//console.log(JSON.stringify(maker.data));\n\t\tmaker.postProccessBinding();\n\t\tthis.application.refreshWithNewModel(maker.data);\n\t\t// \n\t}\n\n});\n\n//@module shortjsdoc\n//@class PropertyView @extends AbstractView\nvar PropertyView = AbstractView.extend({\n\n\tclassName: 'property-view'\n\n,\ttemplate: 'property'\n\n,\tinitialize: function(application, propertyName, isEvent) \n\t{\n\t\tthis.application = application;\n\t\tthis.isEvent = isEvent;\n\t\t// var a = propertyName.split('.');\n\t\t// var className = a[0] + '.' + a[1]; \n\t\tvar className = this.getClassName(propertyName);\n\t\t// var propertySimpleName = a[2];\n\t\tvar propertySimpleName = this.getSimpleName(propertyName);\n\n\t\tvar class_ = this.application.data.classes[className];\n\t\tthis.jsdoc = isEvent ? class_.events[propertySimpleName] : class_.properties[propertySimpleName];\n\t\tif(!this.jsdoc)\n\t\t{\n\t\t\tthis.resourceNotFound = true;\n\t\t\treturn;\n\t\t}\n\n\t\tthis.jsdoc.textHtml = this.getTextHtml(this.jsdoc);\t\t\n\t}\n\n\n});\n\n\n\n//@module shortjsdoc\n//@class SourcesView @extends AbstractView\nvar SourcesView = AbstractView.extend({\n\n\tclassName: 'sources'\n\n,\ttemplate: 'sources'\n\n,\tevents: {\n\t\t'click [data-type=\"goto-source\"]': 'gotoSource'\n\t}\n\n,\tinitialize: function(application, jsdoc)\n\t{\n\t\tthis.application = application;\n\t\tthis.jsdoc = jsdoc;\n\t\tthis.allSource = this.application.maker.data.source; \n\n\t\tvar rangeRatio = 400;\n\t\tvar rangeMin = Math.max(0, this.jsdoc.commentRange[0] - rangeRatio);\n\t\tvar rangeMax = Math.min(this.allSource.length - 1, this.jsdoc.commentRange[1] + rangeRatio);\n\t\tthis.sourceSubset = this.allSource.substring(rangeMin, rangeMax);\n\t\tvar jsdocSource = this.allSource.substring(this.jsdoc.commentRange[0], this.jsdoc.commentRange[1]); \n\t\tvar previusSource = this.sourceSubset.substring(0, this.sourceSubset.indexOf(jsdocSource));\n\t\tvar previusSourceLineCount = previusSource.split('\\n').length; \n\n\t\tthis.jsdocLineNumber = previusSourceLineCount - 1;\n\n\t\tthis.lineCount = jsdocSource.split('\\n').length; \n\n\t\t//TODO: count the lines of the comment and show all the lines - not only the first one\n\t}\n\n,\tafterRender: function()\n\t{\n\t\tif(typeof prettyPrint !== 'undefined') \n\t\t{\n\t\t\tprettyPrint();\n\t\t}\n\t}\n\n,\tgotoSource: function()\n\t{\n\t\tvar selector = 'ol.linenums>li'\n\t\t,\t$target = jQuery(jQuery(selector).get(this.jsdocLineNumber));\n\t\tif($target.size())\n\t\t{\n\t\t\tjQuery(window).scrollTop($target.position().top);\n\t\t\t$target.addClass('selectedJsDocLine'); \n\t\t}\n\n\t\tfor (var i = 0; i < this.lineCount; i++) \n\t\t{\n\t\t\t$target = jQuery(jQuery(selector).get(this.jsdocLineNumber+i));\n\t\t\t$target.addClass('selectedJsDocLine'); \n\t\t}\n\t}\n});\n\n//@module shortjsdoc\n// this file add methods to Abstract Application for dealing with types and html markup. \n// @class AbstractView @extends BackboneView\n\n_(AbstractView.prototype).extend({\n\n\t//@method printTag\n\tprintTag: function(text, classAttribute, tag) {\n\t\ttag = tag || 'span'; \n\t\tclassAttribute = classAttribute ||'';\n\t\tif(text)\n\t\t{\n\t\t\treturn '<'+tag+ (classAttribute?(' class=\"'+classAttribute+'\"'):'') +'>'+text+'</'+tag+'>'; \n\t\t}\n\t\treturn '';\n\t}\n\n\t//@method simpleName @param {String}name\n,\tsimpleName: function(name)\n\t{\n\t\treturn this.application.maker.simpleName(name);\n\t}\n\n\t//@method makeLink @param {boolean} htmlAnchors will output anchor elements html\n,\tmakeLink: function(node, htmlAnchors)\n\t{\n\t\t// if (!node || !node.type) // no type for this node. This isn't undefined ! This means we just simply doesn't have the information.\n\t\t// {\n\t\t//\treturn '';\n\t\t// }\n\t\tvar className = node.annotation + '-name'; \n\t\tvar s = htmlAnchors ? ('<a class=\"' + className + '\" href=\"') : '';\n\t\tif(node.annotation==='method')\n\t\t{\n\t\t\ts += '#method/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='constructor')\n\t\t{\t\t\t\n\t\t\ts += '#constructor/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='property')\n\t\t{\n\t\t\ts += '#property/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='event')\n\t\t{\n\t\t\ts += '#event/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='class')\n\t\t{\n\t\t\ts += '#class/' + node.absoluteName; \n\t\t}\n\t\telse if(node.annotation==='module')\n\t\t{\n\t\t\ts += '#module/' + node.name; \n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn '';\n\t\t}\n\n\t\ts += htmlAnchors?('\">'+node.name+'</a>'):'';\n\t\treturn s;\n\t}\n\n,\tprintLiteralObjectType: function(context)\n\t{\n\n\t\tvar self = this;\n\t\tvar buf = []; \n\t\tcontext.buffer.push(this.printType(context.type, true));\n\t\tif(context.type.name==='Object')\n\t\t{\n\t\t\tcontext.buffer.push('{')\n\t\t\t_(context.type.properties).each(function(value, key)\n\t\t\t{\n\t\t\t\tbuf.push(key + ': ' + self.printSingleTypeAsString(value, true));\n\t\t\t}); \n\t\t}\n\t\tcontext.buffer.push(buf.join(', '));\n\t\tif(context.type.name==='Object')\n\t\t{\n\t\t\tcontext.buffer.push('}'); \n\t\t}\n\t}\n\t\n\t// @method printType prints a type as html support generic. This is really a html template function\n\t// @param {Object}context  @return {String} the type html\n,\tprintType: function(context, ignoreLiteralObject)\n\t{\n\t\tif(!context || !context.type)\n\t\t{\n\t\t\treturn ''; \n\t\t}\n\n\t\tvar self = this;\n\t\tvar href = context.type.nativeTypeUrl || '#class/'+context.type.absoluteName; \n\t\tvar htmlText = context.type.name; \n\t\tvar aclass = (context.type.nativeTypeUrl ? ' type external ' : ' type ');\n\t\tvar iconHtml = context.type.nativeTypeUrl ? '<span class=\"glyphicon glyphicon-share\"></span>' : ''; \n\n\t\tcontext.buffer.push('<a class=\"'+aclass+'\" href=\"'+href+'\">'+iconHtml+htmlText+'</a>');\n\n\t\tif(context.type.properties && !ignoreLiteralObject)\n\t\t{\n\t\t\tthis.printLiteralObjectType(context); \n\t\t}\n\n\t\telse if(context.type.params) \n\t\t{ \n\t\t\tcontext.buffer.push('&lt;');\n\t\t\tfor (var i = 0; i < (context.type.params||[]).length; i++) \n\t\t\t{\n\t\t\t\tvar param = context.type.params[i]; \n\t\t\t\tself.printType({ //recurse!\n\t\t\t\t\ttype:param\n\t\t\t\t,\tbuffer: context.buffer\n\t\t\t\t});\n\t\t\t\tif(i < context.type.params.length - 1)\n\t\t\t\t{\n\t\t\t\t\tcontext.buffer.push(','); \n\t\t\t\t}\n\t\t\t}\n\t\t\tcontext.buffer.push('>'); \n\t\t} \n\t}\n\n\t//@method printTypeAsString this is the public method for printing a type - supports any type @param {String} type @return {String}  @return {String} the type html\n,\tprintSingleTypeAsString: function(type, dontRecurse)\n\t{\n\t\tvar buffer = [];\n\t\tvar context = {type: type, typeTemplate: this.printType, buffer: buffer}; \n\n\t\tthis.printType(context); \n\t\tvar typeOutput = buffer.join(''); \n\t\treturn typeOutput; \n\t}\n\t//@method printTypeAsString @param {Array<Type>|Type} type @return {String} the type html\n,\tprintTypeAsString: function(type)\n\t{\n\t\tvar self = this;\n\t\tif(_(type).isArray())\n\t\t{\n\t\t\tvar a = [];\n\t\t\t_(type).each(function(t)\n\t\t\t{\n\t\t\t\ta.push(self.printSingleTypeAsString(t));\n\t\t\t}); \n\t\t\treturn a.join('<span class=\"type-separator\">or</span>'); \n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this.printSingleTypeAsString(type); \n\t\t}\n\t}\n\t//@method getTextHtml depends on lib/marked/ - all texts should be printed using this method\n,\tgetTextHtml: function(node)\n\t{\n\t\tif(!node || !node.text)\n\t\t{\n\t\t\treturn '';\n\t\t}\n\t\tvar text = node.text\n\t\t,\ttype = this.application.textFormat\n\t\t,\thtml = _(node.children).find(function(c){return c.annotation==='html'; })\n\t\t,\tmarkdown = _(node.children).find(function(c){return c.annotation==='markdown'; });\n\t\t\n\t\tif(html)\n\t\t{\n\t\t\ttype = 'html'; \n\t\t}\n\t\tif(markdown)\n\t\t{\n\t\t\ttype = 'markdown'; \n\t\t}\n\n\t\tif(type === 'markdown')\n\t\t{\n\t\t\treturn marked(text); \n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn text; \n\t\t}\n\t}\n\n\t//@method printMethod\n,\tprintMethod: function(m)\n\t{\n\t\tvar isConstructor = m.annotation==='constructor'; \n\t\tvar s = '<span class=\"method\">';\n\t\tvar methodName = isConstructor ? this.simpleName(m.ownerClass) : m.name;\n\t\tif(!isConstructor && m.returns)\n\t\t{\n\t\t\ts += this.printTypeAsString(m.returns) + '&nbsp;'; \n\t\t}\n\n\t\ts += '<a href=\"' + this.makeLink(m) + '\">' + methodName + '</a>'; \n\n\t\treturn s + '</span>';\n\t}\n\n,\trenderSource_: function(jsdoc, $container)\n\t{\n\t\tvar view = new SourcesView(this.application, jsdoc); \n\t\tview.renderIn($container); \n\t}\n\n\n,\trenderSource: function()\n\t{\n\t\tif(!this.jsdoc)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tthis.renderSource_(this.jsdoc, this.$('[data-type=\"sources\"]')); \n\t\tthis.$('pre code').addClass('prettyprint'); \n\t\tif(typeof prettyPrint !== 'undefined') \n\t\t{\n\t\t\tprettyPrint('pre code');\n\t\t}\n\t}\n\t\n,\tgetInherited: function(c, what)\n\t{\n\t\tvar data = {};\n\t\tif(what==='method')\n\t\t{\n\t\t\tdata = _(c.methods).clone();\n\t\t\t_(data).extend(c.inherited.methods || {});\n\t\t}\n\t\treturn data;\n\t}\n\t\n,\tgetClassName: function(absoluteName)\n\t{\n\t\treturn absoluteName.substring(0, absoluteName.lastIndexOf('.'));\n\t}\n\n,\tgetSimpleName: function(absoluteName)\n\t{\n\t\treturn absoluteName.substring(absoluteName.lastIndexOf('.')+1, absoluteName.length); \n\t}\n\n,\tgetModuleClasses: function(moduleName, data)\n\t{\n\t\tvar a = [];\n\t\t// return a;//data ; //return this.application.data.classes;\n\t\t_(data.classes).each(function(c)\n\t\t{\n\t\t\tif(c.absoluteName.indexOf(moduleName)===0)\n\t\t\t{\n\t\t\t\ta.push(c); \n\t\t\t}\n\t\t});\n\t\treturn a;\n\t}\n\n});\n\nmain.js\n\n/*\n@module javascript\n@class Boolean\n\n#Summary\nThe Boolean object is an object wrapper for a boolean value.\n\n#Constructor\n\tnew Boolean(value)\n\n#Description\nThe value passed as the first parameter is converted to a boolean value, if necessary. If value is omitted or is 0, -0, null, false, NaN, undefined, or the empty string (\"\"), the object has an initial value of false. All other values, including any object or the string \"false\", create an object with an initial value of true.\n\nDo not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.\n\nAny object whose value is not undefined or null, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement. For example, the condition in the following if statement evaluates to true:\n\n\tx = new Boolean(false);\n\tif (x) {\n\t  // . . . this code is executed\n\t}\n\tThis behavior does not apply to Boolean primitives. For example, the condition in the following if statement evaluates to false:\n\n\tx = false;\n\tif (x) {\n\t  // . . . this code is not executed\n\t}\nDo not use a Boolean object to convert a non-boolean value to a boolean value. Instead, use Boolean as a function to perform this task:\n\n\tx = Boolean(expression);     // preferred\n\tx = new Boolean(expression); // don't use\n\tIf you specify any object, including a Boolean object whose value is false, as the initial value of a Boolean object, the new Boolean object has a value of true.\n\n\tmyFalse = new Boolean(false);   // initial value of false\n\tg = new Boolean(myFalse);       // initial value of true\n\tmyString = new String(\"Hello\"); // string object\n\ts = new Boolean(myString);      // initial value of true\n\tDo not use a Boolean object in place of a Boolean primitive.\n\n#Properties\nFor properties available on Boolean instances, see Properties of Boolean instances.\n\nBoolean.length\nLength property whose value is 1.\nBoolean.prototype\nRepresents the prototype for the Boolean constructor.\n#Properties inherited from Function:\narity, caller, constructor, length, name\n##Methods\nFor methods available on Boolean instances, see Methods of Boolean instances.\n\nThe global Boolean object contains no methods of its own, however, it does inherit some methods through the prototype chain:\n\n#Methods inherited from Function:\napply, call, toSource, toString\n\n#Boolean instances\nAll Boolean instances inherit from Boolean.prototype. As with all constructors, the prototype object dictates instances' inherited properties and methods.\n\n#Properties\n\nBoolean.prototype.constructor\nReturns the function that created an instance's prototype. This is the Boolean function by default.\nProperties inherited from Object:\n__parent__, __proto__\n#Methods\n\nBoolean.prototype.toSource() \nReturns a string containing the source of the Boolean object; you can use this string to create an equivalent object. Overrides the Object.prototype.toSource() method.\nBoolean.prototype.toString()\nReturns a string of either \"true\" or \"false\" depending upon the value of the object. Overrides the Object.prototype.toString() method.\nBoolean.prototype.valueOf()\nReturns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.\n\n\n#Examples\nCreating Boolean objects with an initial value of false\n\n\tvar bNoParam = new Boolean();\n\tvar bZero = new Boolean(0);\n\tvar bNull = new Boolean(null);\n\tvar bEmptyString = new Boolean(\"\");\n\tvar bfalse = new Boolean(false);\n\tCreating Boolean objects with an initial value of true\n\n\tvar btrue = new Boolean(true);\n\tvar btrueString = new Boolean(\"true\");\n\tvar bfalseString = new Boolean(\"false\");\n\tvar bSuLin = new Boolean(\"Su Lin\");\n\n\n*/\n\n\n/*\n@method valueOf\n#Summary\nThe valueOf() method returns the primitive value of a Boolean object.\n\n#Syntax\n\tbool.valueOf()\n\n#Description\nThe valueOf method of Boolean returns the primitive value of a Boolean object or literal Boolean as a Boolean data type.\n\nThis method is usually called internally by JavaScript and not explicitly in code.\n\n#Examples\n##Example: Using valueOf\n\n\tx = new Boolean();\n\tmyVar = x.valueOf()      // assigns false to myVar\n*/\n\n/*\n@module javascript\n@class Error\n\n#Summary\nThe Error constructor creates an error object. Instances of Error objects are thrown when runtime errors occur. The Error object can also be used as a base objects for user-defined exceptions. See below for standard built-in error types.\n\n#Syntax\n\tnew Error([message[, fileName[,lineNumber]]])\n#Description\nRuntime errors result in new Error objects being created and thrown.\n\nThis page documents the use of the Error object itself and its use as a constructor function. For a list of properties and methods inherited by Error instances, see Error.prototype.\n\n#Error types\n\nBesides the generic Error constructor, there are six other core error constructors in JavaScript. For client-side exceptions, see Exception Handling Statements.\n\n\tEvalError\n\tCreates an instance representing an error that occurs regarding the global function eval().\n\tInternalError \n\tCreates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. \"too much recursion\".\n\tRangeError\n\tCreates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.\n\tReferenceError\n\tCreates an instance representing an error that occurs when de-referencing an invalid reference.\n\tSyntaxError\n\tCreates an instance representing a syntax error that occurs while parsing code in eval().\n\tTypeError\n\tCreates an instance representing an error that occurs when a variable or parameter is not of a valid type.\n\tURIError\n\tCreates an instance representing an error that occurs when encodeURI() or decodeURl() are passed invalid parameters.\n\n#Properties\nError.prototype\nAllows the addition of properties to Error instances.\n#Methods\nThe global Error object contains no methods of its own, however, it does inherit some methods through the prototype chain.\n\n#Error instances\nAll Error instances and instances of non-generic errors inherit from Error.prototype. As with all constructor functions, you can use the prototype of the constructor to add properties or methods to all instances created with that constructor.\n\n#Properties\n\n##Standard properties\n\nError.prototype.constructor\nSpecifies the function that created an instance's prototype.\n\tError.prototype.message\n\tError message.\n\tError.prototype.name\n\tError name.\n\n\n#Vendor-specific extensions\n\n##Non-standard\nThis feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.\n##Microsoft\n\n\tError.prototype.description\n\tError description. Similar to message.\n\tError.prototype.number\n\tError number.\n##Mozilla\n\n\tError.prototype.fileName\n\tPath to file that raised this error.\n\tError.prototype.lineNumber\n\tLine number in file that raised this error.\n\tError.prototype.columnNumber\n\tColumn number in line that raised this error.\n\tError.prototype.stack\n\tStack trace.\n\n#Examples\n##Example: Throwing a generic error\n\nUsually you create an Error object with the intention of raising it using the throw keyword. You can handle the error using the try...catch construct:\n\n\ttry {\n\t  throw new Error(\"Whoops!\");\n\t} catch (e) {\n\t  alert(e.name + \": \" + e.message);\n\t}\n\tExample: Handling a specific error\n\n\tYou can choose to handle only specific error types by testing the error type with the error's constructor property or, if you're writing for modern JavaScript engines, instanceof keyword:\n\n\ttry {\n\t  foo.bar();\n\t} catch (e) {\n\t  if (e instanceof EvalError) {\n\t    alert(e.name + \": \" + e.message);\n\t  } else if (e instanceof RangeError) {\n\t    alert(e.name + \": \" + e.message);\n\t  }\n\t  // ... etc\n\t}\n##Custom Error Types\n\nYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. The common way to do this is demonstrated below.\n\nNote that the thrown MyError will report incorrect lineNumber and fileName at least in Firefox.\nSee also the \"What's a good way to extend Error in JavaScript?\" discussion on Stackoverflow.\n\n\t// Create a new object, that prototypally inherits from the Error constructor.\n\tfunction MyError(message) {\n\t  this.name = \"MyError\";\n\t  this.message = message || \"Default Message\";\n\t}\n\tMyError.prototype = new Error();\n\tMyError.prototype.constructor = MyError;\n\n\ttry {\n\t  throw new MyError();\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"Default Message\"\n\t}\n\n\ttry {\n\t  throw new MyError(\"custom message\");\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"custom message\"\n\t}\n\n*/\n\n/*\n\n@constructor Boolean\n@param {String} message Human-readable description of the error\n@param {String} fileName The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.\n@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation.\n*/\n\n\n\n/*\n@property {String} message\n\n#Summary\nThe message property is a human-readable description of the error.\n\n#Description\nThis property contains a brief description of the error if one is available or has been set. SpiderMonkey makes extensive use of the message property for exceptions. The message property combined with the name property is used by the Error.prototype.toString() method to create a string representation of the Error.\n\nBy default, the message property is an empty string, but this behavior can be overridden for an instance by specifying a message as the first argument to the Error constructor.\n\n#Examples\n##Example: Throwing a custom error\n\n\tvar e = new Error(\"Could not parse input\"); // e.message is \"Could not parse input\"\n\tthrow e;\n*/\n\n\n\n\n\n/*\n@property {String} name\n#Summary\nThe name property represents a name for the type of error. The initial value is \"Error\".\n\n#Description\nBy default, Error instances are given the name \"Error\". The name property, in addition to the message property, is used by the Error.prototype.toString() method to create a string representation of the error.\n\n#Examples\n##Example: Throwing a custom error\n\n\tvar e = new Error(\"Malformed input\"); // e.name is \"Error\"\n\n\te.name = \"ParseError\"; \n\tthrow e;\n\t// e.toString() would return \"ParseError: Malformed input\"\n\n*/\n\n\n\n\n/*\n@class EvalError @extends Error\nThe EvalError object indicates an error regarding the global eval() function.\n*/\n\n/*\n@class RangeError @extends Error\n\nThe RangeError object indicates an error when a value is not in the set or range of allowed values.\n\nA RangeError is thrown when trying to pass a number as an argument to a function that does not allow a range that includes that number. This can be encountered when to create an array of an illegal length with the Array constructor, or when passing bad values to the numeric methods Number.toExponential(), Number.toFixed() or Number.toPrecision().\n*/\n\n\n/*\n@class ReferenceError @extends Error\n#Summary\nThe ReferenceError object represents an error when a non-existent variable is referenced.\n\n#Description\nA ReferenceError is thrown when trying to dereference a variable that has not been declared.\n*/\n\n\n\n/*\n@class SyntaxError @extends Error\n\n#Summary\nThe SyntaxError object represents an error when trying to interpret syntactically invalid code.\n\n#Description\nA SyntaxError is thrown when the JavaScript engine encounters tokens or token order that does not conform to the syntax of the language when parsing code.\n*/\n\n\n/*\n@class TypeError @extends Error\nThe TypeError object represents an error when a value is not of the expected type.\n*/\n\n/*\n@class URIError @extends Error\n\nThe URIError object represents an error when a global URI handling function was used in a wrong way.\n*/\n\n\n/*\n@module javascript\n\n@class Function\n\n#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.\n*/\n\n\n/*\n@property {Number} length\n\n#Summary\nThe length property specifies the number of arguments expected by the function.\n\n#Description\nlength is a property of a function object, and indicates how many arguments the function expects, i.e. the number of formal parameters. This number does not include the rest parameter. By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.\n\nData property of the Function constructor\n\nThe Function constructor is itself a Function object. It's length data property has a value of 1. The property attributes are: Writable: false, Enumerable: false, Configurable: true.\n\nProperty of the Function prototype object\n\nThe length property of the Function prototype object has a value of 0.\n\n#Examples\n\tconsole.log ( Function.length ); //1\n\n\tconsole.log( (function ()        {}).length ); //0\n\tconsole.log( (function (a)       {}).length ); //1\n\tconsole.log( (function (a, b)    {}).length ); //2 etc. \n\tconsole.log( (function (...args) {}).length ); //0, rest parameter is no\n\n*/\n\n\n/*\n@property {FunctionPrototype} prototype\n#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.\n*/\n\n\n\n/*\n@method apply\n\nThe apply() method calls a function with a given this value and arguments provided as an array (or an array-like object).\n\nNote: While the syntax of this function is almost identical to that of call(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.apply(thisArg, [argsArray])\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object. With apply, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\napply is very similar to call(), except for the type of arguments it supports. You can use an arguments array instead of a named set of parameters. With apply, you can use an array literal, for example, fun.apply(this, ['eat', 'bananas']), or an Array object, for example, fun.apply(this, new Array('eat', 'bananas')).\n\nYou can also use arguments for the argsArray parameter. arguments is a local variable of a function. It can be used for all unspecified arguments of the called object. Thus, you do not have to know the arguments of the called object when you use the apply method. You can use arguments to pass all the arguments to the called object. The called object is then responsible for handling the arguments.\n\nSince ECMAScript 5th Edition you can also use any kind of object which is array-like, so in practice this means it's going to have a property length and integer properties in the range [0...length). As an example you can now use a NodeList or a own custom object like {'length': 2, '0': 'eat', '1': 'bananas'}.\n\nNote: Most browsers, including Chrome 14 and Internet Explorer 9, still do not accept array-like objects and will throw an exception.\n#Examples\nUsing apply to chain constructors\n\nYou can use apply to chain constructors for an object, similar to Java. In the following example we will create a global Function method called construct, which will make you able to use an array-like object with a constructor instead of an arguments list.\n\n\tFunction.prototype.construct = function (aArgs) {\n\t    var fConstructor = this, fNewConstr = function () { fConstructor.apply(this, aArgs); };\n\t    fNewConstr.prototype = fConstructor.prototype;\n\t    return new fNewConstr();\n\t};\n\nExample usage:\n\n\tfunction MyConstructor () {\n\t    for (var nProp = 0; nProp < arguments.length; nProp++) {\n\t        this[\"property\" + nProp] = arguments[nProp];\n\t    }\n\t}\n\n\tvar myArray = [4, \"Hello world!\", false];\n\tvar myInstance = MyConstructor.construct(myArray);\n\n\talert(myInstance.property1); // alerts \"Hello world!\"\n\talert(myInstance instanceof MyConstructor); // alerts \"true\"\n\talert(myInstance.constructor); // alerts \"MyConstructor\"\n\nNote: This non-native Function.construct method will not work with some native constructors (like Date, for example). In these cases you have to use the Function.bind method (for example, imagine to have an array like the following, to be used with Date constructor: [2012, 11, 4]; in this case you have to write something like: new (Function.prototype.bind.apply(Date, [null].concat([2012, 11, 4])))() – anyhow this is not the best way to do things and probably should not be used in any production environment).\nUsing apply and built-in functions\n\nClever usage of apply allows you to use built-ins functions for some tasks that otherwise probably would have been written by looping over the array values. As an example here we are going to use Math.max/Math.min to find out the maximum/minimum value in an array.\n\n\t//min/max number in an array \n\tvar numbers = [5, 6, 2, 3, 7];\n\n\t//using Math.min/Math.max apply \n\tvar max = Math.max.apply(null, numbers); // This about equal to Math.max(numbers[0], ...) or Math.max(5, 6, ..) \n\tvar min = Math.min.apply(null, numbers);\n\n\t/ vs. simple loop based algorithm \n\tmax = -Infinity, min = +Infinity;\n\n\tfor (var i = 0; i < numbers.length; i++) {\n\t  if (numbers[i] > max)\n\t    max = numbers[i];\n\t  if (numbers[i] < min) \n\t    min = numbers[i];\n\t}\n\nBut beware: in using apply this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (think more than tens of thousands of arguments) vary across engines (JavaScriptCore has hard-coded argument limit of 65536), because the limit (indeed even the nature of any excessively-large-stack behavior) is unspecified. Some engines will throw an exception. More perniciously, others will arbitrarily limit the number of arguments actually passed to the applied function. (To illustrate this latter case: if such an engine had a limit of four arguments [actual limits are of course significantly higher], it would be as if the arguments 5, 6, 2, 3 had been passed to apply in the examples above, rather than the full array.) If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:\n\n\tfunction minOfArray(arr) {\n\t  var min = Infinity;\n\t  var QUANTUM = 32768;\n\n\t  for (var i = 0, len = arr.length; i < len; i += QUANTUM) {\n\t    var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len)));\n\t    min = Math.min(submin, min);\n\t  }\n\n\t  return min;\n\t}\n\n\tvar min = minOfArray([5, 6, 2, 3, 7]);\nUsing apply in \"monkey-patching\"\n\nApply can be the best way to monkey-patch a builtin function of Firefox, or JS libraries. Given someobject.foo function, you can modify the function in a somewhat hacky way, like so:\n\n\tvar originalfoo = someobject.foo;\n\tsomeobject.foo = function() {\n\t  //Do stuff before calling function\n\t  console.log(arguments);\n\t  //Call the function as it would have been called normally:\n\t  originalfoo.apply(this,arguments);\n\t  //Run stuff after, here.\n\t}\n\nThis method is especially handy where you want to debug events, or interface with something that has no API like the various .on([event]... events, such as those usable on the Devtools Inspector).\n\n\n@param {Object}thisArg The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.\n@param {Array} argsArray An array-like object, specifying the arguments with which fun should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.\n\n@returns the result of evaluating this function with given context and parameters\n*/\n\n\n\n\n\n\n\n/*\n@method bind\n\n#Summary\nThe bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.\n\n#Syntax\n\tfun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nThe bind() function creates a new function (a bound function) with the same function body (internal call property in ECMAScript 5 terms) as the function it is being called on (the bound function's target function) with the this value bound to the first argument of bind(), which cannot be overridden. bind() also accepts leading default arguments to provide to the target function when the bound function is called. A bound function may also be constructed using the new operator: doing so acts as though the target function had instead been constructed. The provided this value is ignored, while prepended arguments are provided to the emulated function.\n\n#Examples\nCreating a bound function\n\nThe simplest use of bind() is to make a function that, no matter how it is called, is called with a particular this value. A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g. by using that method in callback-based code). Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:\n\n\tthis.x = 9; \n\tvar module = {\n\t  x: 81,\n\t  getX: function() { return this.x; }\n\t};\n\n\tmodule.getX(); // 81\n\n\tvar getX = module.getX;\n\tgetX(); // 9, because in this case, \"this\" refers to the global object\n\n\t// create a new function with 'this' bound to module\n\tvar boundGetX = getX.bind(module);\n\tboundGetX(); // 81\n\n##Partial Functions\n\nThe next simplest use of bind() is to make a function with pre-specified initial arguments. These arguments (if any) follow the provided this value and are then inserted at the start of the arguments passed to the target function, followed by the arguments passed to the bound function, whenever the bound function is called.\n\n\tfunction list() {\n\t  return Array.prototype.slice.call(arguments);\n\t}\n\n\tvar list1 = list(1, 2, 3); // [1, 2, 3]\n\n\t//  Create a function with a preset leading argument\n\tvar leadingThirtysevenList = list.bind(undefined, 37);\n\n\tvar list2 = leadingThirtysevenList(); // [37]\n\tvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n##With setTimeout\n\nBy default within window.setTimeout(), the this keyword will be set to the window (or global) object. When working with class methods that require this to refer to class instances, you may explicitly bind this to the callback function, in order to maintain the instance.\n\n\tfunction LateBloomer() {\n\t  this.petalCount = Math.ceil( Math.random() * 12 ) + 1;\n\t}\n\n\t// declare bloom after a delay of 1 second\n\tLateBloomer.prototype.bloom = function() {\n\t  window.setTimeout( this.declare.bind( this ), 1000 );\n\t};\n\n\tLateBloomer.prototype.declare = function() {\n\t  console.log('I am a beautiful flower with ' + \n\t    this.petalCount + ' petals!');\n\t};\n\n##Bound functions used as constructors\n\nWarning: This section demonstrates JavaScript capabilities and documents some edge cases of the bind() method. The methods shown below are not the best way to do things and probably should not be used in any production environment.\nBound functions are automatically suitable for use with the new operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided this is ignored. However, provided arguments are still prepended to the constructor call:\n\n\tfunction Point(x, y) {\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\n\tPoint.prototype.toString = function() { \n\t  return this.x + \",\" + this.y; \n\t};\n\n\tvar p = new Point(1, 2);\n\tp.toString(); // \"1,2\"\n\n\n\tvar emptyObj = {};\n\tvar YAxisPoint = Point.bind(emptyObj, 0);\n\t// not supported in the polyfill below, works fine with native bind:\n\tvar YAxisPoint = Point.bind(null,0 );\n\n\tvar axisPoint = new YAxisPoint(5);\n\taxisPoint.toString(); //  \"0,5\"\n\n\taxisPoint instanceof Point; // true\n\taxisPoint instanceof YAxisPoint; // true\n\tnew Point(17, 42) instanceof YAxisPoint; // false\nNote that you need do nothing special to create a bound function for use with new. The corollary is that you need do nothing special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using new.\n\n\t// Example can be run directly in your JavaScript console\n\t// ...continuing from above\n\n\t// Can still be called as a normal function \n\t// (although usually this is undesired)\n\tYAxisPoint(13);\n\n\temptyObj.x + \",\" + emptyObj.y;\n\t// >  \"0,13\"\nIf you wish to support use of a bound function only using new, or only by calling it, the target function must enforce that restriction.\n\n##Creating shortcuts\n\nbind() is also helpful in cases where you want to create a shortcut to a function which requires a specific this value.\n\nTake Array.prototype.slice, for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:\n\n\tvar slice = Array.prototype.slice;\n\n\t// ...\n\n\tslice.call(arguments);\n\tWith bind(), this can be simplified. In the following piece of code, slice is a bound function to the call() function of Function.prototype, with the this value set to the slice() function of Array.prototype. This means that additional call() calls can be eliminated:\n\n\t// same as \"slice\" in the previous example\n\tvar unboundSlice = Array.prototype.slice;\n\tvar slice = Function.prototype.call.bind(unboundSlice);\n\n\t// ...\n\n\tslice(arguments);\n#Polyfill\nThe bind function is a recent addition to ECMA-262, 5th edition; as such it may not be present in all browsers. You can partially work around this by inserting the following code at the beginning of your scripts, allowing use of much of the functionality of bind() in implementations that do not natively support it.\n\n\tif (!Function.prototype.bind) {\n\t  Function.prototype.bind = function (oThis) {\n\t    if (typeof this !== \"function\") {\n\t      // closest thing possible to the ECMAScript 5\n\t      // internal IsCallable function\n\t      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\t    }\n\n\t    var aArgs = Array.prototype.slice.call(arguments, 1), \n\t        fToBind = this, \n\t        fNOP = function () {},\n\t        fBound = function () {\n\t          return fToBind.apply(this instanceof fNOP && oThis\n\t                 ? this\n\t                 : oThis,\n\t                 aArgs.concat(Array.prototype.slice.call(arguments)));\n\t        };\n\n\t    fNOP.prototype = this.prototype;\n\t    fBound.prototype = new fNOP();\n\n\t    return fBound;\n\t  };\n\t}\n\nSome of the many differences (there may well be others, as this list does not seriously attempt to be exhaustive) between this algorithm and the specified algorithm are:\n\nThe partial implementation relies Array.prototype.slice, Array.prototype.concat, Function.prototype.call and Function.prototype.apply, built-in methods to have their original values.\nThe partial implementation creates functions that do not have immutable \"poison pill\" caller and arguments properties that throw a TypeError upon get, set, or deletion. (This could be added if the implementation supports Object.defineProperty, or partially implemented [without throw-on-delete behavior] if the implementation supports the __defineGetter__ and __defineSetter__ extensions.)\nThe partial implementation creates functions that have a prototype property. (Proper bound functions have none.)\nThe partial implementation creates bound functions whose length property does not agree with that mandated by ECMA-262: it creates functions with length 0, while a full implementation, depending on the length of the target function and the number of pre-specified arguments, may return a non-zero length.\nIf you choose to use this partial implementation, you must not rely on those cases where behavior deviates from ECMA-262, 5th edition! With some care, however (and perhaps with additional modification to suit specific needs), this partial implementation may be a reasonable bridge to the time when bind() is widely implemented according to the specification.\n\n@param thisArg The value to be passed as the this parameter to the target function when the bound function is called. The value is ignored if the bound function is constructed using the new operator.\n@param args Arguments to prepend to arguments provided to the bound function when invoking the target function.\n\n*/\n\n\n\n\n\n\n/*\n@method call\n\n#Summary\nThe call() method calls a function with a given this value and arguments provided individually.\n\nNOTE: While the syntax of this function is almost identical to that of apply(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.call(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object.\n\nWith call, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\n#Examples\n##Using call to chain constructors for an object\n\nYou can use call to chain constructors for an object, similar to Java. In the following example, the constructor for the Product object is defined with two parameters, name and price. Two other functions Food and Toy invoke Product passing this and name and price. Product initializes the properties name and price, both specialized functions define the category.\n\n\tfunction Product(name, price) {\n\t  this.name = name;\n\t  this.price = price;\n\n\t  if (price < 0) {\n\t    throw RangeError('Cannot create product ' +\n\t                      this.name + ' with a negative price');\n\t  }\n\n\t  return this;\n\t}\n\n\tfunction Food(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'food';\n\t}\n\n\tFood.prototype = Object.create(Product.prototype);\n\n\tfunction Toy(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'toy';\n\t}\n\n\tToy.prototype = Object.create(Product.prototype);\n\n\tvar cheese = new Food('feta', 5);\n\tvar fun = new Toy('robot', 40);\n \n##Using call to invoke an anonymous function\n\nIn this purely constructed example, we create anonymous function and use call to invoke it on every object in an array. The main purpose of the anonymous function here is to add a print function to every object, which is able to print the right index of the object in the array. Passing the object as this value was not strictly necessary, but is done for explanatory purpose.\n\n\tvar animals = [\n\t  {species: 'Lion', name: 'King'},\n\t  {species: 'Whale', name: 'Fail'}\n\t];\n\n\tfor (var i = 0; i < animals.length; i++) {\n\t  (function (i) { \n\t    this.print = function () { \n\t      console.log('#' + i  + ' ' + this.species \n\t                  + ': ' + this.name); \n\t    } \n\t    this.print();\n\t  }).call(animals[i], i);\n\t}\n\n\n@param thisArg The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.\n@param arg1,arg2,... Arguments for the object.\n\n*/\n\n\n\n\n/*\n@method toString\n#Summary\nThe toString() method returns a string representing the source code of the function.\n\n#Syntax\n\tfunction.toString(indentation)\n#Description\nThe Function object overrides the toString method inherited from Object; it does not inherit Object.prototype.toString. For Function objects, the toString method returns a string representation of the object in the form of a function declaration. That is, toString decompiles the function, and the string returned includes the function keyword, the argument list, curly braces, and the source of the function body.\n\nJavaScript calls the toString method automatically when a Function is to be represented as a text value, e.g. when a function is concatenated with a string.\n\n@return {String}\n*/\n\n/*\n@module javascript\n@class Number\n\n#Summary\nThe Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor.\n\n#Constructor\n\tnew Number(value);\n\n#Description\nThe primary uses for the Number object are:\n\nIf the argument cannot be converted into a number, it returns NaN.\nIn a non-constructor context (i.e., without the new operator, Number can be used to perform a type conversion.\n\n\n#Examples\n##Example: Using the Number object to assign values to numeric variables\n\nThe following example uses the Number object's properties to assign values to several numeric variables:\n\n\tvar biggestNum = Number.MAX_VALUE;\n\tvar smallestNum = Number.MIN_VALUE;\n\tvar infiniteNum = Number.POSITIVE_INFINITY;\n\tvar negInfiniteNum = Number.NEGATIVE_INFINITY;\n\tvar notANum = Number.NaN;\n##Example: Integer range for Number\n\nThe following example shows minimum and maximum integer values that can be represented as Number object (for details, refer to EcmaScript standard, chapter 8.5 The Number Type):\n\n\tvar biggestInt = 9007199254740992;\n\tvar smallestInt = -9007199254740992;\n\nWhen parsing data that has been serialized to JSON, integer values falling out of this range can be expected to become corrupted when JSON parser coerces them to Number type. Using String instead is a possible workaround.\n\n##Example: Using Number to convert a Date object\n\nThe following example converts the Date object to a numerical value using Number as a function:\n\n\tvar d = new Date(\"December 17, 1995 03:24:00\");\n\tprint(Number(d));\n\nThis displays \"819199440000\".\n\n*/\n\n/*\n@constructor Number\n@param {Any}value The numeric value of the object being created.\n*/\n\n\n\n\n\n\n/*\n@property {Number} MAX_VALUE\n\n#Summary\nThe Number.MAX_VALUE property represents the maximum numeric value representable in JavaScript.\n\n#Description\nThe MAX_VALUE property has a value of approximately 1.79E+308. Values larger than MAX_VALUE are represented as \"Infinity\".\n\nBecause MAX_VALUE is a static property of Number, you always use it as Number.MAX_VALUE, rather than as a property of a Number object you created.\n\n#Examples\n##Example: Using MAX_VALUE\n\n\tThe following code multiplies two numeric values. If the result is less than or equal to MAX_VALUE, the func1 function is called; otherwise, the func2 function is called.\n\n\tif (num1 * num2 <= Number.MAX_VALUE) {\n\t   func1();\n\t} else {\n\t   func2();\n\t}\n\n@static\n\n*/\n\n\n\n/*\n@property {Number} MIN_VALUE\n\n#Summary\nThe Number.MIN_VALUE property represents the smallest positive numeric value representable in JavaScript.\n\n#Description\nThe MIN_VALUE property is the number closest to 0, not the most negative number, that JavaScript can represent.\n\nMIN_VALUE has a value of approximately 5e-324. Values smaller than MIN_VALUE (\"underflow values\") are converted to 0.\n\nBecause MIN_VALUE is a static property of Number, you always use it as Number.MIN_VALUE, rather than as a property of a Number object you created.\n\n#Examples\n##Example: Using MIN_VALUE\n\nThe following code divides two numeric values. If the result is greater than or equal to MIN_VALUE, the func1 function is called; otherwise, the func2 function is called.\n\n\tif (num1 / num2 >= Number.MIN_VALUE) {\n\t    func1();\n\t} else {\n\t    func2();\n\t}\n\n@static\n*/\n\n\n\n\n/*\n@property {Number}NEGATIVE_INFINITY\n\n#Summary\nThe Number.NEGATIVE_INFINITY property represents the negative Infinity value.\n\nYou do not have to create a Number object to access this static property (use Number.NEGATIVE_INFINITY).\n\n#Description\nThe value of Number.NEGATIVE_INFINITY is the same as the negative value of the global object's Infinity property.\n\nThis value behaves slightly differently than mathematical infinity:\n\n* Any positive value, including POSITIVE_INFINITY, multiplied by NEGATIVE_INFINITY is NEGATIVE_INFINITY.\n* Any negative value, including NEGATIVE_INFINITY, multiplied by NEGATIVE_INFINITY is POSITIVE_INFINITY.\n* Zero multiplied by NEGATIVE_INFINITY is NaN.\n* NaN multiplied by NEGATIVE_INFINITY is NaN.\n* NEGATIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is POSITIVE_INFINITY.\n* NEGATIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is NEGATIVE_INFINITY.\n* NEGATIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\n* Any number divided by NEGATIVE_INFINITY is zero.\n\nYou might use the Number.NEGATIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that isFinite would be more appropriate in such a case.\n\n#Example\nIn the following example, the variable smallNumber is assigned a value that is smaller than the minimum value. When the if statement executes, smallNumber has the value \"-Infinity\", so smallNumber is set to a more manageable value before continuing.\n\n\tvar smallNumber = (-Number.MAX_VALUE) * 2\n\n\tif (smallNumber == Number.NEGATIVE_INFINITY) {\n\t smallNumber = returnFinite();\n\t}\n\n@static\n*/\n\n\n\n/*\n@property {Number} NaN\n#Summary\nThe Number.NaN property represents Not-A-Number. Equivalent of NaN.\n\nYou do not have to create a Number object to access this static property (use Number.NaN).\n@static\n*/\n\n\n\n/*\n@property {Number}POSITIVE_INFINITY\n\n#Summary\nThe Number.POSITIVE_INFINITY property represents the positive Infinity value.\n\nYou do not have to create a Number object to access this static property (use Number.POSITIVE_INFINITY).\n\n#Description\nThe value of Number.POSITIVE_INFINITY is the same as the value of the global object's Infinity property.\n\nThis value behaves slightly differently than mathematical infinity:\n\n* Any positive value, including POSITIVE_INFINITY, multiplied by POSITIVE_INFINITY is POSITIVE_INFINITY.\n* Any negative value, including NEGATIVE_INFINITY, multiplied by POSITIVE_INFINITY is NEGATIVE_INFINITY.\n* Zero multiplied by POSITIVE_INFINITY is NaN.\n* NaN multiplied by POSITIVE_INFINITY is NaN.\n* POSITIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is NEGATIVE_INFINITY.\n* POSITIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is POSITIVE_INFINITY.\n* POSITIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\n* Any number divided by POSITIVE_INFINITY is Zero.\n* You might use the Number.POSITIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that isFinite would be more appropriate in such a case.\n\n#Example\nIn the following example, the variable bigNumber is assigned a value that is larger than the maximum value. When the if statement executes, bigNumber has the value \"Infinity\", so bigNumber is set to a more manageable value before continuing.\n\n\tvar bigNumber = Number.MAX_VALUE * 2\n\tif (bigNumber == Number.POSITIVE_INFINITY) {\n\t bigNumber = returnFinite();\n\t}\n\n@static \n*/\n\n/*\n@module javascript\n\n@class Object\nAdapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n\n#Description\nThe Object constructor creates an object wrapper for the given value. If the value is null or undefined, it will create and return an empty object, otherwise, it will return an object of a Type that corresponds to the given value. If the value is an object already, it will return the value.\n\nWhen called in a non-constructor context, Object behaves identically to new Object().\n\n#Object instances and Object prototype object\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden. For example, other constructors' prototypes override the constructor property and provide their own toString methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.\n\n#Examples\n##Example: Using Object given undefined and null types\n\nThe following examples store an empty Object object in o:\n\n\tvar o = new Object();\n\tvar o = new Object(undefined);\n\tvar o = new Object(null);\n##Example: Using Object to create Boolean objects\n\nThe following examples store Boolean objects in o:\n\n\t// equivalent to o = new Boolean(true);\n\tvar o = new Object(true);\n\t// equivalent to o = new Boolean(false);\n\tvar o = new Object(Boolean());\n\n\n@property {ObjectPrototype} prototype\n\n@static \n\n*/\n\n/*\n@constructor bla bla\n\n\t// Object initialiser or literal \n\t{ [ nameValuePair1 [, nameValuePair2 [, ...nameValuePairN] ] ] }  \n\t// Called as a constructor \n\tnew Object( [ value ] )\n\n@param nameValuePair1,nameValuePair2,...nameValuePairN Pairs of names (strings) and values (any value) where the name is separated from the value by a colon.\n@param value Any value.\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method __defineGetter__()  \nAssociates a function with a property that, when accessed, executes that function and returns its return value.\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method hasOwnProperty\n##Summary\nThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n##Syntax\nobj.hasOwnProperty(prop)\n\n##Examples\n###Example: Using hasOwnProperty to test for a property's existence\n\nThe following example determines whether the o object contains a property named prop:\n\n\to = new Object();\n\to.prop = 'exists';\n\n\tfunction changeO() {\n\t  o.newprop = o.prop;\n\t  delete o.prop;\n\t}\n\n\to.hasOwnProperty('prop');   // returns true\n\tchangeO();\n\to.hasOwnProperty('prop');   // returns false\n\n###Example: Direct versus inherited properties\n\nThe following example differentiates between direct properties and properties inherited through the prototype chain:\n\n\to = new Object();\n\to.prop = 'exists';\n\to.hasOwnProperty('prop');             // returns true\n\to.hasOwnProperty('toString');         // returns false\n\to.hasOwnProperty('hasOwnProperty');   // returns false\n\n##Example: Iterating over the properties of an object\n\nThe following example shows how to iterate over the properties of an object without executing on inherit properties. Note that the for..in loop is already only iterating enumerable items, so one should not assume based on the lack of non-enumerable properties shown in the loop that hasOwnProperty itself is confined strictly to enumerable items (as with Object.getOwnPropertyNames()).\n\n\tvar buz = {\n\t    fog: 'stack'\n\t};\n\n\tfor (var name in buz) {\n\t    if (buz.hasOwnProperty(name)) {\n\t        alert(\"this is fog (\" + name + \") for sure. Value: \" + buz[name]);\n\t    }\n\t    else {\n\t        alert(name); // toString or something else\n\t    }\n\t}\n\n###Example: hasOwnProperty as a property\n\nJavaScript does not protect the property name hasOwnProperty; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an external hasOwnProperty to get correct results:\n\n\tvar foo = {\n\t    hasOwnProperty: function() {\n\t        return false;\n\t    },\n\t    bar: 'Here be dragons'\n\t};\n\n\tfoo.hasOwnProperty('bar'); // always returns false\n\n\t// Use another Object's hasOwnProperty and call it with 'this' set to foo\n\t({}).hasOwnProperty.call(foo, 'bar'); // true\n\n\t// It's also possible to use the hasOwnProperty property from the Object property for this purpose\n\tObject.prototype.hasOwnProperty.call(foo, 'bar'); // true\n\nNote that in the last case there are no newly created objects.\n\n@param param The name of the property to test.\n\n*/\n\n\n\n\n\n\n\n\n/*\n@method isPrototypeOf\n##Summary\nThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\n\tNote: isPrototypeOf differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n\nThe isPrototypeOf method allows you to check whether or not an object exists within another object's prototype chain.\n\nFor example, consider the following prototype chain:\n\n\tfunction Fee() {\n\t  // . . .\n\t}\n\n\tfunction Fi() {\n\t  // . . .\n\t}\n\tFi.prototype = new Fee();\n\n\tfunction Fo() {\n\t  // . . .\n\t}\n\tFo.prototype = new Fi();\n\n\tfunction Fum() {\n\t  // . . .\n\t}\n\tFum.prototype = new Fo();\n\nLater on down the road, if you instantiate Fum and need to check if Fi's prototype exists within the Fum prototype chain, you could do this:\n\n\tvar fum = new Fum();\n\t. . .\n\t\n\tif (Fi.prototype.isPrototypeOf(fum)) {\n\t  // do something safe\n\t}\nThis, along with the instanceof operator particularly comes in handy if you have code that can only function when dealing with objects descended from a specific prototype chain, e.g., to guarantee that certain methods or properties will be present on that object.\n\n\n@param {Object} obj the object whose prototype chain will be searched\n*/\n\n\n\n\n\n/*\n@method propertyIsEnumerable\n##Summary\nThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n\n##Description\nEvery object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.\n\n##Examples\n###Example: A basic use of propertyIsEnumerable\n\nThe following example shows the use of propertyIsEnumerable on objects and arrays:\n\n\tvar o = {};\n\tvar a = [];\n\to.prop = 'is enumerable';\n\ta[0] = 'is enumerable';\n\n\to.propertyIsEnumerable('prop');   // returns true\n\ta.propertyIsEnumerable(0);        // returns true\n\n###Example: User-defined versus built-in objects\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n\tvar a = ['is enumerable'];\n\n\ta.propertyIsEnumerable(0);          // returns true\n\ta.propertyIsEnumerable('length');   // returns false\n\n\tMath.propertyIsEnumerable('random');   // returns false\n\tthis.propertyIsEnumerable('Math');     // returns false\n\tExample: Direct versus inherited properties\n\n\tvar a = [];\n\ta.propertyIsEnumerable('constructor');         // returns false\n\n\tfunction firstConstructor() {\n\t  this.property = 'is not enumerable';\n\t}\n\n\tfirstConstructor.prototype.firstMethod = function () {};\n\n\tfunction secondConstructor() {\n\t  this.method = function method() { return 'is enumerable'; };\n\t}\n\n\tsecondConstructor.prototype = new firstConstructor;\n\tsecondConstructor.prototype.constructor = secondConstructor;\n\n\tvar o = new secondConstructor();\n\to.arbitraryProperty = 'is enumerable';\n\n\to.propertyIsEnumerable('arbitraryProperty');   // returns true\n\to.propertyIsEnumerable('method');              // returns true\n\to.propertyIsEnumerable('property');            // returns false\n\n\to.property = 'is enumerable';\n\n\to.propertyIsEnumerable('property');            // returns true\n\n\t// These return false as they are on the prototype which \n\t// propertyIsEnumerable does not consider (even though the last two\n\t// are iteratable with for-in)\n\to.propertyIsEnumerable('prototype');   // returns false (as of JS 1.8.1/FF3.6)\n\to.propertyIsEnumerable('constructor'); // returns false\n\to.propertyIsEnumerable('firstMethod'); // returns false\n\n@param prop\nThe name of the property to test.\n*/\n\n\n\n\n/*\n@method toLocaleString\n##Summary\nThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n##Syntax\nobj.toLocaleString();\n##Description\nObject's toLocaleString returns the result of calling toString().\n\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. See the list below.\n\n##Objects overriding toLocaleString\n\nArray: Array.prototype.toLocaleString()\nNumber: Number.prototype.toLocaleString()\nDate: Date.prototype.toLocaleString()\n*/\n\n\n\n\n\n/*\n@method toString\n##Summary\nThe toString() method returns a string representing object.\n\n##Syntax\nobj.toString()\n##Description\nEvery object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected. By default, the toString() method is inherited by every object descended from Object. If this method is not overridden in a custom object, toString() returns \"[object type]\", where type is the object type. The following code illustrates this:\n\nvar o = new Object();\no.toString();           // returns [object Object]\nStarting in JavaScript 1.8.5 toString() called on null returns [object Null], and undefined returns [object Undefined], as defined in the 5th Edition of ECMAScript and a subsequent Errata. See Using toString to detect object type.\n##Examples\n###Overriding the default toString method\n\nYou can create a function to be called in place of the default toString() method. The toString() method takes no arguments and should return a string. The toString() method you create can be any value you want, but it will be most useful if it carries information about the object.\n\nThe following code defines the Dog object type and creates theDog, an object of type Dog:\n\n\tfunction Dog(name,breed,color,sex) {\n\t   this.name=name;\n\t   this.breed=breed;\n\t   this.color=color;\n\t   this.sex=sex;\n\t}\n\n\ttheDog = new Dog(\"Gabby\",\"Lab\",\"chocolate\",\"female\");\nIf you call the toString() method on this custom object, it returns the default value inherited from Object:\n\n\ttheDog.toString(); //returns [object Object]\n\tThe following code creates and assigns dogToString() to override the default toString() method. This function generates a string containing the name, breed, color, and sex of the object, in the form \"property = value;\".\n\n\tDog.prototype.toString = function dogToString() {\n\t  var ret = \"Dog \" + this.name + \" is a \" + this.sex + \" \" + this.color + \" \" + this.breed;\n\t  return ret;\n\t}\nWith the preceding code in place, any time theDog is used in a string context, JavaScript automatically calls the dogToString() function, which returns the following string:\n\nDog Gabby is a female chocolate Lab\nUsing toString() to detect object class\n\ntoString() can be used with every object and allows you to get its class. To use the Object.prototype.toString() with every object, you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter called thisArg.\n\n\tvar toString = Object.prototype.toString;\n\n\ttoString.call(new Date); // [object Date]\n\ttoString.call(new String); // [object String]\n\ttoString.call(Math); // [object Math]\n\n\t//Since JavaScript 1.8.5\n\ttoString.call(undefined); // [object Undefined]\n\ttoString.call(null); // [object Null]\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method create\n\n#Summary\nThe Object.create() method creates a new object with the specified prototype object and properties.\n\n#Syntax\n\tObject.create(proto[, propertiesObject])\n\n#Examples\n\n##Example: Classical inheritance with Object.create\n\nBelow is an example of how to use Object.create to achieve classical inheritance. This is for single inheritance, which is all that Javascript supports.\n\n\t// Shape - superclass\n\tfunction Shape() {\n\t  this.x = 0;\n\t  this.y = 0;\n\t}\n\n\t// superclass method\n\tShape.prototype.move = function(x, y) {\n\t  this.x += x;\n\t  this.y += y;\n\t  console.info('Shape moved.');\n\t};\n\n\t// Rectangle - subclass\n\tfunction Rectangle() {\n\t  Shape.call(this); // call super constructor.\n\t}\n\n\t// subclass extends superclass\n\tRectangle.prototype = Object.create(Shape.prototype);\n\tRectangle.prototype.constructor = Rectangle;\n\n\tvar rect = new Rectangle();\n\n\trect instanceof Rectangle; // true\n\trect instanceof Shape; // true\n\n\trect.move(1, 1); // Outputs, 'Shape moved.'\n\tIf you wish to inherit from multiple objects, then mixins are a possibility.\n\n\tfunction MyClass() {\n\t  SuperClass.call(this);\n\t  OtherSuperClass.call(this);\n\t}\n\n\tMyClass.prototype = Object.create(SuperClass.prototype); // inherit\n\tmixin(MyClass.prototype, OtherSuperClass.prototype); // mixin\n\n\tMyClass.prototype.myMethod = function() {\n\t  // do a thing\n\t};\n\nThe mixin function would copy the functions from the superclass prototype to the subclass prototype, the mixin function needs to be supplied by the user. An example of a mixin like function would be jQuery.extend.\n\n##Example: Using propertiesObject argument with Object.create\n\n\tvar o;\n\n\t// create an object with null as prototype\n\to = Object.create(null);\n\n\n\to = {};\n\t// is equivalent to:\n\to = Object.create(Object.prototype);\n\n\n\t// Example where we create an object with a couple of sample properties.\n\t// (Note that the second parameter maps keys to *property descriptors*.)\n\to = Object.create(Object.prototype, {\n\t  // foo is a regular 'value property'\n\t  foo: { writable: true, configurable: true, value: 'hello' },\n\t  // bar is a getter-and-setter (accessor) property\n\t  bar: {\n\t    configurable: false,\n\t    get: function() { return 10; },\n\t    set: function(value) { console.log('Setting `o.bar` to', value); }\n\t  }\n\t});\n\n\n\tfunction Constructor() {}\n\to = new Constructor();\n\t// is equivalent to:\n\to = Object.create(Constructor.prototype);\n\t// Of course, if there is actual initialization code in the\n\t// Constructor function, the Object.create cannot reflect it\n\n\n\t// create a new object whose prototype is a new, empty object\n\t// and a adding single property 'p', with value 42\n\to = Object.create({}, { p: { value: 42 } });\n\n\t// by default properties ARE NOT writable, enumerable or configurable:\n\to.p = 24;\n\to.p;\n\t// 42\n\n\to.q = 12;\n\tfor (var prop in o) {\n\t  console.log(prop);\n\t}\n\t// 'q'\n\n\tdelete o.p;\n\t// false\n\n\t// to specify an ES3 property\n\to2 = Object.create({}, {\n\t  p: {\n\t    value: 42,\n\t    writable: true,\n\t    enumerable: true,\n\t    configurable: true\n\t  }\n\t});\n\n##Polyfill\nThis polyfill covers the main use case which is creating a new object for which the prototype has been chosen but doesn't take the second argument into account.\n\n\tif (typeof Object.create != 'function') {\n\t  Object.create = (function() {\n\t    var Object = function() {};\n\t    return function (prototype) {\n\t      if (arguments.length > 1) {\n\t        throw Error('Second argument not supported');\n\t      }\n\t      if (typeof prototype != 'object') {\n\t        throw TypeError('Argument must be an object');\n\t      }\n\t      Object.prototype = prototype;\n\t      var result = new Object();\n\t      Object.prototype = null;\n\t      return result;\n\t    };\n\t  })();\n\t}\n\n@static\n\n@param {Object} proto The object which should be the prototype of the newly-created object.\n\n@param {Object} propertiesObject If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). @optional\n\n@throws Throws a TypeError exception if the proto parameter isn't null or an object.\n\n*/\n\n\n\n\n\n\n\n\n/*\n@method defineProperties\n\n#Summary\nThe Object.defineProperties() method defines new or modifies existing properties directly on an object, returning the object.\n\n#Syntax\n\tObject.defineProperties(obj, props)\n\n#Description\nObject.defineProperties, in essence, defines all properties corresponding to the enumerable own properties of props on the object obj object.\n\n#Example\n\n\tObject.defineProperties(obj, {\n\t  \"property1\": {\n\t    value: true,\n\t    writable: true\n\t  },\n\t  \"property2\": {\n\t    value: \"Hello\",\n\t    writable: false\n\t  }\n\t  // etc. etc.\n\t});\n\n\n# Polyfill\n\nAssuming a pristine execution environment with all names and properties referring to their initial values, Object.defineProperties is almost completely equivalent (note the comment in isCallable) to the following reimplementation in JavaScript:\n\n\tfunction defineProperties(obj, properties) {\n\t  function convertToDescriptor(desc) {\n\t    function hasProperty(obj, prop) {\n\t      return Object.prototype.hasOwnProperty.call(obj, prop);\n\t    }\n\n\t    function isCallable(v) {\n\t      // NB: modify as necessary if other values than functions are callable.\n\t      return typeof v === \"function\";\n\t    }\n\n\t    if (typeof desc !== \"object\" || desc === null)\n\t      throw new TypeError(\"bad desc\");\n\n\t    var d = {};\n\n\t    if (hasProperty(desc, \"enumerable\"))\n\t      d.enumerable = !!obj.enumerable;\n\t    if (hasProperty(desc, \"configurable\"))\n\t      d.configurable = !!obj.configurable;\n\t    if (hasProperty(desc, \"value\"))\n\t      d.value = obj.value;\n\t    if (hasProperty(desc, \"writable\"))\n\t      d.writable = !!desc.writable;\n\t    if (hasProperty(desc, \"get\")) {\n\t      var g = desc.get;\n\n\t      if (!isCallable(g) && typeof g !== \"undefined\")\n\t        throw new TypeError(\"bad get\");\n\t      d.get = g;\n\t    }\n\t    if (hasProperty(desc, \"set\")) {\n\t      var s = desc.set;\n\t      if (!isCallable(s) && typeof s !== \"undefined\")\n\t        throw new TypeError(\"bad set\");\n\t      d.set = s;\n\t    }\n\n\t    if ((\"get\" in d || \"set\" in d) && (\"value\" in d || \"writable\" in d))\n\t      throw new TypeError(\"identity-confused descriptor\");\n\n\t    return d;\n\t  }\n\n\t  if (typeof obj !== \"object\" || obj === null)\n\t    throw new TypeError(\"bad obj\");\n\n\t  properties = Object(properties);\n\n\t  var keys = Object.keys(properties);\n\t  var descs = [];\n\n\t  for (var i = 0; i < keys.length; i++)\n\t    descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);\n\n\t  for (var i = 0; i < descs.length; i++)\n\t    Object.defineProperty(obj, descs[i][0], descs[i][1]);\n\n\t  return obj;\n\t} \n\n\n@static \n\n@param {Object} obj The object on which to define or modify properties.\n@param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.\n\n\n*/\n\n\n\n\n\n\n\n\n\n\n\n/*\n@method defineProperty\n\n#Summary\nThe Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\n\n#Syntax\nObject.defineProperty(obj, prop, descriptor)\n\n#Description\nThis method allows precise addition to or modification of a property on an object. Normal property addition through assignment creates properties which show up during property enumeration (for...in loop or Object.keys method), whose values may be changed, and which may be deleted. This method allows these extra details to be changed from their defaults.\n\nProperty descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both.\n\nBoth data and accessor descriptors are objects. They share the following optional keys:\n\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\nDefaults to false.\n\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\nDefaults to false.\nA data descriptor also has the following optional keys:\n\n###value\nThe value associated with the property. Can be any valid JavaScript value (number, object, function, etc).\nDefaults to undefined.\nwritable\ntrue if and only if the value associated with the property may be changed with an assignment operator.\nDefaults to false.\nAn accessor descriptor also has the following optional keys:\n\n###get\nA function which serves as a getter for the property, or undefined if there is no getter. The function return will be used as the value of property.\nDefaults to undefined.\n\n###set\nA function which serves as a setter for the property, or undefined if there is no setter. The function will receive as only argument the new value being assigned to the property.\nDefaults to undefined.\nBear in mind that these options are not necessarily own properties so, if inherited, will be considered too. In order to ensure these defaults are preserved you might freeze the Object.prototype upfront, specify all options explicitly, or point to null as __proto__ property.\n\n\t// using __proto__\n\tObject.defineProperty(obj, 'key', {\n\t  __proto__: null, // no inherited properties\n\t  value: 'static'  // not enumerable\n\t                   // not configurable\n\t                   // not writable\n\t                   // as defaults\n\t});\n\n\t// being explicit\n\tObject.defineProperty(obj, 'key', {\n\t  enumerable: false,\n\t  configurable: false,\n\t  writable: false,\n\t  value: 'static'\n\t});\n\n\t// recycling same object\n\tfunction withValue(value) {\n\t  var d = withValue.d || (\n\t    withValue.d = {\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false,\n\t      value: null\n\t    }\n\t  );\n\t  d.value = value;\n\t  return d;\n\t}\n\t// ... and ...\n\tObject.defineProperty(obj, 'key', withValue('static'));\n\n\t// if freeze is available, prevents the code to add\n\t// value, get, set, enumerable, writable, configurable\n\t// to the Object prototype\n\t(Object.freeze || Object)(Object.prototype);\n\n#Examples\n\nIf you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see additional examples.\n\n##Example: Creating a property\n\nWhen the property specified doesn't exist in the object, Object.defineProperty() creates a new property as described. Fields may be omitted from the descriptor, and default values for those fields are imputed. All of the Boolean-valued fields default to false. The value, get, and set fields default to undefined. A property which is defined without get/set/value/writable is called “generic” and is “typed” as a data descriptor.\n\n\tvar o = {}; // Creates a new object\n\n\t// Example of an object property added with defineProperty with a data property descriptor\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: true,\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\t// 'a' property exists in the o object and its value is 37\n\n\t// Example of an object property added with defineProperty with an accessor property descriptor\n\tvar bValue = 38;\n\tObject.defineProperty(o, 'b', {\n\t  get: function() { return bValue; },\n\t  set: function(newValue) { bValue = newValue; },\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\to.b; // 38\n\t// 'b' property exists in the o object and its value is 38\n\t// The value of o.b is now always identical to bValue, unless o.b is redefined\n\n\t// You cannot try to mix both:\n\tObject.defineProperty(o, 'conflict', {\n\t  value: 0x9f91102,\n\t  get: function() { return 0xdeadbeef; }\n\t});\n\t// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors\n\n##Example: Modifying a property\n\nWhen the property already exists, Object.defineProperty() attempts to modify the property according to the values in the descriptor and the object's current configuration. If the old descriptor had its configurable attribute set to false (the property is said to be “non-configurable”), then no attribute besides writable can be changed. In that case, it is also not possible to switch back and forth between the data and accessor property types.\n\nIf a property is non-configurable, its writable attribute can only be changed to false.\n\nA TypeError is thrown when attempts are made to change non-configurable property attributes (besides the writable attribute) unless the current and new values are the same.\n\n##Writable attribute\n\nWhen the writable property attribute is set to false, the property is said to be “non-writable”. It cannot be reassigned.\n\n\tvar o = {}; // Creates a new object\n\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: false\n\t});\n\n\tconsole.log(o.a); // logs 37\n\to.a = 25; // No error thrown (it would throw in strict mode, even if the value had been the same)\n\tconsole.log(o.a); // logs 37. The assignment didn't work.\n\nAs seen in the example, trying to write into the non-writable property doesn't change it but doesn't throw an error either.\n\n##Enumerable attribute\n\nThe enumerable property attribute defines whether the property shows up in a for...in loop and Object.keys() or not.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', { value: 1, enumerable: true });\n\tObject.defineProperty(o, 'b', { value: 2, enumerable: false });\n\tObject.defineProperty(o, 'c', { value: 3 }); // enumerable defaults to false\n\to.d = 4; // enumerable defaults to true when creating a property by setting it\n\n\tfor (var i in o) {\n\t  console.log(i);\n\t}\n\t// logs 'a' and 'd' (in undefined order)\n\n\tObject.keys(o); // ['a', 'd']\n\n\to.propertyIsEnumerable('a'); // true\n\to.propertyIsEnumerable('b'); // false\n\to.propertyIsEnumerable('c'); // false\n\tConfigurable attribute\n\n\tThe configurable attribute controls at the same time whether the property can be deleted from the object and whether its attributes (other than writable) can be changed.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', {\n\t  get: function() { return 1; },\n\t  configurable: false\n\t});\n\n\tObject.defineProperty(o, 'a', { configurable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { enumerable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { set: function() {} }); // throws a TypeError (set was undefined previously)\n\tObject.defineProperty(o, 'a', { get: function() { return 1; } }); // throws a TypeError (even though the new get does exactly the same thing)\n\tObject.defineProperty(o, 'a', { value: 12 }); // throws a TypeError\n\n\tconsole.log(o.a); // logs 1\n\tdelete o.a; // Nothing happens\n\tconsole.log(o.a); // logs 1\n\n\nIf the configurable attribute of o.a had been true, none of the errors would be thrown and the property would be deleted at the end.\n\n##Example: Adding properties and default values\n\nIt's important to consider the way default values of attributes are applied. There is often a difference between simply using dot notation to assign a value and using Object.defineProperty(), as shown in the example below.\n\n\tvar o = {};\n\n\to.a = 1;\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: true,\n\t  configurable: true,\n\t  enumerable: true\n\t});\n\n\n\t// On the other hand,\n\tObject.defineProperty(o, 'a', { value: 1 });\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: false,\n\t  configurable: false,\n\t  enumerable: false\n\t});\n\n\n##Example: Custom Setters and Getters\n\nExample below shows how to implement a self-archiving object. When temperature property is set, the archive array gets a log entry.\n\n\tfunction Archiver() {\n\t  var temperature = null;\n\t  var archive = [];\n\n\t  Object.defineProperty(this, 'temperature', {\n\t    get: function() {\n\t      console.log('get!');\n\t      return temperature;\n\t    },\n\t    set: function(value) {\n\t      temperature = value;\n\t      archive.push({ val: temperature });\n\t    }\n\t  });\n\n\t  this.getArchive = function() { return archive; };\n\t}\n\n\tvar arc = new Archiver();\n\tarc.temperature; // 'get!'\n\tarc.temperature = 11;\n\tarc.temperature = 13;\n\tarc.getArchive(); // [{ val: 11 }, { val: 13 }]\t\n\n\n@static\n@param {Object} obj The object on which to define the property.\n@param {String} prop The name of the property to be defined or modified.\n@param {Object} descriptor The descriptor for the property being defined or modified.\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method freeze\n\n#Summary\nThe Object.freeze() method freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen.\n\n#Syntax\nObject.freeze(obj)\n\n#Description\nNothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail, either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode).\n\nValues cannot be changed for data properties. Accessor properties (getters and setters) work the same (and still give the illusion that you are changing the value). Note that values that are objects can still be modified, unless they are also frozen.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.freeze(obj);\n\n\tassert(Object.isFrozen(obj) === true);\n\n\t// Now any changes will fail\n\tobj.foo = 'quux'; // silently does nothing\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors\n\tfunction fail(){\n\t  'use strict';\n\t  obj.foo = 'sparky'; // throws a TypeError\n\t  delete obj.quaxxor; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\n\tfail();\n\n\t// Attempted changes through Object.defineProperty will also throw\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // throws a TypeError\n\tThe following example shows that object values in a frozen object can be mutated (freeze is shallow).\n\n\tobj = {\n\t  internal: {}\n\t};\n\n\tObject.freeze(obj);\n\tobj.internal.a = 'aValue';\n\n\tobj.internal.a // 'aValue'\n\n\t// To make obj fully immutable, freeze each object in obj.\n\t// To do so, we use this function.\n\n\tfunction deepFreeze(o) {\n\t  var prop, propKey;\n\t  Object.freeze(o); // First freeze the object.\n\t  for (propKey in o) {\n\t    prop = o[propKey];\n\t    if (!o.hasOwnProperty(propKey) || !(typeof prop === 'object') || Object.isFrozen(prop)) {\n\t      // If the object is on the prototype, not an object, or is already frozen,\n\t      // skip it. Note that this might leave an unfrozen reference somewhere in the\n\t      // object if there is an already frozen object containing an unfrozen object.\n\t      continue;\n\t    }\n\n\t    deepFreeze(prop); // Recursively call deepFreeze.\n\t  }\n\t}\n\n\tobj2 = {\n\t  internal: {}\n\t};\n\n\tdeepFreeze(obj2);\n\tobj2.internal.a = 'anotherValue';\n\tobj2.internal.a; // undefined\n\n\n@static\n\n@param obj The object to freeze.\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method getOwnPropertyDescriptor\n\n#Summary\nThe Object.getOwnPropertyDescriptor() method returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object.\n\n#Syntax\n\tObject.getOwnPropertyDescriptor(obj, prop)\n\n#Description\nThis method permits examination of the precise description of a property. A property in JavaScript consists of a string-valued name and a property descriptor. Further information about property descriptor types and their attributes can be found in Object.defineProperty().\n\nA property descriptor is a record with some of the following attributes:\n\n###value\nThe value associated with the property (data descriptors only).\n###writable\ntrue if and only if the value associated with the property may be changed (data descriptors only).\n###get\nA function which serves as a getter for the property, or undefined if there is no getter (accessor descriptors only).\n###set\nA function which serves as a setter for the property, or undefined if there is no setter (accessor descriptors only).\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\n\n#Examples\n\n\tvar o, d;\n\n\to = { get foo() { return 17; } };\n\td = Object.getOwnPropertyDescriptor(o, 'foo');\n\t// d is { configurable: true, enumerable: true, get: , set: undefined }\n\n\to = { bar: 42 };\n\td = Object.getOwnPropertyDescriptor(o, 'bar');\n\t// d is { configurable: true, enumerable: true, value: 42, writable: true }\n\n\to = {};\n\tObject.defineProperty(o, 'baz', { value: 8675309, writable: false, enumerable: false });\n\td = Object.getOwnPropertyDescriptor(o, 'baz');\n\t// d is { value: 8675309, writable: false, enumerable: false, configurable: false }\n\n\n@static \n@param {Object}obj The object in which to look for the property.\n@param {String}prop The name of the property whose description is to be retrieved.\n@returns A property descriptor of the given property if it exists on the object, undefined otherwise.\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method getOwnPropertyNames\n\n#Summary\nThe Object.getOwnPropertyNames() method returns an array of all properties (enumerable or not) found directly upon a given object.\n\n#Syntax\nObject.getOwnPropertyNames(obj)\n\n#Description\nObject.getOwnPropertyNames returns an array whose elements are strings corresponding to the enumerable and non-enumerable properties found directly upon obj. The ordering of the enumerable properties in the array is consistent with the ordering exposed by a for...in loop (or by Object.keys) over the properties of the object. The ordering of the non-enumerable properties in the array, and among the enumerable properties, is not defined.\n\n#Examples\n##Example: Using getOwnPropertyNames\n\n\tvar arr = ['a', 'b', 'c'];\n\tprint(Object.getOwnPropertyNames(arr).sort()); // prints '0,1,2,length'\n\n\t// Array-like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tprint(Object.getOwnPropertyNames(obj).sort()); // prints '0,1,2'\n\n\t// Printing property names and values using Array.forEach\n\tObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n\t  print(val + ' -> ' + obj[val]);\n\t});\n\t// prints\n\t// 0 -> a\n\t// 1 -> b\n\t// 2 -> c\n\n\t// non-enumerable property\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: false } });\n\tmy_obj.foo = 1;\n\n\tprint(Object.getOwnPropertyNames(my_obj).sort()); // prints 'foo,getFoo'\n\nIf you want only the enumerable properties, see Object.keys() or use a for...in loop (although note that this will return enumerable properties not found directly upon that object but also along the prototype chain for the object unless the latter is filtered with hasOwnProperty()).\n\nItems on the prototype chain are not listed:\n\n\tfunction ParentClass() {}\n\tParentClass.prototype.inheritedMethod = function() {};\n\n\tfunction ChildClass() {\n\t  this.prop = 5;\n\t  this.method = function() {};\n\t}\n\tChildClass.prototype = new ParentClass;\n\tChildClass.prototype.prototypeMethod = function() {};\n\n\talert(\n\t  Object.getOwnPropertyNames(\n\t    new ChildClass() // ['prop', 'method']\n\t  )\n\t);\n\n##Example: Get Non-Enumerable Only\n\nThis uses the Array.prototype.filter() function to remove the enumerable keys (obtained with Object.keys()) from a list of all keys (obtained with Object.getOwnPropertyNames) leaving only the non-enumerable keys.\n\n\tvar target = myObject;\n\tvar enum_and_nonenum = Object.getOwnPropertyNames(target);\n\tvar enum_only = Object.keys(target);\n\tvar nonenum_only = enum_and_nonenum.filter(function(key) {\n\t  var indexInEnum = enum_only.indexOf(key);\n\t  if (indexInEnum == -1) {\n\t    // not found in enum_only keys mean the key is non-enumerable,\n\t    // so return true so we keep this in the filter\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t});\n\n\tconsole.log(nonenum_only);\n\n@static\n@param {Object} obj The object whose enumerable and non-enumerable own properties are to be returned.\n\n*/\n\n\n\n\n\n\n\n\n\n\n/*\n@method isExtensible\n#Summary\nThe Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it).\n\n#Syntax\n\tObject.isExtensible(obj)\n\n#Description\nObjects are extensible by default: they can have new properties added to them, and (in engines that support __proto__  their __proto__ property) can be modified. An object can be marked as non-extensible using Object.preventExtensions(), Object.seal(), or Object.freeze().\n\n#Examples\n\t// New objects are extensible.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Sealed objects are by definition non-extensible.\n\tvar sealed = Object.seal({});\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// Frozen objects are also by definition non-extensible.\n\tvar frozen = Object.freeze({});\n\tassert(Object.isExtensible(frozen) === false);\n\tNotes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n\n\t> Object.isExtensible(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isExtensible(1)\n\tfalse                \n\n@static \n\n@param {Object} obj The object which should be checked.\n@return {boolean}\n*/\n\n\n\n\n/*\n@method isFrozen\n\n#Summary\nThe Object.isFrozen() determines if an object is frozen.\n\n#Syntax\n\tObject.isFrozen(obj)\n\n#Description\nAn object is frozen if and only if it is not extensible, all its properties are non-configurable, and all its data properties (that is, properties which are not accessor properties with getter or setter components) are non-writable.\n\n#Examples\n\t// A new object is extensible, so it is not frozen.\n\tassert(Object.isFrozen({}) === false);\n\n\t// An empty object which is not extensible is vacuously frozen.\n\tvar vacuouslyFrozen = Object.preventExtensions({});\n\tassert(Object.isFrozen(vacuouslyFrozen) === true);\n\n\t// A new object with one property is also extensible, ergo not frozen.\n\tvar oneProp = { p: 42 };\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// Preventing extensions to the object still doesn't make it frozen,\n\t// because the property is still configurable (and writable).\n\tObject.preventExtensions(oneProp);\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// ...but then deleting that property makes the object vacuously frozen.\n\tdelete oneProp.p;\n\tassert(Object.isFrozen(oneProp) === true);\n\n\t// A non-extensible object with a non-writable but still configurable property is not frozen.\n\tvar nonWritable = { e: 'plep' };\n\tObject.preventExtensions(nonWritable);\n\tObject.defineProperty(nonWritable, 'e', { writable: false }); // make non-writable\n\tassert(Object.isFrozen(nonWritable) === false);\n\n\t// Changing that property to non-configurable then makes the object frozen.\n\tObject.defineProperty(nonWritable, 'e', { configurable: false }); // make non-configurable\n\tassert(Object.isFrozen(nonWritable) === true);\n\n\t// A non-extensible object with a non-configurable but still writable property also isn't frozen.\n\tvar nonConfigurable = { release: 'the kraken!' };\n\tObject.preventExtensions(nonConfigurable);\n\tObject.defineProperty(nonConfigurable, 'release', { configurable: false });\n\tassert(Object.isFrozen(nonConfigurable) === false);\n\n\t// Changing that property to non-writable then makes the object frozen.\n\tObject.defineProperty(nonConfigurable, 'release', { writable: false });\n\tassert(Object.isFrozen(nonConfigurable) === true);\n\n\t// A non-extensible object with a configurable accessor property isn't frozen.\n\tvar accessor = { get food() { return 'yum'; } };\n\tObject.preventExtensions(accessor);\n\tassert(Object.isFrozen(accessor) === false);\n\n\t// ...but make that property non-configurable and it becomes frozen.\n\tObject.defineProperty(accessor, 'food', { configurable: false });\n\tassert(Object.isFrozen(accessor) === true);\n\n\t// But the easiest way for an object to be frozen is if Object.freeze has been called on it.\n\tvar frozen = { 1: 81 };\n\tassert(Object.isFrozen(frozen) === false);\n\tObject.freeze(frozen);\n\tassert(Object.isFrozen(frozen) === true);\n\n\t// By definition, a frozen object is non-extensible.\n\tassert(Object.isExtensible(frozen) === false);\n\n\t// Also by definition, a frozen object is sealed.\n\tassert(Object.isSealed(frozen) === true);\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n\n\t> Object.isFrozen(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isFrozen(1)\n\ttrue                          // ES6 code\n\n\n@static\n@param {Object}obj The object which should be checked.\n@returns boolean\n*/\n\n\n\n\n\n/*\n@method isSealed\n\n#Summary\nThe Object.isSealed() method determines if an object is sealed.\n\n#Syntax\n\tObject.isSealed(obj)\n#Description\nReturns true if the object is sealed, otherwise false. An object is sealed if it is not extensible and if all its properties are non-configurable and therefore not removable (but not necessarily non-writable).\n\n#Examples\n\t// Objects aren't sealed by default.\n\tvar empty = {};\n\tassert(Object.isSealed(empty) === false);\n\n\t// If you make an empty object non-extensible, it is vacuously sealed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isSealed(empty) === true);\n\n\t// The same is not true of a non-empty object, unless its properties are all non-configurable.\n\tvar hasProp = { fee: 'fie foe fum' };\n\tObject.preventExtensions(hasProp);\n\tassert(Object.isSealed(hasProp) === false);\n\n\t// But make them all non-configurable and the object becomes sealed.\n\tObject.defineProperty(hasProp, 'fee', { configurable: false });\n\tassert(Object.isSealed(hasProp) === true);\n\n\t// The easiest way to seal an object, of course, is Object.seal.\n\tvar sealed = {};\n\tObject.seal(sealed);\n\tassert(Object.isSealed(sealed) === true);\n\n\t// A sealed object is, by definition, non-extensible.\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// A sealed object might be frozen, but it doesn't have to be.\n\tassert(Object.isFrozen(sealed) === true); // all properties also non-writable\n\n\tvar s2 = Object.seal({ p: 3 });\n\tassert(Object.isFrozen(s2) === false); // 'p' is still writable\n\n\tvar s3 = Object.seal({ get p() { return 0; } });\n\tassert(Object.isFrozen(s3) === true); // only configurability matters for accessor properties\n\n#Notes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n\n\t> Object.isSealed(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isSealed(1)\n\ttrue                          // ES6 code\n\n\n@static\n@param {Object} obj The object which should be checked.\n@returns {boolean}\n*/\n\n\n\n\n\n\n\n/*\n@method keys\n#Summary\nThe Object.keys() method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n#Syntax\n\tObject.keys(obj)\n\n#Examples\n\tvar arr = ['a', 'b', 'c'];\n\tconsole.log(Object.keys(arr)); // console: ['0', '1', '2']\n\n\t// array like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tconsole.log(Object.keys(obj)); // console: ['0', '1', '2']\n\n\t// array like object with random key ordering\n\tvar an_obj = { 100: 'a', 2: 'b', 7: 'c' };\n\tconsole.log(Object.keys(an_obj)); // console: ['2', '7', '100']\n\n\t// getFoo is property which isn't enumerable\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\n\tmy_obj.foo = 1;\n\n\tconsole.log(Object.keys(my_obj)); // console: ['foo']\nIf you want all properties, even not enumerables, see Object.getOwnPropertyNames().\n\n#Polyfill\nTo add compatible Object.keys support in older environments that do not natively support it, copy the following snippet:\n\n\t// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n\tif (!Object.keys) {\n\t  Object.keys = (function() {\n\t    'use strict';\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty,\n\t        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n\t        dontEnums = [\n\t          'toString',\n\t          'toLocaleString',\n\t          'valueOf',\n\t          'hasOwnProperty',\n\t          'isPrototypeOf',\n\t          'propertyIsEnumerable',\n\t          'constructor'\n\t        ],\n\t        dontEnumsLength = dontEnums.length;\n\n\t    return function(obj) {\n\t      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n\t        throw new TypeError('Object.keys called on non-object');\n\t      }\n\n\t      var result = [], prop, i;\n\n\t      for (prop in obj) {\n\t        if (hasOwnProperty.call(obj, prop)) {\n\t          result.push(prop);\n\t        }\n\t      }\n\n\t      if (hasDontEnumBug) {\n\t        for (i = 0; i < dontEnumsLength; i++) {\n\t          if (hasOwnProperty.call(obj, dontEnums[i])) {\n\t            result.push(dontEnums[i]);\n\t          }\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t  }());\n\t}\nPlease note that the above code includes non-enumerable keys in IE7 (and maybe IE8), when passing in an object from a different window.\n\nFor a simple browser polyfill, see Javascript - Object.keys Browser Compatibility.\n\n@static\n@param {Object} obj The object whose enumerable own properties are to be returned.\n@returns {Array<String>} method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n*/\n\n\n\n\n\n\n\n\n/*\n@method preventExtensions\n\n#Summary\nThe Object.preventExtensions() method prevents new properties from ever being added to an object (i.e. prevents future extensions to the object).\n\n#Syntax\n\tObject.preventExtensions(obj)\n\n#Description\nAn object is extensible if new properties can be added to it. Object.preventExtensions() marks an object as no longer extensible, so that it will never have properties beyond the ones it had at the time it was marked as non-extensible. Note that the properties of a non-extensible object, in general, may still be deleted. Attempting to add new properties to a non-extensible object will fail, either silently or by throwing a TypeError (most commonly, but not exclusively, when in strict mode).\n\nObject.preventExtensions() only prevents addition of own properties. Properties can still be added to the object prototype. However, calling Object.preventExtensions() on an object will also prevent extensions on its __proto__  property.\n\nIf there is a way to turn an extensible object to a non-extensible one, there is no way to do the opposite in ECMAScript 5.\n\n#Examples\n\t// Object.preventExtensions returns the object being made non-extensible.\n\tvar obj = {};\n\tvar obj2 = Object.preventExtensions(obj);\n\tassert(obj === obj2);\n\n\t// Objects are extensible by default.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Object.defineProperty throws when adding a new property to a non-extensible object.\n\tvar nonExtensible = { removable: true };\n\tObject.preventExtensions(nonExtensible);\n\tObject.defineProperty(nonExtensible, 'new', { value: 8675309 }); // throws a TypeError\n\n\t// In strict mode, attempting to add new properties to a non-extensible object throws a TypeError.\n\tfunction fail() {\n\t  'use strict';\n\t  nonExtensible.newProperty = 'FAIL'; // throws a TypeError\n\t}\n\tfail();\n\n\t// EXTENSION (only works in engines supporting __proto__\n\t// (which is deprecated. Use Object.getPrototypeOf instead)):\n\t// A non-extensible object's prototype is immutable.\n\tvar fixed = Object.preventExtensions({});\n\tfixed.__proto__ = { oh: 'hai' }; // throws a TypeError\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return it.\n\n\t> Object.preventExtensions(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.preventExtensions(1)\n\t1                             // ES6 code\n\n@static\n@param {Object}obj The object which should be made non-extensible.\n\n*/\n\n\n\n\n\n\n\n/*\n@method hasOwnProperty\n\n#Summary\nThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n#Syntax\n\tobj.hasOwnProperty(prop)\n\n#Description\nEvery object descended from Object inherits the hasOwnProperty method. This method can be used to determine whether an object has the specified property as a direct property of that object; unlike the in operator, this method does not check down the object's prototype chain.\n\n#Examples\n##Example: Using hasOwnProperty to test for a property's existence\n\nThe following example determines whether the o object contains a property named prop:\n\n\to = new Object();\n\to.prop = 'exists';\n\n\tfunction changeO() {\n\t  o.newprop = o.prop;\n\t  delete o.prop;\n\t}\n\n\to.hasOwnProperty('prop');   // returns true\n\tchangeO();\n\to.hasOwnProperty('prop');   // returns false\n\tExample: Direct versus inherited properties\n\n\tThe following example differentiates between direct properties and properties inherited through the prototype chain:\n\n\to = new Object();\n\to.prop = 'exists';\n\to.hasOwnProperty('prop');             // returns true\n\to.hasOwnProperty('toString');         // returns false\n\to.hasOwnProperty('hasOwnProperty');   // returns false\n##Example: Iterating over the properties of an object\n\nThe following example shows how to iterate over the properties of an object without executing on inherit properties. Note that the for...in loop is already only iterating enumerable items, so one should not assume based on the lack of non-enumerable properties shown in the loop that hasOwnProperty itself is confined strictly to enumerable items (as with Object.getOwnPropertyNames()).\n\n\tvar buz = {\n\t  fog: 'stack'\n\t};\n\n\tfor (var name in buz) {\n\t  if (buz.hasOwnProperty(name)) {\n\t    alert('this is fog (' + name + ') for sure. Value: ' + buz[name]);\n\t  }\n\t  else {\n\t    alert(name); // toString or something else\n\t  }\n\t}\n##Example: hasOwnProperty as a property\n\nJavaScript does not protect the property name hasOwnProperty; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an external hasOwnProperty to get correct results:\n\n\tvar foo = {\n\t  hasOwnProperty: function() {\n\t    return false;\n\t  },\n\t  bar: 'Here be dragons'\n\t};\n\n\tfoo.hasOwnProperty('bar'); // always returns false\n\n\t// Use another Object's hasOwnProperty and call it with 'this' set to foo\n\t({}).hasOwnProperty.call(foo, 'bar'); // true\n\n\t// It's also possible to use the hasOwnProperty property from the Object prototype for this purpose\n\tObject.prototype.hasOwnProperty.call(foo, 'bar'); // true\nNote that in the last case there are no newly created objects.\n\n@static \n@param {String}prop The name of the property to test.\n\n*/\n\n\n\n\n\n\n\n/*\n@method  isPrototypeOf\n\n\n#Summary\nThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\nNote: isPrototypeOf differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n#Syntax\n\tprototypeObj.isPrototypeOf(obj)\n#Description\nThe isPrototypeOf method allows you to check whether or not an object exists within another object's prototype chain.\n\nFor example, consider the following prototype chain:\n\n\tfunction Fee() {\n\t  // ...\n\t}\n\n\tfunction Fi() {\n\t  // ...\n\t}\n\tFi.prototype = new Fee();\n\n\tfunction Fo() {\n\t  // ...\n\t}\n\tFo.prototype = new Fi();\n\n\tfunction Fum() {\n\t  // ...\n\t}\n\tFum.prototype = new Fo();\nLater on down the road, if you instantiate Fum and need to check if Fi's prototype exists within the Fum prototype chain, you could do this:\n\n\tvar fum = new Fum();\n\t// ...\n\n\tif (Fi.prototype.isPrototypeOf(fum)) {\n\t  // do something safe\n\t}\nThis, along with the instanceof operator particularly comes in handy if you have code that can only function when dealing with objects descended from a specific prototype chain, e.g., to guarantee that certain methods or properties will be present on that object.\n\n\n@static \n@param {Object} prototypeObj An object to be tested against each link in the prototype chain of the object argument.\n@param {Object}object The object whose prototype chain will be searched.\n@returns {boolean}\n*/\n\n\n\n\n\n\n/*\n\n@method propertyIsEnumerable\n\n#Summary\nThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n#Syntax\n\tobj.propertyIsEnumerable(prop)\n\n#Description\nEvery object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.\n\n#Examples\n##Example: A basic use of propertyIsEnumerable\n\nThe following example shows the use of propertyIsEnumerable on objects and arrays:\n\n\tvar o = {};\n\tvar a = [];\n\to.prop = 'is enumerable';\n\ta[0] = 'is enumerable';\n\n\to.propertyIsEnumerable('prop');   // returns true\n\ta.propertyIsEnumerable(0);        // returns true\n##Example: User-defined versus built-in objects\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n\tvar a = ['is enumerable'];\n\n\ta.propertyIsEnumerable(0);          // returns true\n\ta.propertyIsEnumerable('length');   // returns false\n\n\tMath.propertyIsEnumerable('random');   // returns false\n\tthis.propertyIsEnumerable('Math');     // returns false\n##Example: Direct versus inherited properties\n\n\tvar a = [];\n\ta.propertyIsEnumerable('constructor');         // returns false\n\n\tfunction firstConstructor() {\n\t  this.property = 'is not enumerable';\n\t}\n\n\tfirstConstructor.prototype.firstMethod = function() {};\n\n\tfunction secondConstructor() {\n\t  this.method = function method() { return 'is enumerable'; };\n\t}\n\n\tsecondConstructor.prototype = new firstConstructor;\n\tsecondConstructor.prototype.constructor = secondConstructor;\n\n\tvar o = new secondConstructor();\n\to.arbitraryProperty = 'is enumerable';\n\n\to.propertyIsEnumerable('arbitraryProperty');   // returns true\n\to.propertyIsEnumerable('method');              // returns true\n\to.propertyIsEnumerable('property');            // returns false\n\n\to.property = 'is enumerable';\n\n\to.propertyIsEnumerable('property');            // returns true\n\n\t// These return false as they are on the prototype which \n\t// propertyIsEnumerable does not consider (even though the last two\n\t// are iteratable with for-in)\n\to.propertyIsEnumerable('prototype');   // returns false (as of JS 1.8.1/FF3.6)\n\to.propertyIsEnumerable('constructor'); // returns false\n\to.propertyIsEnumerable('firstMethod'); // returns false\n\n\n@param {String}prop The name of the property to test.\n@return {boolean}\n\n*/\n\n\n\n/*\n@method toLocaleString\n#Summary\nThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n#Syntax\n\tobj.toLocaleString();\n#Description\nObject's toLocaleString returns the result of calling toString().\n\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. See the list below.\n\nObjects overriding toLocaleString\n\n\tArray: Array.prototype.toLocaleString()\n\tNumber: Number.prototype.toLocaleString()\n\tDate: Date.prototype.toLocaleString()\n*/\n\n\n\n/*\n@method toString\n\n#Summary\nThe toString() method returns a string representing object.\n\n#Syntax\n\tobj.toString()\n#Description\nEvery object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected. By default, the toString() method is inherited by every object descended from Object. If this method is not overridden in a custom object, toString() returns \"[object type]\", where type is the object type. The following code illustrates this:\n\n\tvar o = new Object();\n\to.toString();           // returns [object Object]\nNote: Starting in JavaScript 1.8.5 toString() called on null returns [object Null], and undefined returns [object Undefined], as defined in the 5th Edition of ECMAScript and a subsequent Errata. See Using toString to detect object type.\n#Examples\n##Example: Overriding the default toString method\n\nYou can create a function to be called in place of the default toString() method. The toString() method takes no arguments and should return a string. The toString() method you create can be any value you want, but it will be most useful if it carries information about the object.\n\nThe following code defines the Dog object type and creates theDog, an object of type Dog:\n\n\tfunction Dog(name, breed, color, sex) {\n\t  this.name = name;\n\t  this.breed = breed;\n\t  this.color = color;\n\t  this.sex = sex;\n\t}\n\n\ttheDog = new Dog('Gabby', 'Lab', 'chocolate', 'female');\nIf you call the toString() method on this custom object, it returns the default value inherited from Object:\n\n\ttheDog.toString(); // returns [object Object]\nThe following code creates and assigns dogToString() to override the default toString() method. This function generates a string containing the name, breed, color, and sex of the object, in the form \"property = value;\".\n\n\tDog.prototype.toString = function dogToString() {\n\t  var ret = 'Dog ' + this.name + ' is a ' + this.sex + ' ' + this.color + ' ' + this.breed;\n\t  return ret;\n\t}\n\nWith the preceding code in place, any time theDog is used in a string context, JavaScript automatically calls the dogToString() function, which returns the following string:\n\n\tDog Gabby is a female chocolate Lab\n\n##Example: Using toString() to detect object class\n\ntoString() can be used with every object and allows you to get its class. To use the Object.prototype.toString() with every object, you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter called thisArg.\n\n\tvar toString = Object.prototype.toString;\n\n\ttoString.call(new Date);    // [object Date]\n\ttoString.call(new String);  // [object String]\n\ttoString.call(Math);        // [object Math]\n\n\t// Since JavaScript 1.8.5\n\ttoString.call(undefined);   // [object Undefined]\n\ttoString.call(null);        // [object Null]\n\n@return{String}returns a string representing object.\n*/\n\n\n\n\n\n/*\n@method valueOf\n#Summary\nThe valueOf() method returns the primitive value of the specified object.\n\n#Syntax\n\tobject.valueOf()\n#Description\nJavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\n\nBy default, the valueOf method is inherited by every object descended from Object. Every built-in core object overrides this method to return an appropriate value. If an object has no primitive value, valueOf returns the object itself, which is displayed as:\n\n\t[object Object]\nYou can use valueOf within your own code to convert a built-in object into a primitive value. When you create a custom object, you can override Object.prototype.valueOf() to call a custom method instead of the default Object method.\n\n##Overriding valueOf for custom objects\n\nYou can create a function to be called in place of the default valueOf method. Your function must take no arguments.\n\nSuppose you have an object type myNumberType and you want to create a valueOf method for it. The following code assigns a user-defined function to the object's valueOf method:\n\n\tmyNumberType.prototype.valueOf = function() { return customPrimitiveValue; };\nWith the preceding code in place, any time an object of type myNumberType is used in a context where it is to be represented as a primitive value, JavaScript automatically calls the function defined in the preceding code.\n\nAn object's valueOf method is usually invoked by JavaScript, but you can invoke it yourself as follows:\n\n\tmyNumber.valueOf()\nNote: Objects in string contexts convert via the toString() method, which is different from String objects converting to string primitives using valueOf. All objects have a string conversion, if only \"[object type]\". But many objects do not convert to number, boolean, or function.\n#Examples\n##Example: Using valueOf\n\n\to = new Object();\n\tmyVar = o.valueOf();      // [object Object]\n*/\n\n\n\n\n/*\n@method seal\n#Summary\nThe Object.seal() method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.\n\n#Syntax\n\tObject.seal(obj)\n\n#Description\nBy default, objects are extensible (new properties can be added to them). Sealing an object prevents new properties from being added and marks all existing properties as non-configurable. This has the effect of making the set of properties on the object fixed and immutable. Making all properties non-configurable also prevents them from being converted from data properties to accessor properties and vice versa, but it does not prevent the values of data properties from being changed. Attempting to delete or add properties to a sealed object, or to convert a data property to accessor or vice versa, will fail, either silently or by throwing a TypeError (most commonly, although not exclusively, when in strict mode code).\n\nThe prototype chain remains untouched. However, the __proto__  property is sealed as well.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed.\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.seal(obj);\n\n\tassert(o === obj);\n\tassert(Object.isSealed(obj) === true);\n\n\t// Changing property values on a sealed object still works.\n\tobj.foo = 'quux';\n\n\t// But you can't convert data properties to accessors, or vice versa.\n\tObject.defineProperty(obj, 'foo', { get: function() { return 'g'; } }); // throws a TypeError\n\n\t// Now any changes, other than to property values, will fail.\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\tdelete obj.foo; // silently doesn't delete the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors.\n\tfunction fail() {\n\t  'use strict';\n\t  delete obj.foo; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\tfail();\n\n\t// Attempted additions through Object.defineProperty will also throw.\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // changes existing property value\n\n@static \n\n@param  obj The object which should be sealed.\n*/\n\n\n\n\n\n/*\n@class Any\nThis is an artificial type that means 'any value is valid here'\n*/\n\n/*\n\n@module javascript \n\n\n\n@class ObjectPrototype\n\nAdapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\n\n#Description\nThe Object.prototype property represents the Object prototype object.\n\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden (except an Object with a null prototype, i.e. Object.create(null)). For example, other constructors' prototypes override the constructor property and provide their own toString() methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.\n\n#Examples\nSince Javascript doesn't exactly have sub-class objects, prototype is a useful workaround to make a “base class” object of certain functions that act as objects. For example:\n\n\tvar Person = function() {\n\t  this.canTalk = true;\n\t  this.greet = function() {\n\t    if (this.canTalk) {\n\t      console.log('Hi, I'm ' + this.name);\n\t    }\n\t  };\n\t};\n\n\tvar Employee = function(name, title) {\n\t  this.name = name;\n\t  this.title = title;\n\t  this.greet = function() {\n\t    if (this.canTalk) {\n\t      console.log(\"Hi, I'm \" + this.name + \", the \" + this.title);\n\t    }\n\t  };\n\t};\n\tEmployee.prototype = new Person();\n\n\tvar Customer = function(name) {\n\t  this.name = name;\n\t};\n\tCustomer.prototype = new Person();\n\n\tvar Mime = function(name) {\n\t  this.name = name;\n\t  this.canTalk = false;\n\t};\n\tMime.prototype = new Person();\n\n\tvar bob = new Employee('Bob', 'Builder');\n\tvar joe = new Customer('Joe');\n\tvar rg = new Employee('Red Green', 'Handyman');\n\tvar mike = new Customer('Mike');\n\tvar mime = new Mime('Mime');\n\tbob.greet();\n\tjoe.greet();\n\trg.greet();\n\tmike.greet();\n\tmime.greet();\n\nThis will output:\n\n\tHi, I'm Bob, the Builder\n\tHi, I'm Joe\n\tHi, I'm Red Green, the Handyman\n\tHi, I'm Mike\n\n*/\n\n\n\n/*\n\n\n\n@property {Function} constructor Specifies the function that creates an object's prototype.\n\n##Summary\nReturns a reference to the Object function that created the instance's prototype. Note that the value of this property is a reference to the function itself, not a string containing the function's name. The value is only read-only for primitive values such as 1, true and \"test\".\n\n##Description\n\nAll objects inherit a constructor property from their prototype:\n\n\tvar o = {};\n\to.constructor === Object; // true\n\n\tvar a = [];\n\ta.constructor === Array; // true\n\n\tvar n = new Number(3);\n\tn.constructor === Number; // true\n\n##Examples\n\n###Example: Displaying the constructor of an object\n\nThe following example creates a prototype, Tree, and an object of that type, theTree. The example then displays the constructor property for the object theTree.\n\n\tfunction Tree(name) {\n\t  this.name = name;\n\t}\n\n\tvar theTree = new Tree('Redwood');\n\tconsole.log('theTree.constructor is ' + theTree.constructor);\n\tThis example displays the following output:\n\n\ttheTree.constructor is function Tree(name) {\n\t  this.name = name;\n\t}\n\n###Example: Changing the constructor of an object\n\nThe following example shows how to modify constructor value of generic objects. Only true, 1 and \"test\" will not be affected as they have read-only native constructors. This example shows that it is not always safe to rely on the constructor property of an object.\n\n\tfunction Type () {}\n\n\tvar types = [\n\t  new Array(),\n\t  [],\n\t  new Boolean(),\n\t  true,             // remains unchanged\n\t  new Date(),\n\t  new Error(),\n\t  new Function(),\n\t  function () {},\n\t  Math,\n\t  new Number(),\n\t  1,                // remains unchanged\n\t  new Object(),\n\t  {},\n\t  new RegExp(),\n\t  /(?:)/,\n\t  new String(),\n\t  'test'            // remains unchanged\n\t];\n\tfor (var i = 0; i < types.length; i++) {\n\t  types[i].constructor = Type;\n\t  types[i] = [types[i].constructor, types[i] instanceof Type, types[i].toString()];\n\t}\n\tconsole.log(types.join('\\n'));\n\tThis example displays the following output:\n\n\tfunction Type() {},false,\n\tfunction Type() {},false,\n\tfunction Type() {},false,false\n\tfunction Boolean() {\n\t    [native code]\n\t},false,true\n\tfunction Type() {},false,Mon Sep 01 2014 16:03:49 GMT+0600\n\tfunction Type() {},false,Error\n\tfunction Type() {},false,function anonymous() {\n\n\t}\n\tfunction Type() {},false,function () {}\n\tfunction Type() {},false,[object Math]\n\tfunction Type() {},false,0\n\tfunction Number() {\n\t    [native code]\n\t},false,1\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,\n\tfunction String() {\n\t    [native code]\n\t},false,тест\n\n*/\n\n\n\n\n\n\n\n/*\n@property {Object} __proto__ \nPoints to the object which was used as prototype when the object was instantiated.\n\n@property {Function} __noSuchMethod__ \nAllows a function to be defined that will be executed when an undefined object member is called as a method.\n*/\n\n\n\n/* \n@module javascript\n\n@class String\n\n#Summary\nThe String global object is a constructor for strings, or a sequence of characters.\n\n#Syntax\nString literals take the forms:\n\n\t'string text' \"string text\" \"中文 español English हिन्दी العربية português বাংলা русский 日本語 ਪੰਜਾਬੀ 한국어\"\n\nBeside regular, printable characters, special characters can be encoded using escape notation:\n\n\tCode\tOutput\n\t\\0\tthe NUL character\n\t\\'\tsingle quote\n\t\\\"\tdouble quote\n\t\\\\\tbackslash\n\t\\n\tnew line\n\t\\r\tcarriage return\n\t\\v\tvertical tab\n\t\\t\ttab\n\t\\b\tbackspace\n\t\\f\tform feed\n\t\\uXXXX\tunicode codepoint\n\t\\xXX\tthe Latin-1 character\n\nOr, using the String global object directly:\n\n\tString(thing) new String(thing)\n\n#Description\nStrings are useful for holding data that can be represented in text form. Some of the most-used operations on strings are to check their length, to build and concatenate them using the + and += string operators, checking for the existence or location of substrings with the indexOf method, or extracting substrings with the substring method.\n\n##Character access\n\nThere are two ways to access an individual character in a string. The first is the charAt method:\n\n\treturn 'cat'.charAt(1); // returns \"a\"\n\nThe other way (introduced in ECMAScript 5) is to treat the string as an array-like object, where individual characters correspond to a numerical index:\n\n\treturn 'cat'[1]; // returns \"a\"\n\nFor character access using bracket notation, attempting to delete or assign a value to these properties will not succeed. The properties involved are neither writable nor configurable. (See Object.defineProperty for more information.)\n\n##Comparing strings\n\nC developers have the strcmp() function for comparing strings. In JavaScript, you just use the less-than and greater-than operators:\n\n\tvar a = \"a\";\n\tvar b = \"b\";\n\tif (a < b) // true\n\t  print(a + \" is less than \" + b);\n\telse if (a > b)\n\t  print(a + \" is greater than \" + b);\n\telse\n\t  print(a + \" and \" + b + \" are equal.\");\n\nA similar result can be achieved using the localeCompare method inherited by String instances.\n\n##Distinction between string primitives and String objects\n\nNote that JavaScript distinguishes between String objects and primitive string values. (The same is true of Boolean and Numbers.)\n\nString literals (denoted by double or single quotes) and strings returned from String calls in a non-constructor context (i.e., without using the new keyword) are primitive strings. JavaScript automatically converts primitives to String objects, so that it's possible to use String object methods for primitive strings. In contexts where a method is to be invoked on a primitive string or a property lookup occurs, JavaScript will automatically wrap the string primitive and call the method or perform the property lookup.\n\n\tvar s_prim = \"foo\";\n\tvar s_obj = new String(s_prim);\n\n\tconsole.log(typeof s_prim); // Logs \"string\"\n\tconsole.log(typeof s_obj);  // Logs \"object\"\n\tString primitives and String objects also give different results when using eval. Primitives passed to eval are treated as source code; String objects are treated as all other objects are, by returning the object. For example:\n\n\ts1 = \"2 + 2\";               // creates a string primitive\n\ts2 = new String(\"2 + 2\");   // creates a String object\n\tconsole.log(eval(s1));      // returns the number 4\n\tconsole.log(eval(s2));      // returns the string \"2 + 2\"\n\nFor these reasons, code may break when it encounters String objects when it expects a primitive string instead, although generally authors need not worry about the distinction.\n\nA String object can always be converted to its primitive counterpart with the valueOf method.\n\n\tconsole.log(eval(s2.valueOf())); // returns the number 4\n\nNote: For another possible approach to strings in JavaScript, please read the article about StringView – a C-like representation of strings based on typed arrays.\n\n\n#String generic methods\nThe String instance methods are also available in Firefox as of JavaScript 1.6 (though not part of the ECMAScript standard) on the String object for applying String methods to any object:\n\n\tvar num = 15;\n\talert(String.replace(num, /5/, '2'));\n\nGenerics are also available on Array methods.\n\nThe following is a shim to provide support to non-supporting browsers:\n\n\t//globals define\n\t// Assumes all supplied String instance methods already present\n\t// (one may use shims for these if not available)\n\t(function () {\n\t    'use strict';\n\n\t    var i,\n\t        // We could also build the array of methods with the following, but the\n\t        //   getOwnPropertyNames() method is non-shimable:\n\t        // Object.getOwnPropertyNames(String).filter(function (methodName)\n\t        //  {return typeof String[methodName] === 'function'});\n\t        methods = [\n\t            'quote', 'substring', 'toLowerCase', 'toUpperCase', 'charAt',\n\t            'charCodeAt', 'indexOf', 'lastIndexOf', 'startsWith', 'endsWith',\n\t            'trim', 'trimLeft', 'trimRight', 'toLocaleLowerCase',\n\t            'toLocaleUpperCase', 'localeCompare', 'match', 'search',\n\t            'replace', 'split', 'substr', 'concat', 'slice'\n\t        ],\n\t        methodCount = methods.length,\n\t        assignStringGeneric = function (methodName) {\n\t            var method = String.prototype[methodName];\n\t            String[methodName] = function (arg1) {\n\t                return method.apply(arg1, Array.prototype.slice.call(arguments, 1));\n\t            };\n\t        };\n\n\t    for (i = 0; i < methodCount; i++) {\n\t        assignStringGeneric(methods[i]);\n\t    }\n\t}());\n\n#Examples\n##String conversion\n\nIt's possible to use String as a \"safer\" toString alternative, as although it still normally calls the underlying toString, it also works for null and undefined. For example:\n\n\tvar outputStrings = [];\n\tfor (let i = 0, n = inputValues.length; i < n; ++i) {\n\t  outputStrings.push(String(inputValues[i]));\n\t}\n\n*/\n\n\n\n\n\n\n/*\n@property {Number} length\n\n#Summary\nThe length property represents the length of a string.\n\n#Syntax\n\n\tstr.length\n\n#Description\n\nThis property returns the number of code units in the string. UTF-16, the string format used by JavaScript, uses a single 16-bit code unit to represent the most common characters, but needs to use two code units for less commonly-used characters, so it's possible for the value returned by length to not match the actual number of characters in the string.\n\nFor an empty string, length is 0.\n\nThe static property String.length returns the value 1.\n\n#Examples\n\n\tvar x = \"Mozilla\";\n\tvar empty = \"\";\n\n\tconsole.log(\"Mozilla is \" + x.length + \" code units long\");\n\t// \"Mozilla is 7 code units long\" \n\n\tconsole.log(\"The empty string is has a length of \" + empty.length);\n\t // \"The empty string is has a length of 0\" \n\n*/\n\n\n\n\n/*\n@method fromCharCode\n\n#Summary\nThe static String.fromCharCode() method returns a string created by using the specified sequence of Unicode values.\n\n#Syntax\nString.fromCharCode(num1, ..., numN)\n#Description\nThis method returns a string and not a String object.\n\nBecause fromCharCode is a static method of String, you always use it as String.fromCharCode(), rather than as a method of a String object you created.\n\n#Examples\nExample: Using fromCharCode\n\nThe following example returns the string \"ABC\".\n\n\tString.fromCharCode(65,66,67)\n\n#Getting it to work with higher values\nAlthough most common Unicode values can be represented with one 16-bit number (as expected early on during JavaScript standardization) and fromCharCode() can be used to return a single character for the most common values (i.e., UCS-2 values which are the subset of UTF-16 with the most common characters), in order to deal with ALL legal Unicode values (up to 21 bits), fromCharCode() alone is inadequate. Since the higher code point characters use two (lower value) \"surrogate\" numbers to form a single character, String.fromCodePoint() (part of the ES6 draft) can be used to return such a pair and thus adequately represent these higher valued characters.\n\n@return {String}  returns a string created by using the specified sequence of Unicode values.}\n\n@param p1,...pn A sequence of numbers that are Unicode values\n\n*/\n\n\n\n\n\n\n\n/*\n@method charAt\n\n\n#Summary\nThe charAt() method returns the specified character from a string.\n\n#Syntax\n\tstr.charAt(index)\n#Description\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string called stringName is stringName.length - 1. If the index you supply is out of range, JavaScript returns an empty string.\n\n#Examples\n##Example: Displaying characters at different locations in a string\n\nThe following example displays characters at different locations in the string \"Brave new world\":\n\n\tvar anyString = \"Brave new world\";\n\n\tconsole.log(\"The character at index 0   is '\" + anyString.charAt(0)   + \"'\");\n\tconsole.log(\"The character at index 1   is '\" + anyString.charAt(1)   + \"'\");\n\tconsole.log(\"The character at index 2   is '\" + anyString.charAt(2)   + \"'\");\n\tconsole.log(\"The character at index 3   is '\" + anyString.charAt(3)   + \"'\");\n\tconsole.log(\"The character at index 4   is '\" + anyString.charAt(4)   + \"'\");\n\tconsole.log(\"The character at index 999 is '\" + anyString.charAt(999) + \"'\");\n\nThese lines display the following:\n\n\tThe character at index 0 is 'B'\n\tThe character at index 1 is 'r'\n\tThe character at index 2 is 'a'\n\tThe character at index 3 is 'v'\n\tThe character at index 4 is 'e'\n\tThe character at index 999 is ''\n\n##Example: Getting whole characters\n\nThe following provides a means of ensuring that going through a string loop always provides a whole character, even if the string contains characters that are not in the Basic Multi-lingual Plane.\n\n\tvar str = 'A \\uD87E\\uDC04 Z'; // We could also use a non-BMP character directly\n\tfor (var i=0, chr; i < str.length; i++) {\n\t  if ((chr = getWholeChar(str, i)) === false) {\n\t    continue;\n\t  } // Adapt this line at the top of each loop, passing in the whole string and\n\t    // the current iteration and returning a variable to represent the \n\t    // individual character\n\n\t  alert(chr);\n\t}\n\n\tfunction getWholeChar (str, i) {\n\t  var code = str.charCodeAt(i);     \n\t \n\t  if (isNaN(code)) {\n\t    return ''; // Position not found\n\t  }\n\t  if (code < 0xD800 || code > 0xDFFF) {\n\t    return str.charAt(i);\n\t  }\n\n\t  // High surrogate (could change last hex to 0xDB7F to treat high private\n\t  // surrogates as single characters)\n\t  if (0xD800 <= code && code <= 0xDBFF) { \n\t    if (str.length <= (i+1))  {\n\t      throw 'High surrogate without following low surrogate';\n\t    }\n\t    var next = str.charCodeAt(i+1);\n\t      if (0xDC00 > next || next > 0xDFFF) {\n\t        throw 'High surrogate without following low surrogate';\n\t      }\n\t      return str.charAt(i)+str.charAt(i+1);\n\t  }\n\t  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n\t  if (i === 0) {\n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  var prev = str.charCodeAt(i-1);\n\t  \n\t  // (could change last hex to 0xDB7F to treat high private\n\t  // surrogates as single characters)\n\t  if (0xD800 > prev || prev > 0xDBFF) { \n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  // We can pass over low surrogates now as the second component\n\t  // in a pair which we have already processed\n\t  return false; \n\t}\n\nIn an exclusive JavaScript 1.7+ environment (such as Firefox) which allows destructured assignment, the following is a more succinct and somewhat more flexible alternative in that it does incrementing for an incrementing variable automatically (if the character warrants it in being a surrogate pair).\n\n\tvar str = 'A\\uD87E\\uDC04Z'; // We could also use a non-BMP character directly\n\tfor (var i=0, chr; i < str.length; i++) {\n\t  [chr, i] = getWholeCharAndI(str, i);\n\t  // Adapt this line at the top of each loop, passing in the whole string and\n\t  // the current iteration and returning an array with the individual character\n\t  // and 'i' value (only changed if a surrogate pair)\n\n\t  alert(chr);\n\t}\n\n\tfunction getWholeCharAndI (str, i) {\n\t  var code = str.charCodeAt(i);\n\n\t  if (isNaN(code)) {\n\t    return ''; // Position not found\n\t  }\n\t  if (code < 0xD800 || code > 0xDFFF) {\n\t    return [str.charAt(i), i]; // Normal character, keeping 'i' the same\n\t  }\n\n\t  // High surrogate (could change last hex to 0xDB7F to treat high private \n\t  // surrogates as single characters)\n\t  if (0xD800 <= code && code <= 0xDBFF) { \n\t    if (str.length <= (i+1))  {\n\t      throw 'High surrogate without following low surrogate';\n\t    }\n\t    var next = str.charCodeAt(i+1);\n\t      if (0xDC00 > next || next > 0xDFFF) {\n\t        throw 'High surrogate without following low surrogate';\n\t      }\n\t      return [str.charAt(i)+str.charAt(i+1), i+1];\n\t  }\n\t  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n\t  if (i === 0) {\n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  var prev = str.charCodeAt(i-1);\n\n\t  // (could change last hex to 0xDB7F to treat high private surrogates\n\t  // as single characters)\n\t  if (0xD800 > prev || prev > 0xDBFF) { \n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  // Return the next character instead (and increment)\n\t  return [str.charAt(i+1), i+1]; \n\t}\n\n\n##Example: Fixing charAt to support non-Basic-Multilingual-Plane (BMP) characters\n\nWhile the example above may be more frequently useful for those wishing to support non-BMP characters (since it does not require the caller to know where any non-BMP character might appear), in the event that one does wish, in choosing a character by index, to treat the surrogate pairs within a string as the single characters they represent, one can use the following:\n\n\tfunction fixedCharAt (str, idx) {\n\t  var ret = '';\n\t  str += '';\n\t  var end = str.length;\n\n\t  var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t  while ((surrogatePairs.exec(str)) != null) {\n\t    var li = surrogatePairs.lastIndex;\n\t    if (li - 2 < idx) {\n\t      idx++;\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\n\t  if (idx >= end || idx < 0) {\n\t    return '';\n\t  }\n\n\t  ret += str.charAt(idx);\n\n\t  if (/[\\uD800-\\uDBFF]/.test(ret) && /[\\uDC00-\\uDFFF]/.test(str.charAt(idx+1))) {\n\t    // Go one further, since one of the \"characters\" is part of a surrogate pair\n\t    ret += str.charAt(idx+1); \n\t  }\n\t  return ret;\n\t}\n\n\n@param {Number} index An integer between 0 and 1-less-than the length of the string.\n@return {String} the specified character from a string.\n\n*/\n\n\n\n\n/*\n@method charCodeAt\n\n#Summary\nThe charCodeAt() method returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000).\n\n#Syntax\n\tstr.charCodeAt(index)\n#Description\nUnicode code points range from 0 to 1,114,111. The first 128 Unicode code points are a direct match of the ASCII character encoding. For information on Unicode, see the JavaScript Guide.\n\nNote that charCodeAt will always return a value that is less than 65,536. This is because the higher code points are represented by a pair of (lower valued) \"surrogate\" pseudo-characters which are used to comprise the real character. Because of this, in order to examine or reproduce the full character for individual characters of value 65,536 and above, for such characters, it is necessary to retrieve not only charCodeAt(i), but also charCodeAt(i+1) (as if examining/reproducing a string with two letters). See example 2 and 3 below.\n\ncharCodeAt returns NaN if the given index is not greater than 0 or is greater than the length of the string.\n\nBackward compatibilty: In historic versions (like JavaScript 1.2) the charCodeAt method returns a number indicating the ISO-Latin-1 codeset value of the character at the given index. The ISO-Latin-1 codeset ranges from 0 to 255. The first 0 to 127 are a direct match of the ASCII character set.\n\n#Examples\n##Example: Using charCodeAt\n\nThe following example returns 65, the Unicode value for A.\n\n\t\"ABC\".charCodeAt(0) // returns 65\n\n#Example: Fixing charCodeAt to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is unknown\n\nThis version might be used in for loops and the like when it is unknown whether non-BMP characters exist before the specified index position.\n\n\tfunction fixedCharCodeAt (str, idx) {\n\t    // ex. fixedCharCodeAt ('\\uD800\\uDC00', 0); // 65536\n\t    // ex. fixedCharCodeAt ('\\uD800\\uDC00', 1); // false\n\t    idx = idx || 0;\n\t    var code = str.charCodeAt(idx);\n\t    var hi, low;\n\t    \n\t    // High surrogate (could change last hex to 0xDB7F to treat high\n\t    // private surrogates as single characters)\n\t    if (0xD800 <= code && code <= 0xDBFF) {\n\t        hi = code;\n\t        low = str.charCodeAt(idx+1);\n\t        if (isNaN(low)) {\n\t            throw 'High surrogate not followed by low surrogate in fixedCharCodeAt()';\n\t        }\n\t        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate\n\t        // We return false to allow loops to skip this iteration since should have\n\t        // already handled high surrogate above in the previous iteration\n\t        return false;\n\t        //hi = str.charCodeAt(idx-1);\n\t        //low = code;\n\t        //return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    return code;\n\t}\n\n##Example: Fixing charCodeAt to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is known\n\n\tfunction knownCharCodeAt (str, idx) {\n\t    str += '';\n\t    var code,\n\t        end = str.length;\n\n\t    var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t    while ((surrogatePairs.exec(str)) != null) {\n\t        var li = surrogatePairs.lastIndex;\n\t        if (li - 2 < idx) {\n\t            idx++;\n\t        }\n\t        else {\n\t            break;\n\t        }\n\t    }\n\n\t    if (idx >= end || idx < 0) {\n\t        return NaN;\n\t    }\n\n\t    code = str.charCodeAt(idx);\n\n\t    var hi, low;\n\t    if (0xD800 <= code && code <= 0xDBFF) {\n\t        hi = code;\n\t        low = str.charCodeAt(idx+1);\n\t        // Go one further, since one of the \"characters\" is part of a surrogate pair\n\t        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    return code;\n\t}\n\n\n@param {Number} index\nAn integer greater than or equal to 0 and less than the length of the string; if it is not a number, it defaults to 0.\n\n@returns {Number}returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000).\n\n*/\n\n\n\n\n\n/*\n@method concat\n\n\n#Summary\nThe concat() method combines the text of two or more strings and returns a new string.\n\n#Syntax\n\tstr.concat(string2, string3[, ..., stringN])\n\n#Description\nThe concat function combines the text from one or more strings and returns a new string. Changes to the text in one string do not affect the other string.\n\n#Examples\n##Example: Using concat\n\nThe following example combines strings into a new string.\n\n\tvar hello = \"Hello, \";\n\tconsole.log(hello.concat(\"Kevin\", \" have a nice day.\")); \n\n\t// Hello, Kevin have a nice day. \n\n#Performance\nIt is strongly recommended that assignment operators (+, +=) are used instead of the concat method. See this perfomance test.\n\n@param string2...stringN Strings to concatenate to this string.\n\n@return {String}\n*/\n\n\n\n\n/*\n@method indexOf\n\n#Summary\nThe indexOf() method returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.\n\n#Syntax\n\tstr.indexOf(searchValue[, fromIndex])\n#Description\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character of a string called stringName is stringName.length - 1.\n\n\t\"Blue Whale\".indexOf(\"Blue\");     // returns  0\n\t\"Blue Whale\".indexOf(\"Blute\");    // returns -1\n\t\"Blue Whale\".indexOf(\"Whale\", 0); // returns  5\n\t\"Blue Whale\".indexOf(\"Whale\", 5); // returns  5\n\t\"Blue Whale\".indexOf(\"\", 9);      // returns  9\n\t\"Blue Whale\".indexOf(\"\", 10);     // returns 10\n\t\"Blue Whale\".indexOf(\"\", 11);     // returns 10\n\n##Case-sensitivity\n\nThe indexOf method is case sensitive. For example, the following expression returns -1:\n\n\"Blue Whale\".indexOf(\"blue\") // returns -1\n##Checking occurrences\n\nNote that '0' doesn't evaluate to true and '-1' doesn't evaluate to false. Therefore, when checking if a specific string exists within another string the correct way to check would be:\n\n\"Blue Whale\".indexOf(\"Blue\") != -1; // true\n\"Blue Whale\".indexOf(\"Bloe\") != -1; // false\n\n#Examples\n##Example: Using indexOf and lastIndexOf\n\nThe following example uses indexOf and lastIndexOf to locate values in the string \"Brave new world\".\n\n\tvar anyString = \"Brave new world\";\n\n\tconsole.log(\"The index of the first w from the beginning is \" + anyString.indexOf(\"w\"));\n\t// Displays 8\n\tconsole.log(\"The index of the first w from the end is \" + anyString.lastIndexOf(\"w\")); \n\t// Displays 10\n\n\tconsole.log(\"The index of 'new' from the beginning is \" + anyString.indexOf(\"new\"));   \n\t// Displays 6\n\tconsole.log(\"The index of 'new' from the end is \" + anyString.lastIndexOf(\"new\"));\n\t// Displays 6\n##Example: indexOf and case-sensitivity\n\nThe following example defines two string variables. The variables contain the same string except that the second string contains uppercase letters. The first log method displays 19. But because the indexOf method is case sensitive, the string \"cheddar\" is not found in myCapString, so the second log method displays -1.\n\n\tvar myString    = \"brie, pepper jack, cheddar\";\n\tvar myCapString = \"Brie, Pepper Jack, Cheddar\";\n\n\tconsole.log('myString.indexOf(\"cheddar\") is ' + myString.indexOf(\"cheddar\"));    \n\t// Displays 19\n\tconsole.log('myCapString.indexOf(\"cheddar\") is ' + myCapString.indexOf(\"cheddar\")); \n\t// Displays -1\n##Example: Using indexOf to count occurrences of a letter in a string\n\nThe following example sets count to the number of occurrences of the letter x in the string str:\n\n\tcount = 0;\n\tpos = str.indexOf(\"x\");\n\n\twhile ( pos != -1 ) {\n\t   count++;\n\t   pos = str.indexOf( \"x\",pos + 1 );\n\t}\n\n\n@param {String} searchValue A string representing the value to search for.\n@param {Number} fromIndex The location within the calling string to start the search from. It can be any integer. The default value is 0. If fromIndex < 0 the entire string is searched (same as passing 0). If fromIndex >= str.length, the method will return -1 unless searchValue is an empty string in which case str.length is returned. \n@optional\n@returns {Number} the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.\n*/","classes":{"ideal.BaseObject":{"annotation":"class","name":"BaseObject","text":"","commentRange":[2,73],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideal","text":"","commentRange":[2,73],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideal.BaseObject","properties":{"creationDate":{"annotation":"property","type":"{Date}","name":"creationDate","text":"","commentRange":[185,346],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"name":{"annotation":"property","type":"{String}","name":"name","text":"","commentRange":[185,346],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"description":{"annotation":"property","type":"{String}","name":"description","text":"","commentRange":[185,346],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"owners":{"annotation":"property","type":"{Object<String,User>}","name":"owners","text":"the owners, a map by owner id","commentRange":[185,346],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"ideal.ObjectPool":{"annotation":"class","name":"ObjectPool","text":"","commentRange":[373,392],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideal","text":"","commentRange":[2,73],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideal.ObjectPool","methods":{"loadObjects":{"annotation":"method","name":"loadObjects","text":"","children":[{"annotation":"param","type":"{Array<String>}","name":"objects_ids","text":"","theRestString":"@return {Object<String,BaseObject>}"},{"annotation":"return","type":"{Object<String,BaseObject>}","text":"","theRestString":""}],"commentRange":[418,510],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"params":{"objects_ids":{"annotation":"param","type":"{Array<String>}","name":"objects_ids","text":"","commentRange":[581,618],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"getState0":{"annotation":"method","name":"getState0","text":"","children":[{"annotation":"returns","type":"{a:B231,c:D231,s:String}","text":"","theRestString":""}],"commentRange":[730,1072],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"getState2":{"annotation":"method","name":"getState2","text":"","children":[{"annotation":"returns","type":"{a:B231,c:D231}","text":"","theRestString":""}],"commentRange":[730,1072],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"getState3":{"annotation":"method","name":"getState3","text":"","children":[{"annotation":"re","name":"turns","text":"{#obj(color:String)}","theRestString":""}],"commentRange":[730,1072],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"getState4":{"annotation":"method","name":"getState4","text":"","children":[{"annotation":"returns","type":"{name:String,colors:Array<Color>,car:Car}","text":"","theRestString":""}],"commentRange":[730,1072],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"getState":{"annotation":"method","name":"getState","text":"get's the current state of this pool","children":[{"annotation":"returns","type":"{id:String,objectDic:Object<String>}","name":"bla","text":"bla bla","theRestString":""}],"commentRange":[730,1072],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"getOwners":{"annotation":"method","name":"getOwners","text":"this method is useful for *blabla* blabla _blabla_ bab","commentRange":[1103,1177],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}},"events":{"objectCreated":{"annotation":"event","name":"objectCreated","text":"event fired when an object is created in this pool.","commentRange":[1292,1367],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"ideal.Thing":{"annotation":"class","name":"Thing","text":"","children":[{"annotation":"extends","name":"BaseObject","text":"","theRestString":""}],"commentRange":[1481,1547],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideal","text":"","commentRange":[2,73],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideal.Thing","properties":{"importance":{"annotation":"property","type":"{Number}","name":"importance","text":"","commentRange":[1481,1547],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"ideal.Action":{"annotation":"class","name":"Action","text":"","children":[{"annotation":"extends","name":"BaseObject","text":"","theRestString":""}],"commentRange":[1662,1702],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideal","text":"","commentRange":[2,73],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideal.Action","methods":{"extract":{"annotation":"method","name":"extract","text":"","children":[{"annotation":"param","type":"{String|BaseObject|Array<BaseObject>}","name":"what","text":"","theRestString":""}],"commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"ideasAndProblems67.Idea":{"annotation":"class","name":"Idea","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideasAndProblems67.Idea"},"ideasAndProblems67.Problem":{"annotation":"class","name":"Problem","text":"","children":[{"annotation":"extends","name":"Idea","text":"","theRestString":"@param {Number} complexity"},{"annotation":"param","type":"{Number}","name":"complexity","text":"","theRestString":""}],"commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideasAndProblems67.Problem"},"ideasAndProblems67.IdealProblem":{"annotation":"class","name":"IdealProblem","text":"","children":[{"annotation":"extends","name":"Problem","text":"","theRestString":""}],"commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideasAndProblems67.IdealProblem"},"ideasAndProblems67.MathProblem":{"annotation":"class","name":"MathProblem","text":"","children":[{"annotation":"extends","name":"IdealProblem","text":"","theRestString":""}],"commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideasAndProblems67.MathProblem","properties":{"equations":{"annotation":"property","type":"{Object<String,Equation>}","name":"equations","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"ideasAndProblems67.Equation":{"annotation":"class","name":"Equation","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideasAndProblems67.Equation","methods":{"resolve":{"annotation":"method","name":"resolve","text":"invoke this method to solve the equation","children":[{"annotation":"throws","type":"{EquationError}","name":"kja","text":"shkdj ahsd","theRestString":""}],"commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}},"events":{"afterThatHappens":{"annotation":"event","name":"afterThatHappens","text":"triggered when you-know-who comes the handler must be a ....","children":[{"annotation":"returns","type":"{Solution}","name":"because","text":"we are very practical","theRestString":""}],"commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"ideasAndProblems67.Solution":{"annotation":"class","name":"Solution","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideasAndProblems67.Solution"},"ideasAndProblems67.EquationError":{"annotation":"class","name":"EquationError","text":"","children":[{"annotation":"extends","name":"Error","text":"","theRestString":""}],"commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"ideasAndProblems67.EquationError"},"pretty.names_9.A.Real.World.Name_123":{"annotation":"class","name":"A.Real.World.Name_123","text":"lorem ipsum liprim trogus","commentRange":[2459,2736],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"pretty.names_9","text":"lorem ipsum liprim trogus","commentRange":[2459,2736],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"pretty.names_9.A.Real.World.Name_123"},"pretty.names_9.Other.Real.Name_234":{"annotation":"class","name":"Other.Real.Name_234","text":"lorem ipsum liprim trogus","children":[{"annotation":"extends","name":"A.Real.World.Name_123","text":"","theRestString":""}],"commentRange":[2459,2736],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"pretty.names_9","text":"lorem ipsum liprim trogus","commentRange":[2459,2736],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"pretty.names_9.Other.Real.Name_234","properties":{"children":{"annotation":"property","type":"{Array<A.Real.World.Name_123>}","name":"children","text":"lorem ipsum liprim trogus","commentRange":[2459,2736],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"life.Living":{"annotation":"class","name":"Living","text":"","children":[{"annotation":"extends","name":"Thing","text":"","theRestString":""}],"commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"life","text":"","commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"life.Living","methods":{"breath":{"annotation":"method","name":"breath","text":"","children":[{"annotation":"param","type":"{Number}","name":"size","text":"","theRestString":""}],"commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"life.Animal":{"annotation":"class","name":"Animal","text":"","children":[{"annotation":"extends","name":"Living","text":"","theRestString":""}],"commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"life","text":"","commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"life.Animal","methods":{"eat":{"annotation":"method","name":"eat","text":"","children":[{"annotation":"param","type":"{Array<Food>}","name":"food","text":"","theRestString":"@return {Array<Energy>}"},{"annotation":"return","type":"{Array<Energy>}","text":"","theRestString":""}],"commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"life.Person":{"annotation":"class","name":"Person","text":"","children":[{"annotation":"extends","name":"Animal","text":"","theRestString":""}],"commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"life","text":"","commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"life.Person","methods":{"walk":{"annotation":"method","name":"walk","text":"","children":[{"annotation":"return","type":"{Action}","text":"","theRestString":""}],"commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"crossStreet":{"annotation":"method","name":"crossStreet","text":"This try to be a markdown [text](http://google.com)\n\nAnother paragraph \n\n\tvar someMarkup = {\n\t\ta: 1\n\t,\tn: 2\n\t,\tg: function (e)\n\t\t{\n\t\t\treturn 1;\n\t\t}\n\t};\n\nand some final text with a list\n\n1. First ordered list item\n2. Another item\n  * Unordered sub-list.\n1. Actual numbers don't matter, just that it's a number\n  1. Ordered sub-list\n  2. hello\n4. And another item.","commentRange":[2984,3372],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"problem1.TerranObject":{"annotation":"class","name":"TerranObject","text":"","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.TerranObject"},"problem1.Person":{"annotation":"class","name":"Person","text":"","children":[{"annotation":"extends","name":"TerranObject","text":"","theRestString":""}],"commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.Person"},"problem1.List":{"annotation":"class","name":"List","text":"This is just a semantic alias for javascript Array.","children":[{"annotation":"extends","name":"Array","text":"","theRestString":""}],"commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.List"},"problem1.Map":{"annotation":"class","name":"Map","text":"This is just a semantic alias for javascript Object.","children":[{"annotation":"extends","name":"Object","text":"","theRestString":""}],"commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.Map"},"problem1.Building":{"annotation":"class","name":"Building","text":"","children":[{"annotation":"extends","name":"TerranObject","text":"","theRestString":""}],"commentRange":[3731,3773],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.Building"},"problem1.Hospital":{"annotation":"class","name":"Hospital","text":"","children":[{"annotation":"extends","name":"Building","text":"","theRestString":""}],"commentRange":[3775,4334],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.Hospital","constructors":[{"annotation":"constructor","name":"n","text":"Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...","children":[{"annotation":"param","type":"{Number}","name":"availableBeds","text":"Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...","theRestString":""}],"commentRange":[3775,4334],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"params":[{"annotation":"param","type":"{Number}","name":"availableBeds","text":"Neque porro quisquam est qui _dolorem_ *ipsum* quia dolor sit amet, consectetur, adipisci velit...","theRestString":""}],"throws":[]}],"methods":{"getActiveDoctors":{"annotation":"method","name":"getActiveDoctors","text":"","children":[{"annotation":"returns","type":"{List<Doctor>}","name":"the","text":"currently active doctors in this hospital","theRestString":""}],"commentRange":[3775,4334],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}},"properties":{"todayIngresedPatients":{"annotation":"property","type":"{Array<Person>}","name":"todayIngresedPatients","text":"all the patiens that entered this hospital today","commentRange":[3775,4334],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"problem1.Doctor":{"annotation":"class","name":"Doctor","text":"","children":[{"annotation":"extend","name":"Person","text":"","theRestString":""}],"commentRange":[3775,4334],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.Doctor","properties":{"skills":{"annotation":"property","type":"{Map<String,MedicalTopic>}","name":"skills","text":"","commentRange":[3775,4334],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"problem1.MedicalTopic":{"annotation":"class","name":"MedicalTopic","text":"Lorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum","commentRange":[4336,5528],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.MedicalTopic","methods":{"beUsed":{"annotation":"method","name":"beUsed","text":"Lorem *ipsum* dolor sit amet, consectetur adipisicing elit, \n\n\tsed do eiusmod tempor \n\tincididunt ut labore et dolore \n\tmagna aliqua. \n\t\tUt enim ad minim \n\t\t\tveniam, quis nostrud exercitation\n\t\t\tullamco laboris nisi ut aliquip ex \n\t\tea commodo consequat. Duis aute irure dolor\n\tin reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \n\nExcepteur sint occaecat *cupidatat* non proident, sunt in culpa qui officia deserunt mollit anim id est laborum","children":[{"annotation":"throws","type":"{MedicalException}","name":"if","text":"there is any medical issue stuff...","theRestString":"@param {Number} amount Excepteur sint occaecat *cupidatat* \n\n@return {Array<MedicalTopic>}"},{"annotation":"param","type":"{Number}","name":"amount","text":"Excepteur sint occaecat *cupidatat*","theRestString":"@return {Array<MedicalTopic>}"},{"annotation":"return","type":"{Array<MedicalTopic>}","text":"","theRestString":""}],"commentRange":[4336,5528],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"problem1.MedicalException":{"annotation":"class","name":"MedicalException","text":"","children":[{"annotation":"extends","name":"Error","text":"","theRestString":""}],"commentRange":[4336,5528],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.MedicalException"},"problem1.TypeBinding":{"annotation":"class","name":"TypeBinding","text":"a datatype with an association between types names in source code and parsed class nodes. It support generic types (recursive)","commentRange":[53681,54286],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.TypeBinding","properties":{"type":{"annotation":"property","type":"{TypeBinding}","name":"type","text":"","commentRange":[53681,54286],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"params":{"annotation":"property","type":"{Array<TypeBinding>}","name":"params","text":"- the generic types params array. For example the params for {Map<String,Apple>} is [StringBynding]","commentRange":[53681,54286],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"nativeTypeUrl":{"annotation":"property","type":"{String}","name":"nativeTypeUrl","text":"- if this is a native type - this","commentRange":[53681,54286],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}}}},"problem1.JsDocMaker":{"annotation":"class","name":"JsDocMaker","text":"\n\nMain jsdoc parser utility. It accepts a valid js source code String and returns a JavaScript object with a jsdoc AST, this is an object with classes and modules array that users can use to easily access jsdocs information, for example, parsed.classes.Apple.methods.getColor use the parseFile method for this! This will return the AST, if you want to perform more enrichment and type binding, then use postProccess and postProccessBinding methods after.","commentRange":[53681,54286],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"module":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"absoluteName":"problem1.JsDocMaker","methods":{"parseTypeString":{"annotation":"method","name":"parseTypeString","text":"","children":[{"annotation":"return","type":"{TypeBinding}","name":"or","text":"nulll in case the given type cannot be parsed TODO: support multiple generics and generics anidation like in","theRestString":""}],"commentRange":[53681,54286],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"parseSingleTypeString":{"annotation":"method","name":"parseSingleTypeString","text":"","children":[{"annotation":"param","type":"{String}","name":"typeStr","text":"","theRestString":""}],"commentRange":[54807,54863],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"bindParsedType":{"annotation":"method","name":"bindParsedType","text":"merges the data of JsDocMaker.parseType with bindings of current jsdoc. recursive!","children":[{"annotation":"param","type":"{Object}","name":"typeObject","text":"","theRestString":"@param {Object} baseClass @return {Object}"},{"annotation":"param","type":"{Object}","name":"baseClass","text":"","theRestString":"@return {Object}"},{"annotation":"return","type":"{Object}","text":"","theRestString":""}],"commentRange":[56980,57159],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"bindClass":{"annotation":"method","name":"bindClass","text":"","children":[{"annotation":"param","type":"{String}","name":"name","text":"","theRestString":"@param {Object} baseClass TODO: using a internal map this could be done faster"},{"annotation":"param","type":"{Object}","name":"baseClass","text":"TODO: using a internal map this could be done faster","theRestString":""}],"commentRange":[58170,58290],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"simpleName":{"annotation":"method","name":"simpleName","text":"","children":[{"annotation":"param","type":"{String}","name":"name","text":"","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[59178,59237],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"require":{"annotation":"method","name":"require","text":"perform an intelligent require n browser&nodejs, needed for esprima. Ugly :(","commentRange":[60614,60708],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"jsdoc":{"annotation":"method","name":"jsdoc","text":"the public method to parse all the added files with addFile.","children":[{"annotation":"return","type":"{Object}","name":"the","text":"parsed object","theRestString":"@param {String} source . Optional"},{"annotation":"param","type":"{String}","name":"source","text":". Optional","theRestString":""}],"commentRange":[61552,61697],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"parseFile":{"annotation":"method","name":"parseFile","text":"a public method for parsing a single file. Note if you want to parse more than one file please use addFile() and the jsdoc()","children":[{"annotation":"return","type":"{Object}","name":"the","text":"parsed object","theRestString":"@param {String} source @param {String} filename"},{"annotation":"param","type":"{String}","name":"source","text":"","theRestString":"@param {String} filename"},{"annotation":"param","type":"{String}","name":"filename","text":"","theRestString":""}],"commentRange":[62167,62397],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"addFile":{"annotation":"method","name":"addFile","text":"","children":[{"annotation":"param","type":"{String}","name":"source","text":"the source code of the file","theRestString":"@param {String} the file name"},{"annotation":"param","type":"{String}","name":"the","text":"file name","theRestString":""}],"commentRange":[62522,62620],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"parse":{"annotation":"method","name":"parse","text":"a object literal type string like ''","children":[{"annotation":"return","type":"{Object}","name":"the","text":"parsed object","theRestString":"@static dummy"},{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[78190,78286],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"parseUnit":{"annotation":"method","type":"{Unit}","name":"parseUnit","text":"parse a simple substring like '@annotation {Type} a text' into an object {annotation, type, text} object. syntax:","commentRange":[67273,67502],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"methodName":{"annotation":"method","type":"{String}","name":"methodName","text":"blabla","children":[{"annotation":"return","type":"{Number}","name":"blabla","text":"","theRestString":"@param {Object} p1 blabla"},{"annotation":"param","type":"{Object}","name":"p1","text":"blabla","theRestString":""}],"commentRange":[67273,67502],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"parseUnitSimple":{"annotation":"method","name":"parseUnitSimple","text":"","children":[{"annotation":"param","type":"{String}","name":"str","text":"","theRestString":"@param {ASTSprimaNode} comment"},{"annotation":"param","type":"{ASTSprimaNode}","name":"comment","text":"","theRestString":""}],"commentRange":[68102,68178],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"postProccess":{"annotation":"method","name":"postProccess","text":"so the data is already parsed but we want to normalize some children like","children":[{"annotation":"extend","name":"and","text":"@ module to be properties of the unit instead children. Also we enforce explicit parent reference, this is a class must reference its parent module and a method muest reference its parent class. Also related to this is the fullname property that will return an unique full name in the format '$MODULE.$CLASS.$METHOD'. We assume that a module contains unique named classes and that classes contain unique named properties and methods.","theRestString":""}],"commentRange":[69487,70055],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"postProccessBinding":{"annotation":"method","name":"postProccessBinding","text":"precondion: call postProccess() first. We separated the post proccessing in two because we shouln't do JSON.stringify() after we bind types because of recursive loops.","commentRange":[70522,70720],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"preprocessComments":{"annotation":"method","name":"preprocessComments","text":"do an initial preprocesing on the comments erasing those marked to be ignored, and fixing its text to support alternative syntax.","commentRange":[74702,74885],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"fixUnamedAnnotations":{"annotation":"method","name":"fixUnamedAnnotations","text":"- our regexp format expect an anotation with a name. So for enabling unamed annotations we do this dirty fix, this is add a name to precondition","commentRange":[75715,75893],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"unifyLineComments":{"annotation":"method","name":"unifyLineComments","text":"unify adjacents Line comment nodes into one in the ns.syntax.coments generated after visiting.","commentRange":[76505,76629],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"parseType":{"annotation":"method","name":"parseType","text":"parse a type string like 'Map<String,Array<Apple>>' or 'String' and return an object like {name: 'Map',params:['String',{name: 'Array',params:['Apple']}]}. This is the default type parser. It depends on type parser file typeParser.js","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[77623,77903],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"splitAndPreserve":{"annotation":"method","name":"splitAndPreserve","text":"search for given regexp and split the given string but preserving the matches","children":[{"annotation":"param","type":"{Regexp}","name":"regexp","text":"must contain a capturing group (like /(\\s+@\\w+)/gi)","theRestString":"@return {Array of string} @static dummy"},{"annotation":"return","type":"{Array of string}","text":"@static dummy","theRestString":""}],"commentRange":[78787,79031],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"stringFullTrim":{"annotation":"method","name":"stringFullTrim","text":"","children":[{"annotation":"param","type":"{String}","name":"s","text":"","theRestString":"@static dummy"},{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[79317,79367],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"stringTrim":{"annotation":"method","name":"stringTrim","text":"","children":[{"annotation":"param","type":"{String}","name":"s","text":"","theRestString":"@static dummy"},{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[79493,79539],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"stringEndsWith":{"annotation":"method","name":"stringEndsWith","text":"","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[80221,80253],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"postProccessInherited":{"annotation":"method","name":"postProccessInherited","text":"calculates inherited methods&properties and put it in class'properties inheritedMethods and inheritedProperties","commentRange":[96213,96415],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"extractInherited":{"annotation":"method","name":"extractInherited","text":"","children":[{"annotation":"param","name":"baseClass","text":"","theRestString":"@param c @param what @para data"},{"annotation":"param","name":"c","text":"","theRestString":"@param what @para data"},{"annotation":"param","name":"what","text":"","theRestString":"@para data"},{"annotation":"para","name":"data","text":"","theRestString":""}],"commentRange":[97154,97229],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"isClassOwner":{"annotation":"method","name":"isClassOwner","text":"utility method for knowing if a property is defined in given class or is inherithed","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param aClass @param prop"},{"annotation":"param","name":"aClass","text":"","theRestString":"@param prop"},{"annotation":"param","name":"prop","text":"","theRestString":""}],"commentRange":[98607,98749],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"params":{"undefined":{"annotation":"param","text":"{#obj({p1:P1,p2:P2,...})} param1 CUSTOM TPE PLUGIN literalObjectParse - requires literalObjectParser.js - it adds support for the custom type syntax #obj({p1:P1,p2:P2,...})to express literal objects syntax: {#obj(prop1:String,prop2:Array<Apple>)} DEPRECATED - turn it into a unit test showing an example of plugin","commentRange":[99093,99549],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"literalObjectParse":{"annotation":"method","name":"literalObjectParse","text":"","commentRange":[99093,99549],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"installModifiers":{"annotation":"method","name":"installModifiers","text":"sets the property modifiers to the node according its children","commentRange":[101090,101179],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"getNativeTypeUrl":{"annotation":"method","name":"getNativeTypeUrl","text":"","children":[{"annotation":"returns","type":"{String}","name":"an","text":"url if given name match a native types or undefined otherwise","theRestString":""}],"commentRange":[101868,101976],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"recurseAST":{"annotation":"method","name":"recurseAST","text":"An utility method that can be used in extensions to visit all the ast nodes with given function","children":[{"annotation":"param","type":"{Function}","name":"fn","text":"","theRestString":""}],"commentRange":[102591,102731],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}},"properties":{"customNativeTypes":{"annotation":"property","type":"{Object<String,String>}","name":"customNativeTypes","text":"name to url map that the user can modify to register new native types b givin its url.","commentRange":[60010,60150],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"commentPreprocessors":{"annotation":"property","type":"{Array<Function>}","name":"commentPreprocessors","text":"","commentRange":[61423,61501],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"all":{"annotation":"property","type":"{Array<String>}","name":"all","text":"the input added included","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"the":{"annotation":"property","type":"{EsprimaSyntax}","name":"the","text":"Sprima Syntax object of the current pased file.","commentRange":[61934,62015],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"ignoreCommentPrefix":{"annotation":"property","type":"{String}","name":"ignoreCommentPrefix","text":"","commentRange":[62795,62835],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"and":{"annotation":"property","name":"and","text":"","commentRange":[66501,66547],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"postProccessors":{"annotation":"property","type":"{Array<Function>}","name":"postProccessors","text":"","commentRange":[69377,69441],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"lineCommentSeparator":{"annotation":"property","type":"{String}","name":"lineCommentSeparator","text":"used to separate each Line comment type text","commentRange":[76699,76785],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"MODIFIERS":{"annotation":"property","type":"{Array<String>}","name":"MODIFIERS","text":"","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[100860,100979],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}},"events":{"are":{"annotation":"event","name":"are","text":"treated similarly","commentRange":[66501,66547],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"shortjsdoc.AbstractView":{"annotation":"class","name":"AbstractView","text":"","children":[{"annotation":"extend","name":"Backbone.View","text":"","theRestString":""}],"commentRange":[103140,103223],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"\n\nthis is the main class for all the application utilities for rendering jsdoc data generated by jsdocgenerator1 js-indentator plugin using backbone. The user should provide with underscore templates.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nthis file add methods to Abstract Application for dealing with types and html markup.","commentRange":[103140,103223],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.AbstractView","methods":{"renderIn":{"annotation":"method","name":"renderIn","text":"renders this view in given parent element","children":[{"annotation":"param","type":"{jQuery}","name":"$parent","text":"","theRestString":""}],"commentRange":[103364,103448],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"render":{"annotation":"method","name":"render","text":"implemented to comply with Backbone View contract","commentRange":[103706,103772],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"printTag":{"annotation":"method","name":"printTag","text":"","commentRange":[118311,118329],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"simpleName":{"annotation":"method","name":"simpleName","text":"","children":[{"annotation":"param","type":"{String}","name":"name","text":"","theRestString":""}],"commentRange":[118576,118616],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"makeLink":{"annotation":"method","name":"makeLink","text":"","children":[{"annotation":"param","type":"{boolean}","name":"htmlAnchors","text":"will output anchor elements html","theRestString":""}],"commentRange":[118704,118784],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"printType":{"annotation":"method","name":"printType","text":"prints a type as html support generic. This is really a html template function","children":[{"annotation":"param","type":"{Object}","name":"context","text":"","theRestString":"@return {String} the type html"},{"annotation":"return","type":"{String}","name":"the","text":"type html","theRestString":""}],"commentRange":[120195,120353],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"printTypeAsString":{"annotation":"method","name":"printTypeAsString","text":"","children":[{"annotation":"param","type":"{Array<Type>|Type}","name":"type","text":"","theRestString":"@return {String} the type html"},{"annotation":"return","type":"{String}","name":"the","text":"type html","theRestString":""}],"commentRange":[121783,121872],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"getTextHtml":{"annotation":"method","name":"getTextHtml","text":"depends on lib/marked/ - all texts should be printed using this method","commentRange":[122191,122283],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"printMethod":{"annotation":"method","name":"printMethod","text":"","commentRange":[122776,122797],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"shortjsdoc.Application":{"annotation":"class","name":"Application","text":"","commentRange":[104041,104376],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","children":[{"annotation":"author","text":": sgurin","theRestString":""}],"commentRange":[104041,104376],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.Application","constructors":[{"annotation":"constructor","name":"n","text":"Application","children":[{"annotation":"param","type":"{Object}","name":"data","text":"is the data.json object outputed by running \n\t\n\tvar maker = new JsDocMaker();\n\tmaker.parseFile(myCodeString);\n\tmaker.postProccess();\n\tvar data = maker.data;","theRestString":""}],"commentRange":[104377,104588],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"params":[{"annotation":"param","type":"{Object}","name":"data","text":"is the data.json object outputed by running \n\t\n\tvar maker = new JsDocMaker();\n\tmaker.parseFile(myCodeString);\n\tmaker.postProccess();\n\tvar data = maker.data;","theRestString":""}],"throws":[]}],"properties":{"textFormat":{"annotation":"property","type":"{String}","name":"textFormat","text":"can be markdown or html. default: markdown","commentRange":[104625,104700],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"templates":{"annotation":"property","type":"{Object}","name":"templates","text":"The templates dictionary (given by template-output.js)","commentRange":[104736,104821],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"data":{"annotation":"property","type":"{Object}","name":"data","text":"is the data.json object outputed by running:\t\n\n\t\tvar maker = new JsDocMaker();\n\t\tmaker.parseFile(myCodeString);\n\t\tmaker.postProccess();\n\t\tvar data = maker.data;","commentRange":[104855,105046],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"maker":{"annotation":"property","type":"{JsDocMaker}","name":"maker","text":"the JsDocMaker instance we will use for loading the parsed data and doing some post processing stage (type binding and so)","commentRange":[105070,105223],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}},"methods":{"start":{"annotation":"method","name":"start","text":"an application loading it with given data.","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param data the output of passing jsindentator JsDocMaker."},{"annotation":"param","name":"data","text":"the output of passing jsindentator JsDocMaker.","theRestString":""}],"commentRange":[106655,106783],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showView":{"annotation":"method","name":"showView","text":"","children":[{"annotation":"param","type":"{AbstractView}","name":"view","text":"","theRestString":""}],"commentRange":[106041,106086],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"refreshWithNewModel":{"annotation":"method","name":"refreshWithNewModel","text":"","children":[{"annotation":"param","type":"{Object}","name":"data","text":"","theRestString":""}],"commentRange":[106307,106356],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showErrorView":{"annotation":"method","name":"showErrorView","text":"","children":[{"annotation":"param","type":"{String}","name":"s","text":"","theRestString":""}],"commentRange":[106516,106557],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"shortjsdoc.ApplicationView":{"annotation":"class","name":"ApplicationView","text":"","children":[{"annotation":"extends","name":"AbstractView","text":"","theRestString":""}],"commentRange":[106889,106956],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[106889,106956],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.ApplicationView"},"shortjsdoc.ClassView":{"annotation":"class","name":"ClassView","text":"","children":[{"annotation":"extends","name":"AbstractView","text":"","theRestString":""}],"commentRange":[107565,107626],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[107565,107626],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.ClassView"},"shortjsdoc.HeaderView":{"annotation":"class","name":"HeaderView","text":"","children":[{"annotation":"extends","name":"AbstractView","text":"","theRestString":""}],"commentRange":[108843,108905],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[108843,108905],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.HeaderView"},"shortjsdoc.IndexView":{"annotation":"class","name":"IndexView","text":"","children":[{"annotation":"extends","name":"AbstractView","text":"","theRestString":""}],"commentRange":[110793,110854],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[110793,110854],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.IndexView"},"shortjsdoc.JsDocRouter":{"annotation":"class","name":"JsDocRouter","text":"","children":[{"annotation":"extends","name":"BackboneRouter","text":"","theRestString":""}],"commentRange":[110941,111006],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[110941,111006],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.JsDocRouter","methods":{"showView":{"annotation":"method","name":"showView","text":"","children":[{"annotation":"param","type":"{AbstractView}","name":"view","text":"","theRestString":"@param {String} resourceName"},{"annotation":"param","type":"{String}","name":"resourceName","text":"","theRestString":""}],"commentRange":[111500,111573],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showModule":{"annotation":"method","name":"showModule","text":"","children":[{"annotation":"param","type":"{String}","name":"moduleName","text":"","theRestString":""}],"commentRange":[111836,111884],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showClass":{"annotation":"method","name":"showClass","text":"","children":[{"annotation":"param","type":"{String}","name":"className","text":"","theRestString":""}],"commentRange":[112280,112326],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showMethod":{"annotation":"method","name":"showMethod","text":"","children":[{"annotation":"param","type":"{String}","name":"method","text":"","theRestString":""}],"commentRange":[112539,112583],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showProperty":{"annotation":"method","name":"showProperty","text":"","children":[{"annotation":"param","type":"{String}","name":"property","text":"","theRestString":""}],"commentRange":[112702,112750],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showEvent":{"annotation":"method","name":"showEvent","text":"","children":[{"annotation":"param","type":"{String}","name":"event","text":"","theRestString":""}],"commentRange":[112877,112919],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showModules":{"annotation":"method","name":"showModules","text":"","commentRange":[113043,113064],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showClasses":{"annotation":"method","name":"showClasses","text":"","commentRange":[113201,113222],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showIndex":{"annotation":"method","name":"showIndex","text":"","commentRange":[113359,113378],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"showParse":{"annotation":"method","name":"showParse","text":"","commentRange":[113494,113513],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"shortjsdoc.MethodView":{"annotation":"class","name":"MethodView","text":"","children":[{"annotation":"extends","name":"AbstractView","text":"","theRestString":""}],"commentRange":[113634,113696],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[113634,113696],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.MethodView"},"shortjsdoc.ModuleView":{"annotation":"class","name":"ModuleView","text":"","children":[{"annotation":"extends","name":"AbstractView","text":"","theRestString":""}],"commentRange":[114650,114712],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[114650,114712],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.ModuleView"},"shortjsdoc.ParseView":{"annotation":"class","name":"ParseView","text":"","children":[{"annotation":"extends","name":"AbstractView","text":"","theRestString":""}],"commentRange":[115141,115202],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[115141,115202],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.ParseView"},"shortjsdoc.PropertyView":{"annotation":"class","name":"PropertyView","text":"","children":[{"annotation":"extends","name":"AbstractView","text":"","theRestString":""}],"commentRange":[115687,115751],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[115687,115751],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.PropertyView"},"shortjsdoc.SourcesView":{"annotation":"class","name":"SourcesView","text":"","children":[{"annotation":"extends","name":"AbstractView","text":"","theRestString":""}],"commentRange":[116494,116557],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"shortjsdoc","text":"","commentRange":[116494,116557],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"shortjsdoc.SourcesView"},"javascript.Boolean":{"annotation":"class","name":"Boolean","text":"#Summary\nThe Boolean object is an object wrapper for a boolean value.\n\n#Constructor\n\tnew Boolean(value)\n\n#Description\nThe value passed as the first parameter is converted to a boolean value, if necessary. If value is omitted or is 0, -0, null, false, NaN, undefined, or the empty string (\"\"), the object has an initial value of false. All other values, including any object or the string \"false\", create an object with an initial value of true.\n\nDo not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.\n\nAny object whose value is not undefined or null, including a Boolean object whose value is false, evaluates to true when passed to a conditional statement. For example, the condition in the following if statement evaluates to true:\n\n\tx = new Boolean(false);\n\tif (x) {\n\t  // . . . this code is executed\n\t}\n\tThis behavior does not apply to Boolean primitives. For example, the condition in the following if statement evaluates to false:\n\n\tx = false;\n\tif (x) {\n\t  // . . . this code is not executed\n\t}\nDo not use a Boolean object to convert a non-boolean value to a boolean value. Instead, use Boolean as a function to perform this task:\n\n\tx = Boolean(expression);     // preferred\n\tx = new Boolean(expression); // don't use\n\tIf you specify any object, including a Boolean object whose value is false, as the initial value of a Boolean object, the new Boolean object has a value of true.\n\n\tmyFalse = new Boolean(false);   // initial value of false\n\tg = new Boolean(myFalse);       // initial value of true\n\tmyString = new String(\"Hello\"); // string object\n\ts = new Boolean(myString);      // initial value of true\n\tDo not use a Boolean object in place of a Boolean primitive.\n\n#Properties\nFor properties available on Boolean instances, see Properties of Boolean instances.\n\nBoolean.length\nLength property whose value is 1.\nBoolean.prototype\nRepresents the prototype for the Boolean constructor.\n#Properties inherited from Function:\narity, caller, constructor, length, name\n##Methods\nFor methods available on Boolean instances, see Methods of Boolean instances.\n\nThe global Boolean object contains no methods of its own, however, it does inherit some methods through the prototype chain:\n\n#Methods inherited from Function:\napply, call, toSource, toString\n\n#Boolean instances\nAll Boolean instances inherit from Boolean.prototype. As with all constructors, the prototype object dictates instances' inherited properties and methods.\n\n#Properties\n\nBoolean.prototype.constructor\nReturns the function that created an instance's prototype. This is the Boolean function by default.\nProperties inherited from Object:\n__parent__, __proto__\n#Methods\n\nBoolean.prototype.toSource() \nReturns a string containing the source of the Boolean object; you can use this string to create an equivalent object. Overrides the Object.prototype.toSource() method.\nBoolean.prototype.toString()\nReturns a string of either \"true\" or \"false\" depending upon the value of the object. Overrides the Object.prototype.toString() method.\nBoolean.prototype.valueOf()\nReturns the primitive value of the Boolean object. Overrides the Object.prototype.valueOf() method.\n\n\n#Examples\nCreating Boolean objects with an initial value of false\n\n\tvar bNoParam = new Boolean();\n\tvar bZero = new Boolean(0);\n\tvar bNull = new Boolean(null);\n\tvar bEmptyString = new Boolean(\"\");\n\tvar bfalse = new Boolean(false);\n\tCreating Boolean objects with an initial value of true\n\n\tvar btrue = new Boolean(true);\n\tvar btrueString = new Boolean(\"true\");\n\tvar bfalseString = new Boolean(\"false\");\n\tvar bSuLin = new Boolean(\"Su Lin\");","commentRange":[124295,127963],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[124295,127963],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.Boolean","methods":{"valueOf":{"annotation":"method","name":"valueOf","text":"#Summary\nThe valueOf() method returns the primitive value of a Boolean object.\n\n#Syntax\n\tbool.valueOf()\n\n#Description\nThe valueOf method of Boolean returns the primitive value of a Boolean object or literal Boolean as a Boolean data type.\n\nThis method is usually called internally by JavaScript and not explicitly in code.\n\n#Examples\n##Example: Using valueOf\n\n\tx = new Boolean();\n\tmyVar = x.valueOf()      // assigns false to myVar","commentRange":[127966,128419],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"javascript.Error":{"annotation":"class","name":"Error","text":"#Summary\nThe Error constructor creates an error object. Instances of Error objects are thrown when runtime errors occur. The Error object can also be used as a base objects for user-defined exceptions. See below for standard built-in error types.\n\n#Syntax\n\tnew Error([message[, fileName[,lineNumber]]])\n#Description\nRuntime errors result in new Error objects being created and thrown.\n\nThis page documents the use of the Error object itself and its use as a constructor function. For a list of properties and methods inherited by Error instances, see Error.prototype.\n\n#Error types\n\nBesides the generic Error constructor, there are six other core error constructors in JavaScript. For client-side exceptions, see Exception Handling Statements.\n\n\tEvalError\n\tCreates an instance representing an error that occurs regarding the global function eval().\n\tInternalError \n\tCreates an instance representing an error that occurs when an internal error in the JavaScript engine is thrown. E.g. \"too much recursion\".\n\tRangeError\n\tCreates an instance representing an error that occurs when a numeric variable or parameter is outside of its valid range.\n\tReferenceError\n\tCreates an instance representing an error that occurs when de-referencing an invalid reference.\n\tSyntaxError\n\tCreates an instance representing a syntax error that occurs while parsing code in eval().\n\tTypeError\n\tCreates an instance representing an error that occurs when a variable or parameter is not of a valid type.\n\tURIError\n\tCreates an instance representing an error that occurs when encodeURI() or decodeURl() are passed invalid parameters.\n\n#Properties\nError.prototype\nAllows the addition of properties to Error instances.\n#Methods\nThe global Error object contains no methods of its own, however, it does inherit some methods through the prototype chain.\n\n#Error instances\nAll Error instances and instances of non-generic errors inherit from Error.prototype. As with all constructor functions, you can use the prototype of the constructor to add properties or methods to all instances created with that constructor.\n\n#Properties\n\n##Standard properties\n\nError.prototype.constructor\nSpecifies the function that created an instance's prototype.\n\tError.prototype.message\n\tError message.\n\tError.prototype.name\n\tError name.\n\n\n#Vendor-specific extensions\n\n##Non-standard\nThis feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.\n##Microsoft\n\n\tError.prototype.description\n\tError description. Similar to message.\n\tError.prototype.number\n\tError number.\n##Mozilla\n\n\tError.prototype.fileName\n\tPath to file that raised this error.\n\tError.prototype.lineNumber\n\tLine number in file that raised this error.\n\tError.prototype.columnNumber\n\tColumn number in line that raised this error.\n\tError.prototype.stack\n\tStack trace.\n\n#Examples\n##Example: Throwing a generic error\n\nUsually you create an Error object with the intention of raising it using the throw keyword. You can handle the error using the try...catch construct:\n\n\ttry {\n\t  throw new Error(\"Whoops!\");\n\t} catch (e) {\n\t  alert(e.name + \": \" + e.message);\n\t}\n\tExample: Handling a specific error\n\n\tYou can choose to handle only specific error types by testing the error type with the error's constructor property or, if you're writing for modern JavaScript engines, instanceof keyword:\n\n\ttry {\n\t  foo.bar();\n\t} catch (e) {\n\t  if (e instanceof EvalError) {\n\t    alert(e.name + \": \" + e.message);\n\t  } else if (e instanceof RangeError) {\n\t    alert(e.name + \": \" + e.message);\n\t  }\n\t  // ... etc\n\t}\n##Custom Error Types\n\nYou might want to define your own error types deriving from Error to be able to throw new MyError() and use instanceof MyError to check the kind of error in the exception handler. The common way to do this is demonstrated below.\n\nNote that the thrown MyError will report incorrect lineNumber and fileName at least in Firefox.\nSee also the \"What's a good way to extend Error in JavaScript?\" discussion on Stackoverflow.\n\n\t// Create a new object, that prototypally inherits from the Error constructor.\n\tfunction MyError(message) {\n\t  this.name = \"MyError\";\n\t  this.message = message || \"Default Message\";\n\t}\n\tMyError.prototype = new Error();\n\tMyError.prototype.constructor = MyError;\n\n\ttry {\n\t  throw new MyError();\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"Default Message\"\n\t}\n\n\ttry {\n\t  throw new MyError(\"custom message\");\n\t} catch (e) {\n\t  console.log(e.name);     // \"MyError\"\n\t  console.log(e.message);  // \"custom message\"\n\t}","commentRange":[128421,133155],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[128421,133155],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.Error","constructors":[{"annotation":"constructor","name":"n","text":"Boolean","children":[{"annotation":"param","type":"{String}","name":"message","text":"Human-readable description of the error","theRestString":"@param {String} fileName The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.\n@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."},{"annotation":"param","type":"{String}","name":"fileName","text":"The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.","theRestString":"@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."},{"annotation":"param","type":"{Number}","name":"lineNumber","text":"The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation.","theRestString":""}],"commentRange":[133157,133597],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"params":[{"annotation":"param","type":"{String}","name":"message","text":"Human-readable description of the error","theRestString":"@param {String} fileName The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.\n@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."},{"annotation":"param","type":"{String}","name":"fileName","text":"The value for the fileName property on the created Error object. Defaults to the name of the file containing the code that called the Error() constructor.","theRestString":"@param {Number} lineNumber The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation."},{"annotation":"param","type":"{Number}","name":"lineNumber","text":"The value for the lineNumber property on the created Error object. Defaults to the line number containing the Error() constructor invocation.","theRestString":""}],"throws":[]}],"properties":{"message":{"annotation":"property","type":"{String}","name":"message","text":"#Summary\nThe message property is a human-readable description of the error.\n\n#Description\nThis property contains a brief description of the error if one is available or has been set. SpiderMonkey makes extensive use of the message property for exceptions. The message property combined with the name property is used by the Error.prototype.toString() method to create a string representation of the Error.\n\nBy default, the message property is an empty string, but this behavior can be overridden for an instance by specifying a message as the first argument to the Error constructor.\n\n#Examples\n##Example: Throwing a custom error\n\n\tvar e = new Error(\"Could not parse input\"); // e.message is \"Could not parse input\"\n\tthrow e;","commentRange":[133601,134360],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"name":{"annotation":"property","type":"{String}","name":"name","text":"#Summary\nThe name property represents a name for the type of error. The initial value is \"Error\".\n\n#Description\nBy default, Error instances are given the name \"Error\". The name property, in addition to the message property, is used by the Error.prototype.toString() method to create a string representation of the error.\n\n#Examples\n##Example: Throwing a custom error\n\n\tvar e = new Error(\"Malformed input\"); // e.name is \"Error\"\n\n\te.name = \"ParseError\"; \n\tthrow e;\n\t// e.toString() would return \"ParseError: Malformed input\"","commentRange":[134366,134920],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"javascript.EvalError":{"annotation":"class","name":"EvalError","text":"","children":[{"annotation":"extends","name":"Error","text":"The EvalError object indicates an error regarding the global eval() function.","theRestString":""}],"commentRange":[134925,135040],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[128421,133155],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.EvalError"},"javascript.RangeError":{"annotation":"class","name":"RangeError","text":"","children":[{"annotation":"extends","name":"Error","text":"The RangeError object indicates an error when a value is not in the set or range of allowed values.\n\nA RangeError is thrown when trying to pass a number as an argument to a function that does not allow a range that includes that number. This can be encountered when to create an array of an illegal length with the Array constructor, or when passing bad values to the numeric methods Number.toExponential(), Number.toFixed() or Number.toPrecision().","theRestString":""}],"commentRange":[135042,135531],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[128421,133155],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.RangeError"},"javascript.ReferenceError":{"annotation":"class","name":"ReferenceError","text":"","children":[{"annotation":"extends","name":"Error","text":"#Summary\nThe ReferenceError object represents an error when a non-existent variable is referenced.\n\n#Description\nA ReferenceError is thrown when trying to dereference a variable that has not been declared.","theRestString":""}],"commentRange":[135534,135782],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[128421,133155],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.ReferenceError"},"javascript.SyntaxError":{"annotation":"class","name":"SyntaxError","text":"","children":[{"annotation":"extends","name":"Error","text":"#Summary\nThe SyntaxError object represents an error when trying to interpret syntactically invalid code.\n\n#Description\nA SyntaxError is thrown when the JavaScript engine encounters tokens or token order that does not conform to the syntax of the language when parsing code.","theRestString":""}],"commentRange":[135786,136100],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[128421,133155],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.SyntaxError"},"javascript.TypeError":{"annotation":"class","name":"TypeError","text":"","children":[{"annotation":"extends","name":"Error","text":"The TypeError object represents an error when a value is not of the expected type.","theRestString":""}],"commentRange":[136103,136223],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[128421,133155],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.TypeError"},"javascript.URIError":{"annotation":"class","name":"URIError","text":"","children":[{"annotation":"extends","name":"Error","text":"The URIError object represents an error when a global URI handling function was used in a wrong way.","theRestString":""}],"commentRange":[136225,136363],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[128421,133155],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.URIError"},"javascript.Function":{"annotation":"class","name":"Function","text":"#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.","commentRange":[136366,136595],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[136366,136595],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.Function","properties":{"length":{"annotation":"property","type":"{Number}","name":"length","text":"#Summary\nThe length property specifies the number of arguments expected by the function.\n\n#Description\nlength is a property of a function object, and indicates how many arguments the function expects, i.e. the number of formal parameters. This number does not include the rest parameter. By contrast, arguments.length is local to a function and provides the number of arguments actually passed to the function.\n\nData property of the Function constructor\n\nThe Function constructor is itself a Function object. It's length data property has a value of 1. The property attributes are: Writable: false, Enumerable: false, Configurable: true.\n\nProperty of the Function prototype object\n\nThe length property of the Function prototype object has a value of 0.\n\n#Examples\n\tconsole.log ( Function.length ); //1\n\n\tconsole.log( (function ()        {}).length ); //0\n\tconsole.log( (function (a)       {}).length ); //1\n\tconsole.log( (function (a, b)    {}).length ); //2 etc. \n\tconsole.log( (function (...args) {}).length ); //0, rest parameter is no","commentRange":[136598,137670],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"prototype":{"annotation":"property","type":"{FunctionPrototype}","name":"prototype","text":"#Summary\nThe Function.prototype property represents the Function prototype object.\n\n#Description\nFunction objects inherit from Function.prototype.  Function.prototype cannot be modified.","commentRange":[137673,137905],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}},"methods":{"apply":{"annotation":"method","name":"apply","text":"The apply() method calls a function with a given this value and arguments provided as an array (or an array-like object).\n\nNote: While the syntax of this function is almost identical to that of call(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.apply(thisArg, [argsArray])\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object. With apply, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\napply is very similar to call(), except for the type of arguments it supports. You can use an arguments array instead of a named set of parameters. With apply, you can use an array literal, for example, fun.apply(this, ['eat', 'bananas']), or an Array object, for example, fun.apply(this, new Array('eat', 'bananas')).\n\nYou can also use arguments for the argsArray parameter. arguments is a local variable of a function. It can be used for all unspecified arguments of the called object. Thus, you do not have to know the arguments of the called object when you use the apply method. You can use arguments to pass all the arguments to the called object. The called object is then responsible for handling the arguments.\n\nSince ECMAScript 5th Edition you can also use any kind of object which is array-like, so in practice this means it's going to have a property length and integer properties in the range [0...length). As an example you can now use a NodeList or a own custom object like {'length': 2, '0': 'eat', '1': 'bananas'}.\n\nNote: Most browsers, including Chrome 14 and Internet Explorer 9, still do not accept array-like objects and will throw an exception.\n#Examples\nUsing apply to chain constructors\n\nYou can use apply to chain constructors for an object, similar to Java. In the following example we will create a global Function method called construct, which will make you able to use an array-like object with a constructor instead of an arguments list.\n\n\tFunction.prototype.construct = function (aArgs) {\n\t    var fConstructor = this, fNewConstr = function () { fConstructor.apply(this, aArgs); };\n\t    fNewConstr.prototype = fConstructor.prototype;\n\t    return new fNewConstr();\n\t};\n\nExample usage:\n\n\tfunction MyConstructor () {\n\t    for (var nProp = 0; nProp < arguments.length; nProp++) {\n\t        this[\"property\" + nProp] = arguments[nProp];\n\t    }\n\t}\n\n\tvar myArray = [4, \"Hello world!\", false];\n\tvar myInstance = MyConstructor.construct(myArray);\n\n\talert(myInstance.property1); // alerts \"Hello world!\"\n\talert(myInstance instanceof MyConstructor); // alerts \"true\"\n\talert(myInstance.constructor); // alerts \"MyConstructor\"\n\nNote: This non-native Function.construct method will not work with some native constructors (like Date, for example). In these cases you have to use the Function.bind method (for example, imagine to have an array like the following, to be used with Date constructor: [2012, 11, 4]; in this case you have to write something like: new (Function.prototype.bind.apply(Date, [null].concat([2012, 11, 4])))() – anyhow this is not the best way to do things and probably should not be used in any production environment).\nUsing apply and built-in functions\n\nClever usage of apply allows you to use built-ins functions for some tasks that otherwise probably would have been written by looping over the array values. As an example here we are going to use Math.max/Math.min to find out the maximum/minimum value in an array.\n\n\t//min/max number in an array \n\tvar numbers = [5, 6, 2, 3, 7];\n\n\t//using Math.min/Math.max apply \n\tvar max = Math.max.apply(null, numbers); // This about equal to Math.max(numbers[0], ...) or Math.max(5, 6, ..) \n\tvar min = Math.min.apply(null, numbers);\n\n\t/ vs. simple loop based algorithm \n\tmax = -Infinity, min = +Infinity;\n\n\tfor (var i = 0; i < numbers.length; i++) {\n\t  if (numbers[i] > max)\n\t    max = numbers[i];\n\t  if (numbers[i] < min) \n\t    min = numbers[i];\n\t}\n\nBut beware: in using apply this way, you run the risk of exceeding the JavaScript engine's argument length limit. The consequences of applying a function with too many arguments (think more than tens of thousands of arguments) vary across engines (JavaScriptCore has hard-coded argument limit of 65536), because the limit (indeed even the nature of any excessively-large-stack behavior) is unspecified. Some engines will throw an exception. More perniciously, others will arbitrarily limit the number of arguments actually passed to the applied function. (To illustrate this latter case: if such an engine had a limit of four arguments [actual limits are of course significantly higher], it would be as if the arguments 5, 6, 2, 3 had been passed to apply in the examples above, rather than the full array.) If your value array might grow into the tens of thousands, use a hybrid strategy: apply your function to chunks of the array at a time:\n\n\tfunction minOfArray(arr) {\n\t  var min = Infinity;\n\t  var QUANTUM = 32768;\n\n\t  for (var i = 0, len = arr.length; i < len; i += QUANTUM) {\n\t    var submin = Math.min.apply(null, arr.slice(i, Math.min(i + QUANTUM, len)));\n\t    min = Math.min(submin, min);\n\t  }\n\n\t  return min;\n\t}\n\n\tvar min = minOfArray([5, 6, 2, 3, 7]);\nUsing apply in \"monkey-patching\"\n\nApply can be the best way to monkey-patch a builtin function of Firefox, or JS libraries. Given someobject.foo function, you can modify the function in a somewhat hacky way, like so:\n\n\tvar originalfoo = someobject.foo;\n\tsomeobject.foo = function() {\n\t  //Do stuff before calling function\n\t  console.log(arguments);\n\t  //Call the function as it would have been called normally:\n\t  originalfoo.apply(this,arguments);\n\t  //Run stuff after, here.\n\t}\n\nThis method is especially handy where you want to debug events, or interface with something that has no API like the various .on([event]... events, such as those usable on the Devtools Inspector).","children":[{"annotation":"param","type":"{Object}","name":"thisArg","text":"The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.","theRestString":"@param {Array} argsArray An array-like object, specifying the arguments with which fun should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.\n\n@returns the result of evaluating this function with given context and parameters"},{"annotation":"param","type":"{Array}","name":"argsArray","text":"An array-like object, specifying the arguments with which fun should be called, or null or undefined if no arguments should be provided to the function. Starting with ECMAScript 5 these arguments can be a generic array-like object instead of an array. See below for browser compatibility information.","theRestString":"@returns the result of evaluating this function with given context and parameters"},{"annotation":"returns","name":"the","text":"result of evaluating this function with given context and parameters","theRestString":""}],"commentRange":[137909,144639],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"bind":{"annotation":"method","name":"bind","text":"#Summary\nThe bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.\n\n#Syntax\n\tfun.bind(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nThe bind() function creates a new function (a bound function) with the same function body (internal call property in ECMAScript 5 terms) as the function it is being called on (the bound function's target function) with the this value bound to the first argument of bind(), which cannot be overridden. bind() also accepts leading default arguments to provide to the target function when the bound function is called. A bound function may also be constructed using the new operator: doing so acts as though the target function had instead been constructed. The provided this value is ignored, while prepended arguments are provided to the emulated function.\n\n#Examples\nCreating a bound function\n\nThe simplest use of bind() is to make a function that, no matter how it is called, is called with a particular this value. A common mistake for new JavaScript programmers is to extract a method from an object, then to later call that function and expect it to use the original object as its this (e.g. by using that method in callback-based code). Without special care, however, the original object is usually lost. Creating a bound function from the function, using the original object, neatly solves this problem:\n\n\tthis.x = 9; \n\tvar module = {\n\t  x: 81,\n\t  getX: function() { return this.x; }\n\t};\n\n\tmodule.getX(); // 81\n\n\tvar getX = module.getX;\n\tgetX(); // 9, because in this case, \"this\" refers to the global object\n\n\t// create a new function with 'this' bound to module\n\tvar boundGetX = getX.bind(module);\n\tboundGetX(); // 81\n\n##Partial Functions\n\nThe next simplest use of bind() is to make a function with pre-specified initial arguments. These arguments (if any) follow the provided this value and are then inserted at the start of the arguments passed to the target function, followed by the arguments passed to the bound function, whenever the bound function is called.\n\n\tfunction list() {\n\t  return Array.prototype.slice.call(arguments);\n\t}\n\n\tvar list1 = list(1, 2, 3); // [1, 2, 3]\n\n\t//  Create a function with a preset leading argument\n\tvar leadingThirtysevenList = list.bind(undefined, 37);\n\n\tvar list2 = leadingThirtysevenList(); // [37]\n\tvar list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]\n\n##With setTimeout\n\nBy default within window.setTimeout(), the this keyword will be set to the window (or global) object. When working with class methods that require this to refer to class instances, you may explicitly bind this to the callback function, in order to maintain the instance.\n\n\tfunction LateBloomer() {\n\t  this.petalCount = Math.ceil( Math.random() * 12 ) + 1;\n\t}\n\n\t// declare bloom after a delay of 1 second\n\tLateBloomer.prototype.bloom = function() {\n\t  window.setTimeout( this.declare.bind( this ), 1000 );\n\t};\n\n\tLateBloomer.prototype.declare = function() {\n\t  console.log('I am a beautiful flower with ' + \n\t    this.petalCount + ' petals!');\n\t};\n\n##Bound functions used as constructors\n\nWarning: This section demonstrates JavaScript capabilities and documents some edge cases of the bind() method. The methods shown below are not the best way to do things and probably should not be used in any production environment.\nBound functions are automatically suitable for use with the new operator to construct new instances created by the target function. When a bound function is used to construct a value, the provided this is ignored. However, provided arguments are still prepended to the constructor call:\n\n\tfunction Point(x, y) {\n\t  this.x = x;\n\t  this.y = y;\n\t}\n\n\tPoint.prototype.toString = function() { \n\t  return this.x + \",\" + this.y; \n\t};\n\n\tvar p = new Point(1, 2);\n\tp.toString(); // \"1,2\"\n\n\n\tvar emptyObj = {};\n\tvar YAxisPoint = Point.bind(emptyObj, 0);\n\t// not supported in the polyfill below, works fine with native bind:\n\tvar YAxisPoint = Point.bind(null,0 );\n\n\tvar axisPoint = new YAxisPoint(5);\n\taxisPoint.toString(); //  \"0,5\"\n\n\taxisPoint instanceof Point; // true\n\taxisPoint instanceof YAxisPoint; // true\n\tnew Point(17, 42) instanceof YAxisPoint; // false\nNote that you need do nothing special to create a bound function for use with new. The corollary is that you need do nothing special to create a bound function to be called plainly, even if you would rather require the bound function to only be called using new.\n\n\t// Example can be run directly in your JavaScript console\n\t// ...continuing from above\n\n\t// Can still be called as a normal function \n\t// (although usually this is undesired)\n\tYAxisPoint(13);\n\n\temptyObj.x + \",\" + emptyObj.y;\n\t// >  \"0,13\"\nIf you wish to support use of a bound function only using new, or only by calling it, the target function must enforce that restriction.\n\n##Creating shortcuts\n\nbind() is also helpful in cases where you want to create a shortcut to a function which requires a specific this value.\n\nTake Array.prototype.slice, for example, which you want to use for converting an array-like object to a real array. You could create a shortcut like this:\n\n\tvar slice = Array.prototype.slice;\n\n\t// ...\n\n\tslice.call(arguments);\n\tWith bind(), this can be simplified. In the following piece of code, slice is a bound function to the call() function of Function.prototype, with the this value set to the slice() function of Array.prototype. This means that additional call() calls can be eliminated:\n\n\t// same as \"slice\" in the previous example\n\tvar unboundSlice = Array.prototype.slice;\n\tvar slice = Function.prototype.call.bind(unboundSlice);\n\n\t// ...\n\n\tslice(arguments);\n#Polyfill\nThe bind function is a recent addition to ECMA-262, 5th edition; as such it may not be present in all browsers. You can partially work around this by inserting the following code at the beginning of your scripts, allowing use of much of the functionality of bind() in implementations that do not natively support it.\n\n\tif (!Function.prototype.bind) {\n\t  Function.prototype.bind = function (oThis) {\n\t    if (typeof this !== \"function\") {\n\t      // closest thing possible to the ECMAScript 5\n\t      // internal IsCallable function\n\t      throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");\n\t    }\n\n\t    var aArgs = Array.prototype.slice.call(arguments, 1), \n\t        fToBind = this, \n\t        fNOP = function () {},\n\t        fBound = function () {\n\t          return fToBind.apply(this instanceof fNOP && oThis\n\t                 ? this\n\t                 : oThis,\n\t                 aArgs.concat(Array.prototype.slice.call(arguments)));\n\t        };\n\n\t    fNOP.prototype = this.prototype;\n\t    fBound.prototype = new fNOP();\n\n\t    return fBound;\n\t  };\n\t}\n\nSome of the many differences (there may well be others, as this list does not seriously attempt to be exhaustive) between this algorithm and the specified algorithm are:\n\nThe partial implementation relies Array.prototype.slice, Array.prototype.concat, Function.prototype.call and Function.prototype.apply, built-in methods to have their original values.\nThe partial implementation creates functions that do not have immutable \"poison pill\" caller and arguments properties that throw a TypeError upon get, set, or deletion. (This could be added if the implementation supports Object.defineProperty, or partially implemented [without throw-on-delete behavior] if the implementation supports the __defineGetter__ and __defineSetter__ extensions.)\nThe partial implementation creates functions that have a prototype property. (Proper bound functions have none.)\nThe partial implementation creates bound functions whose length property does not agree with that mandated by ECMA-262: it creates functions with length 0, while a full implementation, depending on the length of the target function and the number of pre-specified arguments, may return a non-zero length.\nIf you choose to use this partial implementation, you must not rely on those cases where behavior deviates from ECMA-262, 5th edition! With some care, however (and perhaps with additional modification to suit specific needs), this partial implementation may be a reasonable bridge to the time when bind() is widely implemented according to the specification.","children":[{"annotation":"param","name":"thisArg","text":"The value to be passed as the this parameter to the target function when the bound function is called. The value is ignored if the bound function is constructed using the new operator.","theRestString":"@param args Arguments to prepend to arguments provided to the bound function when invoking the target function."},{"annotation":"param","name":"args","text":"Arguments to prepend to arguments provided to the bound function when invoking the target function.","theRestString":""}],"commentRange":[144647,153331],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"call":{"annotation":"method","name":"call","text":"#Summary\nThe call() method calls a function with a given this value and arguments provided individually.\n\nNOTE: While the syntax of this function is almost identical to that of apply(), the fundamental difference is that call() accepts an argument list, while apply() accepts a single array of arguments.\n#Syntax\n\tfun.call(thisArg[, arg1[, arg2[, ...]]])\n\n#Description\nYou can assign a different this object when calling an existing function. this refers to the current object, the calling object.\n\nWith call, you can write a method once and then inherit it in another object, without having to rewrite the method for the new object.\n\n#Examples\n##Using call to chain constructors for an object\n\nYou can use call to chain constructors for an object, similar to Java. In the following example, the constructor for the Product object is defined with two parameters, name and price. Two other functions Food and Toy invoke Product passing this and name and price. Product initializes the properties name and price, both specialized functions define the category.\n\n\tfunction Product(name, price) {\n\t  this.name = name;\n\t  this.price = price;\n\n\t  if (price < 0) {\n\t    throw RangeError('Cannot create product ' +\n\t                      this.name + ' with a negative price');\n\t  }\n\n\t  return this;\n\t}\n\n\tfunction Food(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'food';\n\t}\n\n\tFood.prototype = Object.create(Product.prototype);\n\n\tfunction Toy(name, price) {\n\t  Product.call(this, name, price);\n\t  this.category = 'toy';\n\t}\n\n\tToy.prototype = Object.create(Product.prototype);\n\n\tvar cheese = new Food('feta', 5);\n\tvar fun = new Toy('robot', 40);\n \n##Using call to invoke an anonymous function\n\nIn this purely constructed example, we create anonymous function and use call to invoke it on every object in an array. The main purpose of the anonymous function here is to add a print function to every object, which is able to print the right index of the object in the array. Passing the object as this value was not strictly necessary, but is done for explanatory purpose.\n\n\tvar animals = [\n\t  {species: 'Lion', name: 'King'},\n\t  {species: 'Whale', name: 'Fail'}\n\t];\n\n\tfor (var i = 0; i < animals.length; i++) {\n\t  (function (i) { \n\t    this.print = function () { \n\t      console.log('#' + i  + ' ' + this.species \n\t                  + ': ' + this.name); \n\t    } \n\t    this.print();\n\t  }).call(animals[i], i);\n\t}","children":[{"annotation":"param","name":"thisArg","text":"The value of this provided for the call to fun. Note that this may not be the actual value seen by the method: if the method is a function in non-strict mode code, null and undefined will be replaced with the global object, and primitive values will be boxed.","theRestString":"@param arg1,arg2,... Arguments for the object."},{"annotation":"param","name":"arg1","text":",arg2,... Arguments for the object.","theRestString":""}],"commentRange":[153338,156107],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"toString":{"annotation":"method","name":"toString","text":"#Summary\nThe toString() method returns a string representing the source code of the function.\n\n#Syntax\n\tfunction.toString(indentation)\n#Description\nThe Function object overrides the toString method inherited from Object; it does not inherit Object.prototype.toString. For Function objects, the toString method returns a string representation of the object in the form of a function declaration. That is, toString decompiles the function, and the string returned includes the function keyword, the argument list, curly braces, and the source of the function body.\n\nJavaScript calls the toString method automatically when a Function is to be represented as a text value, e.g. when a function is concatenated with a string.","children":[{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[156112,156873],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"javascript.Number":{"annotation":"class","name":"Number","text":"#Summary\nThe Number JavaScript object is a wrapper object allowing you to work with numerical values. A Number object is created using the Number() constructor.\n\n#Constructor\n\tnew Number(value);\n\n#Description\nThe primary uses for the Number object are:\n\nIf the argument cannot be converted into a number, it returns NaN.\nIn a non-constructor context (i.e., without the new operator, Number can be used to perform a type conversion.\n\n\n#Examples\n##Example: Using the Number object to assign values to numeric variables\n\nThe following example uses the Number object's properties to assign values to several numeric variables:\n\n\tvar biggestNum = Number.MAX_VALUE;\n\tvar smallestNum = Number.MIN_VALUE;\n\tvar infiniteNum = Number.POSITIVE_INFINITY;\n\tvar negInfiniteNum = Number.NEGATIVE_INFINITY;\n\tvar notANum = Number.NaN;\n##Example: Integer range for Number\n\nThe following example shows minimum and maximum integer values that can be represented as Number object (for details, refer to EcmaScript standard, chapter 8.5 The Number Type):\n\n\tvar biggestInt = 9007199254740992;\n\tvar smallestInt = -9007199254740992;\n\nWhen parsing data that has been serialized to JSON, integer values falling out of this range can be expected to become corrupted when JSON parser coerces them to Number type. Using String instead is a possible workaround.\n\n##Example: Using Number to convert a Date object\n\nThe following example converts the Date object to a numerical value using Number as a function:\n\n\tvar d = new Date(\"December 17, 1995 03:24:00\");\n\tprint(Number(d));\n\nThis displays \"819199440000\".","commentRange":[156875,158492],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[156875,158492],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.Number","constructors":[{"annotation":"constructor","name":"n","text":"Number","children":[{"annotation":"param","type":"{Any}","name":"value","text":"The numeric value of the object being created.","theRestString":""}],"commentRange":[158494,158584],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"params":[{"annotation":"param","type":"{Any}","name":"value","text":"The numeric value of the object being created.","theRestString":""}],"throws":[]}],"properties":{"MAX_VALUE":{"annotation":"property","type":"{Number}","name":"MAX_VALUE","text":"#Summary\nThe Number.MAX_VALUE property represents the maximum numeric value representable in JavaScript.\n\n#Description\nThe MAX_VALUE property has a value of approximately 1.79E+308. Values larger than MAX_VALUE are represented as \"Infinity\".\n\nBecause MAX_VALUE is a static property of Number, you always use it as Number.MAX_VALUE, rather than as a property of a Number object you created.\n\n#Examples\n##Example: Using MAX_VALUE\n\n\tThe following code multiplies two numeric values. If the result is less than or equal to MAX_VALUE, the func1 function is called; otherwise, the func2 function is called.\n\n\tif (num1 * num2 <= Number.MAX_VALUE) {\n\t   func1();\n\t} else {\n\t   func2();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[158591,159317],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"MIN_VALUE":{"annotation":"property","type":"{Number}","name":"MIN_VALUE","text":"#Summary\nThe Number.MIN_VALUE property represents the smallest positive numeric value representable in JavaScript.\n\n#Description\nThe MIN_VALUE property is the number closest to 0, not the most negative number, that JavaScript can represent.\n\nMIN_VALUE has a value of approximately 5e-324. Values smaller than MIN_VALUE (\"underflow values\") are converted to 0.\n\nBecause MIN_VALUE is a static property of Number, you always use it as Number.MIN_VALUE, rather than as a property of a Number object you created.\n\n#Examples\n##Example: Using MIN_VALUE\n\nThe following code divides two numeric values. If the result is greater than or equal to MIN_VALUE, the func1 function is called; otherwise, the func2 function is called.\n\n\tif (num1 / num2 >= Number.MIN_VALUE) {\n\t    func1();\n\t} else {\n\t    func2();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[159321,160165],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"NEGATIVE_INFINITY":{"annotation":"property","type":"{Number}","name":"NEGATIVE_INFINITY","text":"#Summary\nThe Number.NEGATIVE_INFINITY property represents the negative Infinity value.\n\nYou do not have to create a Number object to access this static property (use Number.NEGATIVE_INFINITY).\n\n#Description\nThe value of Number.NEGATIVE_INFINITY is the same as the negative value of the global object's Infinity property.\n\nThis value behaves slightly differently than mathematical infinity:\n\n* Any positive value, including POSITIVE_INFINITY, multiplied by NEGATIVE_INFINITY is NEGATIVE_INFINITY.\n* Any negative value, including NEGATIVE_INFINITY, multiplied by NEGATIVE_INFINITY is POSITIVE_INFINITY.\n* Zero multiplied by NEGATIVE_INFINITY is NaN.\n* NaN multiplied by NEGATIVE_INFINITY is NaN.\n* NEGATIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is POSITIVE_INFINITY.\n* NEGATIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is NEGATIVE_INFINITY.\n* NEGATIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\n* Any number divided by NEGATIVE_INFINITY is zero.\n\nYou might use the Number.NEGATIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that isFinite would be more appropriate in such a case.\n\n#Example\nIn the following example, the variable smallNumber is assigned a value that is smaller than the minimum value. When the if statement executes, smallNumber has the value \"-Infinity\", so smallNumber is set to a more manageable value before continuing.\n\n\tvar smallNumber = (-Number.MAX_VALUE) * 2\n\n\tif (smallNumber == Number.NEGATIVE_INFINITY) {\n\t smallNumber = returnFinite();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[160170,161843],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"NaN":{"annotation":"property","type":"{Number}","name":"NaN","text":"#Summary\nThe Number.NaN property represents Not-A-Number. Equivalent of NaN.\n\nYou do not have to create a Number object to access this static property (use Number.NaN).","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[161847,162052],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"POSITIVE_INFINITY":{"annotation":"property","type":"{Number}","name":"POSITIVE_INFINITY","text":"#Summary\nThe Number.POSITIVE_INFINITY property represents the positive Infinity value.\n\nYou do not have to create a Number object to access this static property (use Number.POSITIVE_INFINITY).\n\n#Description\nThe value of Number.POSITIVE_INFINITY is the same as the value of the global object's Infinity property.\n\nThis value behaves slightly differently than mathematical infinity:\n\n* Any positive value, including POSITIVE_INFINITY, multiplied by POSITIVE_INFINITY is POSITIVE_INFINITY.\n* Any negative value, including NEGATIVE_INFINITY, multiplied by POSITIVE_INFINITY is NEGATIVE_INFINITY.\n* Zero multiplied by POSITIVE_INFINITY is NaN.\n* NaN multiplied by POSITIVE_INFINITY is NaN.\n* POSITIVE_INFINITY, divided by any negative value except NEGATIVE_INFINITY, is NEGATIVE_INFINITY.\n* POSITIVE_INFINITY, divided by any positive value except POSITIVE_INFINITY, is POSITIVE_INFINITY.\n* POSITIVE_INFINITY, divided by either NEGATIVE_INFINITY or POSITIVE_INFINITY, is NaN.\n* Any number divided by POSITIVE_INFINITY is Zero.\n* You might use the Number.POSITIVE_INFINITY property to indicate an error condition that returns a finite number in case of success. Note, however, that isFinite would be more appropriate in such a case.\n\n#Example\nIn the following example, the variable bigNumber is assigned a value that is larger than the maximum value. When the if statement executes, bigNumber has the value \"Infinity\", so bigNumber is set to a more manageable value before continuing.\n\n\tvar bigNumber = Number.MAX_VALUE * 2\n\tif (bigNumber == Number.POSITIVE_INFINITY) {\n\t bigNumber = returnFinite();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[162056,163704],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"javascript.Object":{"annotation":"class","name":"Object","text":"Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object\n\n#Description\nThe Object constructor creates an object wrapper for the given value. If the value is null or undefined, it will create and return an empty object, otherwise, it will return an object of a Type that corresponds to the given value. If the value is an object already, it will return the value.\n\nWhen called in a non-constructor context, Object behaves identically to new Object().\n\n#Object instances and Object prototype object\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden. For example, other constructors' prototypes override the constructor property and provide their own toString methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.\n\n#Examples\n##Example: Using Object given undefined and null types\n\nThe following examples store an empty Object object in o:\n\n\tvar o = new Object();\n\tvar o = new Object(undefined);\n\tvar o = new Object(null);\n##Example: Using Object to create Boolean objects\n\nThe following examples store Boolean objects in o:\n\n\t// equivalent to o = new Boolean(true);\n\tvar o = new Object(true);\n\t// equivalent to o = new Boolean(false);\n\tvar o = new Object(Boolean());","commentRange":[163706,165238],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[163706,165238],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.Object","properties":{"prototype":{"annotation":"property","type":"{ObjectPrototype}","name":"prototype","text":"","children":[{"annotation":"static","name":"dummy","text":"","theRestString":""}],"commentRange":[163706,165238],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}},"constructors":[{"annotation":"constructor","name":"n","text":"bla bla\n\n\t// Object initialiser or literal \n\t{ [ nameValuePair1 [, nameValuePair2 [, ...nameValuePairN] ] ] }  \n\t// Called as a constructor \n\tnew Object( [ value ] )","children":[{"annotation":"param","name":"nameValuePair1","text":",nameValuePair2,...nameValuePairN Pairs of names (strings) and values (any value) where the name is separated from the value by a colon.","theRestString":"@param value Any value."},{"annotation":"param","name":"value","text":"Any value.","theRestString":""}],"commentRange":[165240,165607],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"params":[{"annotation":"param","name":"nameValuePair1","text":",nameValuePair2,...nameValuePairN Pairs of names (strings) and values (any value) where the name is separated from the value by a colon.","theRestString":"@param value Any value."},{"annotation":"param","name":"value","text":"Any value.","theRestString":""}],"throws":[]}],"methods":{"__defineGetter__":{"annotation":"method","name":"__defineGetter__","text":"()  \nAssociates a function with a property that, when accessed, executes that function and returns its return value.","commentRange":[165623,165769],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"hasOwnProperty":{"annotation":"method","name":"hasOwnProperty","text":"#Summary\nThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n#Syntax\n\tobj.hasOwnProperty(prop)\n\n#Description\nEvery object descended from Object inherits the hasOwnProperty method. This method can be used to determine whether an object has the specified property as a direct property of that object; unlike the in operator, this method does not check down the object's prototype chain.\n\n#Examples\n##Example: Using hasOwnProperty to test for a property's existence\n\nThe following example determines whether the o object contains a property named prop:\n\n\to = new Object();\n\to.prop = 'exists';\n\n\tfunction changeO() {\n\t  o.newprop = o.prop;\n\t  delete o.prop;\n\t}\n\n\to.hasOwnProperty('prop');   // returns true\n\tchangeO();\n\to.hasOwnProperty('prop');   // returns false\n\tExample: Direct versus inherited properties\n\n\tThe following example differentiates between direct properties and properties inherited through the prototype chain:\n\n\to = new Object();\n\to.prop = 'exists';\n\to.hasOwnProperty('prop');             // returns true\n\to.hasOwnProperty('toString');         // returns false\n\to.hasOwnProperty('hasOwnProperty');   // returns false\n##Example: Iterating over the properties of an object\n\nThe following example shows how to iterate over the properties of an object without executing on inherit properties. Note that the for...in loop is already only iterating enumerable items, so one should not assume based on the lack of non-enumerable properties shown in the loop that hasOwnProperty itself is confined strictly to enumerable items (as with Object.getOwnPropertyNames()).\n\n\tvar buz = {\n\t  fog: 'stack'\n\t};\n\n\tfor (var name in buz) {\n\t  if (buz.hasOwnProperty(name)) {\n\t    alert('this is fog (' + name + ') for sure. Value: ' + buz[name]);\n\t  }\n\t  else {\n\t    alert(name); // toString or something else\n\t  }\n\t}\n##Example: hasOwnProperty as a property\n\nJavaScript does not protect the property name hasOwnProperty; thus, if the possibility exists that an object might have a property with this name, it is necessary to use an external hasOwnProperty to get correct results:\n\n\tvar foo = {\n\t  hasOwnProperty: function() {\n\t    return false;\n\t  },\n\t  bar: 'Here be dragons'\n\t};\n\n\tfoo.hasOwnProperty('bar'); // always returns false\n\n\t// Use another Object's hasOwnProperty and call it with 'this' set to foo\n\t({}).hasOwnProperty.call(foo, 'bar'); // true\n\n\t// It's also possible to use the hasOwnProperty property from the Object prototype for this purpose\n\tObject.prototype.hasOwnProperty.call(foo, 'bar'); // true\nNote that in the last case there are no newly created objects.","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {String}prop The name of the property to test."},{"annotation":"param","type":"{String}","name":"prop","text":"The name of the property to test.","theRestString":""}],"commentRange":[212499,215221],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"isPrototypeOf":{"annotation":"method","name":"isPrototypeOf","text":"#Summary\nThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\nNote: isPrototypeOf differs from the instanceof operator. In the expression \"object instanceof AFunction\", the object prototype chain is checked against AFunction.prototype, not against AFunction itself.\n#Syntax\n\tprototypeObj.isPrototypeOf(obj)\n#Description\nThe isPrototypeOf method allows you to check whether or not an object exists within another object's prototype chain.\n\nFor example, consider the following prototype chain:\n\n\tfunction Fee() {\n\t  // ...\n\t}\n\n\tfunction Fi() {\n\t  // ...\n\t}\n\tFi.prototype = new Fee();\n\n\tfunction Fo() {\n\t  // ...\n\t}\n\tFo.prototype = new Fi();\n\n\tfunction Fum() {\n\t  // ...\n\t}\n\tFum.prototype = new Fo();\nLater on down the road, if you instantiate Fum and need to check if Fi's prototype exists within the Fum prototype chain, you could do this:\n\n\tvar fum = new Fum();\n\t// ...\n\n\tif (Fi.prototype.isPrototypeOf(fum)) {\n\t  // do something safe\n\t}\nThis, along with the instanceof operator particularly comes in handy if you have code that can only function when dealing with objects descended from a specific prototype chain, e.g., to guarantee that certain methods or properties will be present on that object.","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} prototypeObj An object to be tested against each link in the prototype chain of the object argument.\n@param {Object}object The object whose prototype chain will be searched.\n@returns {boolean}"},{"annotation":"param","type":"{Object}","name":"prototypeObj","text":"An object to be tested against each link in the prototype chain of the object argument.","theRestString":"@param {Object}object The object whose prototype chain will be searched.\n@returns {boolean}"},{"annotation":"param","type":"{Object}","name":"object","text":"The object whose prototype chain will be searched.","theRestString":"@returns {boolean}"},{"annotation":"returns","type":"{boolean}","text":"","theRestString":""}],"commentRange":[215229,216713],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"propertyIsEnumerable":{"annotation":"method","name":"propertyIsEnumerable","text":"#Summary\nThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n#Syntax\n\tobj.propertyIsEnumerable(prop)\n\n#Description\nEvery object has a propertyIsEnumerable method. This method can determine whether the specified property in an object can be enumerated by a for...in loop, with the exception of properties inherited through the prototype chain. If the object does not have the specified property, this method returns false.\n\n#Examples\n##Example: A basic use of propertyIsEnumerable\n\nThe following example shows the use of propertyIsEnumerable on objects and arrays:\n\n\tvar o = {};\n\tvar a = [];\n\to.prop = 'is enumerable';\n\ta[0] = 'is enumerable';\n\n\to.propertyIsEnumerable('prop');   // returns true\n\ta.propertyIsEnumerable(0);        // returns true\n##Example: User-defined versus built-in objects\n\nThe following example demonstrates the enumerability of user-defined versus built-in properties:\n\n\tvar a = ['is enumerable'];\n\n\ta.propertyIsEnumerable(0);          // returns true\n\ta.propertyIsEnumerable('length');   // returns false\n\n\tMath.propertyIsEnumerable('random');   // returns false\n\tthis.propertyIsEnumerable('Math');     // returns false\n##Example: Direct versus inherited properties\n\n\tvar a = [];\n\ta.propertyIsEnumerable('constructor');         // returns false\n\n\tfunction firstConstructor() {\n\t  this.property = 'is not enumerable';\n\t}\n\n\tfirstConstructor.prototype.firstMethod = function() {};\n\n\tfunction secondConstructor() {\n\t  this.method = function method() { return 'is enumerable'; };\n\t}\n\n\tsecondConstructor.prototype = new firstConstructor;\n\tsecondConstructor.prototype.constructor = secondConstructor;\n\n\tvar o = new secondConstructor();\n\to.arbitraryProperty = 'is enumerable';\n\n\to.propertyIsEnumerable('arbitraryProperty');   // returns true\n\to.propertyIsEnumerable('method');              // returns true\n\to.propertyIsEnumerable('property');            // returns false\n\n\to.property = 'is enumerable';\n\n\to.propertyIsEnumerable('property');            // returns true\n\n\t// These return false as they are on the prototype which \n\t// propertyIsEnumerable does not consider (even though the last two\n\t// are iteratable with for-in)\n\to.propertyIsEnumerable('prototype');   // returns false (as of JS 1.8.1/FF3.6)\n\to.propertyIsEnumerable('constructor'); // returns false\n\to.propertyIsEnumerable('firstMethod'); // returns false","children":[{"annotation":"param","type":"{String}","name":"prop","text":"The name of the property to test.","theRestString":"@return {boolean}"},{"annotation":"return","type":"{boolean}","text":"","theRestString":""}],"commentRange":[216720,219227],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"toLocaleString":{"annotation":"method","name":"toLocaleString","text":"#Summary\nThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n#Syntax\n\tobj.toLocaleString();\n#Description\nObject's toLocaleString returns the result of calling toString().\n\nThis function is provided to give objects a generic toLocaleString method, even though not all may use it. See the list below.\n\nObjects overriding toLocaleString\n\n\tArray: Array.prototype.toLocaleString()\n\tNumber: Number.prototype.toLocaleString()\n\tDate: Date.prototype.toLocaleString()","commentRange":[219231,219822],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"toString":{"annotation":"method","name":"toString","text":"#Summary\nThe toString() method returns a string representing object.\n\n#Syntax\n\tobj.toString()\n#Description\nEvery object has a toString() method that is automatically called when the object is to be represented as a text value or when an object is referred to in a manner in which a string is expected. By default, the toString() method is inherited by every object descended from Object. If this method is not overridden in a custom object, toString() returns \"[object type]\", where type is the object type. The following code illustrates this:\n\n\tvar o = new Object();\n\to.toString();           // returns [object Object]\nNote: Starting in JavaScript 1.8.5 toString() called on null returns [object Null], and undefined returns [object Undefined], as defined in the 5th Edition of ECMAScript and a subsequent Errata. See Using toString to detect object type.\n#Examples\n##Example: Overriding the default toString method\n\nYou can create a function to be called in place of the default toString() method. The toString() method takes no arguments and should return a string. The toString() method you create can be any value you want, but it will be most useful if it carries information about the object.\n\nThe following code defines the Dog object type and creates theDog, an object of type Dog:\n\n\tfunction Dog(name, breed, color, sex) {\n\t  this.name = name;\n\t  this.breed = breed;\n\t  this.color = color;\n\t  this.sex = sex;\n\t}\n\n\ttheDog = new Dog('Gabby', 'Lab', 'chocolate', 'female');\nIf you call the toString() method on this custom object, it returns the default value inherited from Object:\n\n\ttheDog.toString(); // returns [object Object]\nThe following code creates and assigns dogToString() to override the default toString() method. This function generates a string containing the name, breed, color, and sex of the object, in the form \"property = value;\".\n\n\tDog.prototype.toString = function dogToString() {\n\t  var ret = 'Dog ' + this.name + ' is a ' + this.sex + ' ' + this.color + ' ' + this.breed;\n\t  return ret;\n\t}\n\nWith the preceding code in place, any time theDog is used in a string context, JavaScript automatically calls the dogToString() function, which returns the following string:\n\n\tDog Gabby is a female chocolate Lab\n\n##Example: Using toString() to detect object class\n\ntoString() can be used with every object and allows you to get its class. To use the Object.prototype.toString() with every object, you need to call Function.prototype.call() or Function.prototype.apply() on it, passing the object you want to inspect as the first parameter called thisArg.\n\n\tvar toString = Object.prototype.toString;\n\n\ttoString.call(new Date);    // [object Date]\n\ttoString.call(new String);  // [object String]\n\ttoString.call(Math);        // [object Math]\n\n\t// Since JavaScript 1.8.5\n\ttoString.call(undefined);   // [object Undefined]\n\ttoString.call(null);        // [object Null]","children":[{"annotation":"return","type":"{String}","name":"returns","text":"a string representing object.","theRestString":""}],"commentRange":[219826,222791],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"create":{"annotation":"method","name":"create","text":"#Summary\nThe Object.create() method creates a new object with the specified prototype object and properties.\n\n#Syntax\n\tObject.create(proto[, propertiesObject])\n\n#Examples\n\n##Example: Classical inheritance with Object.create\n\nBelow is an example of how to use Object.create to achieve classical inheritance. This is for single inheritance, which is all that Javascript supports.\n\n\t// Shape - superclass\n\tfunction Shape() {\n\t  this.x = 0;\n\t  this.y = 0;\n\t}\n\n\t// superclass method\n\tShape.prototype.move = function(x, y) {\n\t  this.x += x;\n\t  this.y += y;\n\t  console.info('Shape moved.');\n\t};\n\n\t// Rectangle - subclass\n\tfunction Rectangle() {\n\t  Shape.call(this); // call super constructor.\n\t}\n\n\t// subclass extends superclass\n\tRectangle.prototype = Object.create(Shape.prototype);\n\tRectangle.prototype.constructor = Rectangle;\n\n\tvar rect = new Rectangle();\n\n\trect instanceof Rectangle; // true\n\trect instanceof Shape; // true\n\n\trect.move(1, 1); // Outputs, 'Shape moved.'\n\tIf you wish to inherit from multiple objects, then mixins are a possibility.\n\n\tfunction MyClass() {\n\t  SuperClass.call(this);\n\t  OtherSuperClass.call(this);\n\t}\n\n\tMyClass.prototype = Object.create(SuperClass.prototype); // inherit\n\tmixin(MyClass.prototype, OtherSuperClass.prototype); // mixin\n\n\tMyClass.prototype.myMethod = function() {\n\t  // do a thing\n\t};\n\nThe mixin function would copy the functions from the superclass prototype to the subclass prototype, the mixin function needs to be supplied by the user. An example of a mixin like function would be jQuery.extend.\n\n##Example: Using propertiesObject argument with Object.create\n\n\tvar o;\n\n\t// create an object with null as prototype\n\to = Object.create(null);\n\n\n\to = {};\n\t// is equivalent to:\n\to = Object.create(Object.prototype);\n\n\n\t// Example where we create an object with a couple of sample properties.\n\t// (Note that the second parameter maps keys to *property descriptors*.)\n\to = Object.create(Object.prototype, {\n\t  // foo is a regular 'value property'\n\t  foo: { writable: true, configurable: true, value: 'hello' },\n\t  // bar is a getter-and-setter (accessor) property\n\t  bar: {\n\t    configurable: false,\n\t    get: function() { return 10; },\n\t    set: function(value) { console.log('Setting `o.bar` to', value); }\n\t  }\n\t});\n\n\n\tfunction Constructor() {}\n\to = new Constructor();\n\t// is equivalent to:\n\to = Object.create(Constructor.prototype);\n\t// Of course, if there is actual initialization code in the\n\t// Constructor function, the Object.create cannot reflect it\n\n\n\t// create a new object whose prototype is a new, empty object\n\t// and a adding single property 'p', with value 42\n\to = Object.create({}, { p: { value: 42 } });\n\n\t// by default properties ARE NOT writable, enumerable or configurable:\n\to.p = 24;\n\to.p;\n\t// 42\n\n\to.q = 12;\n\tfor (var prop in o) {\n\t  console.log(prop);\n\t}\n\t// 'q'\n\n\tdelete o.p;\n\t// false\n\n\t// to specify an ES3 property\n\to2 = Object.create({}, {\n\t  p: {\n\t    value: 42,\n\t    writable: true,\n\t    enumerable: true,\n\t    configurable: true\n\t  }\n\t});\n\n##Polyfill\nThis polyfill covers the main use case which is creating a new object for which the prototype has been chosen but doesn't take the second argument into account.\n\n\tif (typeof Object.create != 'function') {\n\t  Object.create = (function() {\n\t    var Object = function() {};\n\t    return function (prototype) {\n\t      if (arguments.length > 1) {\n\t        throw Error('Second argument not supported');\n\t      }\n\t      if (typeof prototype != 'object') {\n\t        throw TypeError('Argument must be an object');\n\t      }\n\t      Object.prototype = prototype;\n\t      var result = new Object();\n\t      Object.prototype = null;\n\t      return result;\n\t    };\n\t  })();\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} proto The object which should be the prototype of the newly-created object.\n\n@param {Object} propertiesObject If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). @optional dummy @throws Throws a TypeError exception if the proto parameter isn't null or an object."},{"annotation":"param","type":"{Object}","name":"proto","text":"The object which should be the prototype of the newly-created object.","theRestString":"@param {Object} propertiesObject If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). @optional dummy @throws Throws a TypeError exception if the proto parameter isn't null or an object."},{"annotation":"param","type":"{Object}","name":"propertiesObject","text":"If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties().","theRestString":"@optional dummy @throws Throws a TypeError exception if the proto parameter isn't null or an object."},{"annotation":"optional","name":"dummy","text":"","theRestString":"@throws Throws a TypeError exception if the proto parameter isn't null or an object."},{"annotation":"throws","name":"Throws","text":"a TypeError exception if the proto parameter isn't null or an object.","theRestString":""}],"commentRange":[175447,179749],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"defineProperties":{"annotation":"method","name":"defineProperties","text":"#Summary\nThe Object.defineProperties() method defines new or modifies existing properties directly on an object, returning the object.\n\n#Syntax\n\tObject.defineProperties(obj, props)\n\n#Description\nObject.defineProperties, in essence, defines all properties corresponding to the enumerable own properties of props on the object obj object.\n\n#Example\n\n\tObject.defineProperties(obj, {\n\t  \"property1\": {\n\t    value: true,\n\t    writable: true\n\t  },\n\t  \"property2\": {\n\t    value: \"Hello\",\n\t    writable: false\n\t  }\n\t  // etc. etc.\n\t});\n\n\n# Polyfill\n\nAssuming a pristine execution environment with all names and properties referring to their initial values, Object.defineProperties is almost completely equivalent (note the comment in isCallable) to the following reimplementation in JavaScript:\n\n\tfunction defineProperties(obj, properties) {\n\t  function convertToDescriptor(desc) {\n\t    function hasProperty(obj, prop) {\n\t      return Object.prototype.hasOwnProperty.call(obj, prop);\n\t    }\n\n\t    function isCallable(v) {\n\t      // NB: modify as necessary if other values than functions are callable.\n\t      return typeof v === \"function\";\n\t    }\n\n\t    if (typeof desc !== \"object\" || desc === null)\n\t      throw new TypeError(\"bad desc\");\n\n\t    var d = {};\n\n\t    if (hasProperty(desc, \"enumerable\"))\n\t      d.enumerable = !!obj.enumerable;\n\t    if (hasProperty(desc, \"configurable\"))\n\t      d.configurable = !!obj.configurable;\n\t    if (hasProperty(desc, \"value\"))\n\t      d.value = obj.value;\n\t    if (hasProperty(desc, \"writable\"))\n\t      d.writable = !!desc.writable;\n\t    if (hasProperty(desc, \"get\")) {\n\t      var g = desc.get;\n\n\t      if (!isCallable(g) && typeof g !== \"undefined\")\n\t        throw new TypeError(\"bad get\");\n\t      d.get = g;\n\t    }\n\t    if (hasProperty(desc, \"set\")) {\n\t      var s = desc.set;\n\t      if (!isCallable(s) && typeof s !== \"undefined\")\n\t        throw new TypeError(\"bad set\");\n\t      d.set = s;\n\t    }\n\n\t    if ((\"get\" in d || \"set\" in d) && (\"value\" in d || \"writable\" in d))\n\t      throw new TypeError(\"identity-confused descriptor\");\n\n\t    return d;\n\t  }\n\n\t  if (typeof obj !== \"object\" || obj === null)\n\t    throw new TypeError(\"bad obj\");\n\n\t  properties = Object(properties);\n\n\t  var keys = Object.keys(properties);\n\t  var descs = [];\n\n\t  for (var i = 0; i < keys.length; i++)\n\t    descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);\n\n\t  for (var i = 0; i < descs.length; i++)\n\t    Object.defineProperty(obj, descs[i][0], descs[i][1]);\n\n\t  return obj;\n\t}","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object on which to define or modify properties.\n@param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object on which to define or modify properties.","theRestString":"@param {Object} props An object whose own enumerable properties constitute descriptors for the properties to be defined or modified."},{"annotation":"param","type":"{Object}","name":"props","text":"An object whose own enumerable properties constitute descriptors for the properties to be defined or modified.","theRestString":""}],"commentRange":[179758,182510],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"defineProperty":{"annotation":"method","name":"defineProperty","text":"#Summary\nThe Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\n\n#Syntax\nObject.defineProperty(obj, prop, descriptor)\n\n#Description\nThis method allows precise addition to or modification of a property on an object. Normal property addition through assignment creates properties which show up during property enumeration (for...in loop or Object.keys method), whose values may be changed, and which may be deleted. This method allows these extra details to be changed from their defaults.\n\nProperty descriptors present in objects come in two main flavors: data descriptors and accessor descriptors. A data descriptor is a property that has a value, which may or may not be writable. An accessor descriptor is a property described by a getter-setter pair of functions. A descriptor must be one of these two flavors; it cannot be both.\n\nBoth data and accessor descriptors are objects. They share the following optional keys:\n\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\nDefaults to false.\n\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\nDefaults to false.\nA data descriptor also has the following optional keys:\n\n###value\nThe value associated with the property. Can be any valid JavaScript value (number, object, function, etc).\nDefaults to undefined.\nwritable\ntrue if and only if the value associated with the property may be changed with an assignment operator.\nDefaults to false.\nAn accessor descriptor also has the following optional keys:\n\n###get\nA function which serves as a getter for the property, or undefined if there is no getter. The function return will be used as the value of property.\nDefaults to undefined.\n\n###set\nA function which serves as a setter for the property, or undefined if there is no setter. The function will receive as only argument the new value being assigned to the property.\nDefaults to undefined.\nBear in mind that these options are not necessarily own properties so, if inherited, will be considered too. In order to ensure these defaults are preserved you might freeze the Object.prototype upfront, specify all options explicitly, or point to null as __proto__ property.\n\n\t// using __proto__\n\tObject.defineProperty(obj, 'key', {\n\t  __proto__: null, // no inherited properties\n\t  value: 'static'  // not enumerable\n\t                   // not configurable\n\t                   // not writable\n\t                   // as defaults\n\t});\n\n\t// being explicit\n\tObject.defineProperty(obj, 'key', {\n\t  enumerable: false,\n\t  configurable: false,\n\t  writable: false,\n\t  value: 'static'\n\t});\n\n\t// recycling same object\n\tfunction withValue(value) {\n\t  var d = withValue.d || (\n\t    withValue.d = {\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false,\n\t      value: null\n\t    }\n\t  );\n\t  d.value = value;\n\t  return d;\n\t}\n\t// ... and ...\n\tObject.defineProperty(obj, 'key', withValue('static'));\n\n\t// if freeze is available, prevents the code to add\n\t// value, get, set, enumerable, writable, configurable\n\t// to the Object prototype\n\t(Object.freeze || Object)(Object.prototype);\n\n#Examples\n\nIf you want to see how to use the Object.defineProperty method with a binary-flags-like syntax, see additional examples.\n\n##Example: Creating a property\n\nWhen the property specified doesn't exist in the object, Object.defineProperty() creates a new property as described. Fields may be omitted from the descriptor, and default values for those fields are imputed. All of the Boolean-valued fields default to false. The value, get, and set fields default to undefined. A property which is defined without get/set/value/writable is called “generic” and is “typed” as a data descriptor.\n\n\tvar o = {}; // Creates a new object\n\n\t// Example of an object property added with defineProperty with a data property descriptor\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: true,\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\t// 'a' property exists in the o object and its value is 37\n\n\t// Example of an object property added with defineProperty with an accessor property descriptor\n\tvar bValue = 38;\n\tObject.defineProperty(o, 'b', {\n\t  get: function() { return bValue; },\n\t  set: function(newValue) { bValue = newValue; },\n\t  enumerable: true,\n\t  configurable: true\n\t});\n\to.b; // 38\n\t// 'b' property exists in the o object and its value is 38\n\t// The value of o.b is now always identical to bValue, unless o.b is redefined\n\n\t// You cannot try to mix both:\n\tObject.defineProperty(o, 'conflict', {\n\t  value: 0x9f91102,\n\t  get: function() { return 0xdeadbeef; }\n\t});\n\t// throws a TypeError: value appears only in data descriptors, get appears only in accessor descriptors\n\n##Example: Modifying a property\n\nWhen the property already exists, Object.defineProperty() attempts to modify the property according to the values in the descriptor and the object's current configuration. If the old descriptor had its configurable attribute set to false (the property is said to be “non-configurable”), then no attribute besides writable can be changed. In that case, it is also not possible to switch back and forth between the data and accessor property types.\n\nIf a property is non-configurable, its writable attribute can only be changed to false.\n\nA TypeError is thrown when attempts are made to change non-configurable property attributes (besides the writable attribute) unless the current and new values are the same.\n\n##Writable attribute\n\nWhen the writable property attribute is set to false, the property is said to be “non-writable”. It cannot be reassigned.\n\n\tvar o = {}; // Creates a new object\n\n\tObject.defineProperty(o, 'a', {\n\t  value: 37,\n\t  writable: false\n\t});\n\n\tconsole.log(o.a); // logs 37\n\to.a = 25; // No error thrown (it would throw in strict mode, even if the value had been the same)\n\tconsole.log(o.a); // logs 37. The assignment didn't work.\n\nAs seen in the example, trying to write into the non-writable property doesn't change it but doesn't throw an error either.\n\n##Enumerable attribute\n\nThe enumerable property attribute defines whether the property shows up in a for...in loop and Object.keys() or not.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', { value: 1, enumerable: true });\n\tObject.defineProperty(o, 'b', { value: 2, enumerable: false });\n\tObject.defineProperty(o, 'c', { value: 3 }); // enumerable defaults to false\n\to.d = 4; // enumerable defaults to true when creating a property by setting it\n\n\tfor (var i in o) {\n\t  console.log(i);\n\t}\n\t// logs 'a' and 'd' (in undefined order)\n\n\tObject.keys(o); // ['a', 'd']\n\n\to.propertyIsEnumerable('a'); // true\n\to.propertyIsEnumerable('b'); // false\n\to.propertyIsEnumerable('c'); // false\n\tConfigurable attribute\n\n\tThe configurable attribute controls at the same time whether the property can be deleted from the object and whether its attributes (other than writable) can be changed.\n\n\tvar o = {};\n\tObject.defineProperty(o, 'a', {\n\t  get: function() { return 1; },\n\t  configurable: false\n\t});\n\n\tObject.defineProperty(o, 'a', { configurable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { enumerable: true }); // throws a TypeError\n\tObject.defineProperty(o, 'a', { set: function() {} }); // throws a TypeError (set was undefined previously)\n\tObject.defineProperty(o, 'a', { get: function() { return 1; } }); // throws a TypeError (even though the new get does exactly the same thing)\n\tObject.defineProperty(o, 'a', { value: 12 }); // throws a TypeError\n\n\tconsole.log(o.a); // logs 1\n\tdelete o.a; // Nothing happens\n\tconsole.log(o.a); // logs 1\n\n\nIf the configurable attribute of o.a had been true, none of the errors would be thrown and the property would be deleted at the end.\n\n##Example: Adding properties and default values\n\nIt's important to consider the way default values of attributes are applied. There is often a difference between simply using dot notation to assign a value and using Object.defineProperty(), as shown in the example below.\n\n\tvar o = {};\n\n\to.a = 1;\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: true,\n\t  configurable: true,\n\t  enumerable: true\n\t});\n\n\n\t// On the other hand,\n\tObject.defineProperty(o, 'a', { value: 1 });\n\t// is equivalent to:\n\tObject.defineProperty(o, 'a', {\n\t  value: 1,\n\t  writable: false,\n\t  configurable: false,\n\t  enumerable: false\n\t});\n\n\n##Example: Custom Setters and Getters\n\nExample below shows how to implement a self-archiving object. When temperature property is set, the archive array gets a log entry.\n\n\tfunction Archiver() {\n\t  var temperature = null;\n\t  var archive = [];\n\n\t  Object.defineProperty(this, 'temperature', {\n\t    get: function() {\n\t      console.log('get!');\n\t      return temperature;\n\t    },\n\t    set: function(value) {\n\t      temperature = value;\n\t      archive.push({ val: temperature });\n\t    }\n\t  });\n\n\t  this.getArchive = function() { return archive; };\n\t}\n\n\tvar arc = new Archiver();\n\tarc.temperature; // 'get!'\n\tarc.temperature = 11;\n\tarc.temperature = 13;\n\tarc.getArchive(); // [{ val: 11 }, { val: 13 }]","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object on which to define the property.\n@param {String} prop The name of the property to be defined or modified.\n@param {Object} descriptor The descriptor for the property being defined or modified."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object on which to define the property.","theRestString":"@param {String} prop The name of the property to be defined or modified.\n@param {Object} descriptor The descriptor for the property being defined or modified."},{"annotation":"param","type":"{String}","name":"prop","text":"The name of the property to be defined or modified.","theRestString":"@param {Object} descriptor The descriptor for the property being defined or modified."},{"annotation":"param","type":"{Object}","name":"descriptor","text":"The descriptor for the property being defined or modified.","theRestString":""}],"commentRange":[182522,192016],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"freeze":{"annotation":"method","name":"freeze","text":"#Summary\nThe Object.freeze() method freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen.\n\n#Syntax\nObject.freeze(obj)\n\n#Description\nNothing can be added to or removed from the properties set of a frozen object. Any attempt to do so will fail, either silently or by throwing a TypeError exception (most commonly, but not exclusively, when in strict mode).\n\nValues cannot be changed for data properties. Accessor properties (getters and setters) work the same (and still give the illusion that you are changing the value). Note that values that are objects can still be modified, unless they are also frozen.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.freeze(obj);\n\n\tassert(Object.isFrozen(obj) === true);\n\n\t// Now any changes will fail\n\tobj.foo = 'quux'; // silently does nothing\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors\n\tfunction fail(){\n\t  'use strict';\n\t  obj.foo = 'sparky'; // throws a TypeError\n\t  delete obj.quaxxor; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\n\tfail();\n\n\t// Attempted changes through Object.defineProperty will also throw\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // throws a TypeError\n\tThe following example shows that object values in a frozen object can be mutated (freeze is shallow).\n\n\tobj = {\n\t  internal: {}\n\t};\n\n\tObject.freeze(obj);\n\tobj.internal.a = 'aValue';\n\n\tobj.internal.a // 'aValue'\n\n\t// To make obj fully immutable, freeze each object in obj.\n\t// To do so, we use this function.\n\n\tfunction deepFreeze(o) {\n\t  var prop, propKey;\n\t  Object.freeze(o); // First freeze the object.\n\t  for (propKey in o) {\n\t    prop = o[propKey];\n\t    if (!o.hasOwnProperty(propKey) || !(typeof prop === 'object') || Object.isFrozen(prop)) {\n\t      // If the object is on the prototype, not an object, or is already frozen,\n\t      // skip it. Note that this might leave an unfrozen reference somewhere in the\n\t      // object if there is an already frozen object containing an unfrozen object.\n\t      continue;\n\t    }\n\n\t    deepFreeze(prop); // Recursively call deepFreeze.\n\t  }\n\t}\n\n\tobj2 = {\n\t  internal: {}\n\t};\n\n\tdeepFreeze(obj2);\n\tobj2.internal.a = 'anotherValue';\n\tobj2.internal.a; // undefined","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param obj The object to freeze."},{"annotation":"param","name":"obj","text":"The object to freeze.","theRestString":""}],"commentRange":[192027,194873],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"getOwnPropertyDescriptor":{"annotation":"method","name":"getOwnPropertyDescriptor","text":"#Summary\nThe Object.getOwnPropertyDescriptor() method returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object.\n\n#Syntax\n\tObject.getOwnPropertyDescriptor(obj, prop)\n\n#Description\nThis method permits examination of the precise description of a property. A property in JavaScript consists of a string-valued name and a property descriptor. Further information about property descriptor types and their attributes can be found in Object.defineProperty().\n\nA property descriptor is a record with some of the following attributes:\n\n###value\nThe value associated with the property (data descriptors only).\n###writable\ntrue if and only if the value associated with the property may be changed (data descriptors only).\n###get\nA function which serves as a getter for the property, or undefined if there is no getter (accessor descriptors only).\n###set\nA function which serves as a setter for the property, or undefined if there is no setter (accessor descriptors only).\n###configurable\ntrue if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.\n###enumerable\ntrue if and only if this property shows up during enumeration of the properties on the corresponding object.\n\n#Examples\n\n\tvar o, d;\n\n\to = { get foo() { return 17; } };\n\td = Object.getOwnPropertyDescriptor(o, 'foo');\n\t// d is { configurable: true, enumerable: true, get: , set: undefined }\n\n\to = { bar: 42 };\n\td = Object.getOwnPropertyDescriptor(o, 'bar');\n\t// d is { configurable: true, enumerable: true, value: 42, writable: true }\n\n\to = {};\n\tObject.defineProperty(o, 'baz', { value: 8675309, writable: false, enumerable: false });\n\td = Object.getOwnPropertyDescriptor(o, 'baz');\n\t// d is { value: 8675309, writable: false, enumerable: false, configurable: false }","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object}obj The object in which to look for the property.\n@param {String}prop The name of the property whose description is to be retrieved.\n@returns A property descriptor of the given property if it exists on the object, undefined otherwise."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object in which to look for the property.","theRestString":"@param {String}prop The name of the property whose description is to be retrieved.\n@returns A property descriptor of the given property if it exists on the object, undefined otherwise."},{"annotation":"param","type":"{String}","name":"prop","text":"The name of the property whose description is to be retrieved.","theRestString":"@returns A property descriptor of the given property if it exists on the object, undefined otherwise."},{"annotation":"returns","name":"A","text":"property descriptor of the given property if it exists on the object, undefined otherwise.","theRestString":""}],"commentRange":[194884,197099],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"getOwnPropertyNames":{"annotation":"method","name":"getOwnPropertyNames","text":"#Summary\nThe Object.getOwnPropertyNames() method returns an array of all properties (enumerable or not) found directly upon a given object.\n\n#Syntax\nObject.getOwnPropertyNames(obj)\n\n#Description\nObject.getOwnPropertyNames returns an array whose elements are strings corresponding to the enumerable and non-enumerable properties found directly upon obj. The ordering of the enumerable properties in the array is consistent with the ordering exposed by a for...in loop (or by Object.keys) over the properties of the object. The ordering of the non-enumerable properties in the array, and among the enumerable properties, is not defined.\n\n#Examples\n##Example: Using getOwnPropertyNames\n\n\tvar arr = ['a', 'b', 'c'];\n\tprint(Object.getOwnPropertyNames(arr).sort()); // prints '0,1,2,length'\n\n\t// Array-like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tprint(Object.getOwnPropertyNames(obj).sort()); // prints '0,1,2'\n\n\t// Printing property names and values using Array.forEach\n\tObject.getOwnPropertyNames(obj).forEach(function(val, idx, array) {\n\t  print(val + ' -> ' + obj[val]);\n\t});\n\t// prints\n\t// 0 -> a\n\t// 1 -> b\n\t// 2 -> c\n\n\t// non-enumerable property\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; }, enumerable: false } });\n\tmy_obj.foo = 1;\n\n\tprint(Object.getOwnPropertyNames(my_obj).sort()); // prints 'foo,getFoo'\n\nIf you want only the enumerable properties, see Object.keys() or use a for...in loop (although note that this will return enumerable properties not found directly upon that object but also along the prototype chain for the object unless the latter is filtered with hasOwnProperty()).\n\nItems on the prototype chain are not listed:\n\n\tfunction ParentClass() {}\n\tParentClass.prototype.inheritedMethod = function() {};\n\n\tfunction ChildClass() {\n\t  this.prop = 5;\n\t  this.method = function() {};\n\t}\n\tChildClass.prototype = new ParentClass;\n\tChildClass.prototype.prototypeMethod = function() {};\n\n\talert(\n\t  Object.getOwnPropertyNames(\n\t    new ChildClass() // ['prop', 'method']\n\t  )\n\t);\n\n##Example: Get Non-Enumerable Only\n\nThis uses the Array.prototype.filter() function to remove the enumerable keys (obtained with Object.keys()) from a list of all keys (obtained with Object.getOwnPropertyNames) leaving only the non-enumerable keys.\n\n\tvar target = myObject;\n\tvar enum_and_nonenum = Object.getOwnPropertyNames(target);\n\tvar enum_only = Object.keys(target);\n\tvar nonenum_only = enum_and_nonenum.filter(function(key) {\n\t  var indexInEnum = enum_only.indexOf(key);\n\t  if (indexInEnum == -1) {\n\t    // not found in enum_only keys mean the key is non-enumerable,\n\t    // so return true so we keep this in the filter\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t});\n\n\tconsole.log(nonenum_only);","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object whose enumerable and non-enumerable own properties are to be returned."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object whose enumerable and non-enumerable own properties are to be returned.","theRestString":""}],"commentRange":[197110,200009],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"isExtensible":{"annotation":"method","name":"isExtensible","text":"#Summary\nThe Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it).\n\n#Syntax\n\tObject.isExtensible(obj)\n\n#Description\nObjects are extensible by default: they can have new properties added to them, and (in engines that support __proto__  their __proto__ property) can be modified. An object can be marked as non-extensible using Object.preventExtensions(), Object.seal(), or Object.freeze().\n\n#Examples\n\t// New objects are extensible.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Sealed objects are by definition non-extensible.\n\tvar sealed = Object.seal({});\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// Frozen objects are also by definition non-extensible.\n\tvar frozen = Object.freeze({});\n\tassert(Object.isExtensible(frozen) === false);\n\tNotes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return false.\n\n\t> Object.isExtensible(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isExtensible(1)\n\tfalse","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object which should be checked.\n@return {boolean}"},{"annotation":"param","type":"{Object}","name":"obj","text":"The object which should be checked.","theRestString":"@return {boolean}"},{"annotation":"return","type":"{boolean}","text":"","theRestString":""}],"commentRange":[200020,201421],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"isFrozen":{"annotation":"method","name":"isFrozen","text":"#Summary\nThe Object.isFrozen() determines if an object is frozen.\n\n#Syntax\n\tObject.isFrozen(obj)\n\n#Description\nAn object is frozen if and only if it is not extensible, all its properties are non-configurable, and all its data properties (that is, properties which are not accessor properties with getter or setter components) are non-writable.\n\n#Examples\n\t// A new object is extensible, so it is not frozen.\n\tassert(Object.isFrozen({}) === false);\n\n\t// An empty object which is not extensible is vacuously frozen.\n\tvar vacuouslyFrozen = Object.preventExtensions({});\n\tassert(Object.isFrozen(vacuouslyFrozen) === true);\n\n\t// A new object with one property is also extensible, ergo not frozen.\n\tvar oneProp = { p: 42 };\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// Preventing extensions to the object still doesn't make it frozen,\n\t// because the property is still configurable (and writable).\n\tObject.preventExtensions(oneProp);\n\tassert(Object.isFrozen(oneProp) === false);\n\n\t// ...but then deleting that property makes the object vacuously frozen.\n\tdelete oneProp.p;\n\tassert(Object.isFrozen(oneProp) === true);\n\n\t// A non-extensible object with a non-writable but still configurable property is not frozen.\n\tvar nonWritable = { e: 'plep' };\n\tObject.preventExtensions(nonWritable);\n\tObject.defineProperty(nonWritable, 'e', { writable: false }); // make non-writable\n\tassert(Object.isFrozen(nonWritable) === false);\n\n\t// Changing that property to non-configurable then makes the object frozen.\n\tObject.defineProperty(nonWritable, 'e', { configurable: false }); // make non-configurable\n\tassert(Object.isFrozen(nonWritable) === true);\n\n\t// A non-extensible object with a non-configurable but still writable property also isn't frozen.\n\tvar nonConfigurable = { release: 'the kraken!' };\n\tObject.preventExtensions(nonConfigurable);\n\tObject.defineProperty(nonConfigurable, 'release', { configurable: false });\n\tassert(Object.isFrozen(nonConfigurable) === false);\n\n\t// Changing that property to non-writable then makes the object frozen.\n\tObject.defineProperty(nonConfigurable, 'release', { writable: false });\n\tassert(Object.isFrozen(nonConfigurable) === true);\n\n\t// A non-extensible object with a configurable accessor property isn't frozen.\n\tvar accessor = { get food() { return 'yum'; } };\n\tObject.preventExtensions(accessor);\n\tassert(Object.isFrozen(accessor) === false);\n\n\t// ...but make that property non-configurable and it becomes frozen.\n\tObject.defineProperty(accessor, 'food', { configurable: false });\n\tassert(Object.isFrozen(accessor) === true);\n\n\t// But the easiest way for an object to be frozen is if Object.freeze has been called on it.\n\tvar frozen = { 1: 81 };\n\tassert(Object.isFrozen(frozen) === false);\n\tObject.freeze(frozen);\n\tassert(Object.isFrozen(frozen) === true);\n\n\t// By definition, a frozen object is non-extensible.\n\tassert(Object.isExtensible(frozen) === false);\n\n\t// Also by definition, a frozen object is sealed.\n\tassert(Object.isSealed(frozen) === true);\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a frozen ordinary object, simply return true.\n\n\t> Object.isFrozen(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isFrozen(1)\n\ttrue                          // ES6 code","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object}obj The object which should be checked.\n@returns boolean"},{"annotation":"param","type":"{Object}","name":"obj","text":"The object which should be checked.","theRestString":"@returns boolean"},{"annotation":"returns","name":"boolean","text":"","theRestString":""}],"commentRange":[201426,204866],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"isSealed":{"annotation":"method","name":"isSealed","text":"#Summary\nThe Object.isSealed() method determines if an object is sealed.\n\n#Syntax\n\tObject.isSealed(obj)\n#Description\nReturns true if the object is sealed, otherwise false. An object is sealed if it is not extensible and if all its properties are non-configurable and therefore not removable (but not necessarily non-writable).\n\n#Examples\n\t// Objects aren't sealed by default.\n\tvar empty = {};\n\tassert(Object.isSealed(empty) === false);\n\n\t// If you make an empty object non-extensible, it is vacuously sealed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isSealed(empty) === true);\n\n\t// The same is not true of a non-empty object, unless its properties are all non-configurable.\n\tvar hasProp = { fee: 'fie foe fum' };\n\tObject.preventExtensions(hasProp);\n\tassert(Object.isSealed(hasProp) === false);\n\n\t// But make them all non-configurable and the object becomes sealed.\n\tObject.defineProperty(hasProp, 'fee', { configurable: false });\n\tassert(Object.isSealed(hasProp) === true);\n\n\t// The easiest way to seal an object, of course, is Object.seal.\n\tvar sealed = {};\n\tObject.seal(sealed);\n\tassert(Object.isSealed(sealed) === true);\n\n\t// A sealed object is, by definition, non-extensible.\n\tassert(Object.isExtensible(sealed) === false);\n\n\t// A sealed object might be frozen, but it doesn't have to be.\n\tassert(Object.isFrozen(sealed) === true); // all properties also non-writable\n\n\tvar s2 = Object.seal({ p: 3 });\n\tassert(Object.isFrozen(s2) === false); // 'p' is still writable\n\n\tvar s3 = Object.seal({ get p() { return 0; } });\n\tassert(Object.isFrozen(s3) === true); // only configurability matters for accessor properties\n\n#Notes\n\tIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a sealed ordinary object, simply return true.\n\n\t> Object.isSealed(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.isSealed(1)\n\ttrue                          // ES6 code","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object which should be checked.\n@returns {boolean}"},{"annotation":"param","type":"{Object}","name":"obj","text":"The object which should be checked.","theRestString":"@returns {boolean}"},{"annotation":"returns","type":"{boolean}","text":"","theRestString":""}],"commentRange":[204872,206954],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"keys":{"annotation":"method","name":"keys","text":"#Summary\nThe Object.keys() method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n#Syntax\n\tObject.keys(obj)\n\n#Examples\n\tvar arr = ['a', 'b', 'c'];\n\tconsole.log(Object.keys(arr)); // console: ['0', '1', '2']\n\n\t// array like object\n\tvar obj = { 0: 'a', 1: 'b', 2: 'c' };\n\tconsole.log(Object.keys(obj)); // console: ['0', '1', '2']\n\n\t// array like object with random key ordering\n\tvar an_obj = { 100: 'a', 2: 'b', 7: 'c' };\n\tconsole.log(Object.keys(an_obj)); // console: ['2', '7', '100']\n\n\t// getFoo is property which isn't enumerable\n\tvar my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });\n\tmy_obj.foo = 1;\n\n\tconsole.log(Object.keys(my_obj)); // console: ['foo']\nIf you want all properties, even not enumerables, see Object.getOwnPropertyNames().\n\n#Polyfill\nTo add compatible Object.keys support in older environments that do not natively support it, copy the following snippet:\n\n\t// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n\tif (!Object.keys) {\n\t  Object.keys = (function() {\n\t    'use strict';\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty,\n\t        hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString'),\n\t        dontEnums = [\n\t          'toString',\n\t          'toLocaleString',\n\t          'valueOf',\n\t          'hasOwnProperty',\n\t          'isPrototypeOf',\n\t          'propertyIsEnumerable',\n\t          'constructor'\n\t        ],\n\t        dontEnumsLength = dontEnums.length;\n\n\t    return function(obj) {\n\t      if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {\n\t        throw new TypeError('Object.keys called on non-object');\n\t      }\n\n\t      var result = [], prop, i;\n\n\t      for (prop in obj) {\n\t        if (hasOwnProperty.call(obj, prop)) {\n\t          result.push(prop);\n\t        }\n\t      }\n\n\t      if (hasDontEnumBug) {\n\t        for (i = 0; i < dontEnumsLength; i++) {\n\t          if (hasOwnProperty.call(obj, dontEnums[i])) {\n\t            result.push(dontEnums[i]);\n\t          }\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t  }());\n\t}\nPlease note that the above code includes non-enumerable keys in IE7 (and maybe IE8), when passing in an object from a different window.\n\nFor a simple browser polyfill, see Javascript - Object.keys Browser Compatibility.","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object} obj The object whose enumerable own properties are to be returned.\n@returns {Array<String>} method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object whose enumerable own properties are to be returned.","theRestString":"@returns {Array<String>} method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well)."},{"annotation":"returns","type":"{Array<String>}","name":"method","text":"returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).","theRestString":""}],"commentRange":[206962,209802],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"preventExtensions":{"annotation":"method","name":"preventExtensions","text":"#Summary\nThe Object.preventExtensions() method prevents new properties from ever being added to an object (i.e. prevents future extensions to the object).\n\n#Syntax\n\tObject.preventExtensions(obj)\n\n#Description\nAn object is extensible if new properties can be added to it. Object.preventExtensions() marks an object as no longer extensible, so that it will never have properties beyond the ones it had at the time it was marked as non-extensible. Note that the properties of a non-extensible object, in general, may still be deleted. Attempting to add new properties to a non-extensible object will fail, either silently or by throwing a TypeError (most commonly, but not exclusively, when in strict mode).\n\nObject.preventExtensions() only prevents addition of own properties. Properties can still be added to the object prototype. However, calling Object.preventExtensions() on an object will also prevent extensions on its __proto__  property.\n\nIf there is a way to turn an extensible object to a non-extensible one, there is no way to do the opposite in ECMAScript 5.\n\n#Examples\n\t// Object.preventExtensions returns the object being made non-extensible.\n\tvar obj = {};\n\tvar obj2 = Object.preventExtensions(obj);\n\tassert(obj === obj2);\n\n\t// Objects are extensible by default.\n\tvar empty = {};\n\tassert(Object.isExtensible(empty) === true);\n\n\t// ...but that can be changed.\n\tObject.preventExtensions(empty);\n\tassert(Object.isExtensible(empty) === false);\n\n\t// Object.defineProperty throws when adding a new property to a non-extensible object.\n\tvar nonExtensible = { removable: true };\n\tObject.preventExtensions(nonExtensible);\n\tObject.defineProperty(nonExtensible, 'new', { value: 8675309 }); // throws a TypeError\n\n\t// In strict mode, attempting to add new properties to a non-extensible object throws a TypeError.\n\tfunction fail() {\n\t  'use strict';\n\t  nonExtensible.newProperty = 'FAIL'; // throws a TypeError\n\t}\n\tfail();\n\n\t// EXTENSION (only works in engines supporting __proto__\n\t// (which is deprecated. Use Object.getPrototypeOf instead)):\n\t// A non-extensible object's prototype is immutable.\n\tvar fixed = Object.preventExtensions({});\n\tfixed.__proto__ = { oh: 'hai' }; // throws a TypeError\n\n#Notes\nIn ES5, if the argument to this method is not an object (a primitive), then it will cause a TypeError. In ES6, a non-object argument will be treated as if it was a non-extensible ordinary object, simply return it.\n\n\t> Object.preventExtensions(1)\n\tTypeError: 1 is not an object // ES5 code\n\n\t> Object.preventExtensions(1)\n\t1                             // ES6 code","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param {Object}obj The object which should be made non-extensible."},{"annotation":"param","type":"{Object}","name":"obj","text":"The object which should be made non-extensible.","theRestString":""}],"commentRange":[209811,212491],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"valueOf":{"annotation":"method","name":"valueOf","text":"#Summary\nThe valueOf() method returns the primitive value of the specified object.\n\n#Syntax\n\tobject.valueOf()\n#Description\nJavaScript calls the valueOf method to convert an object to a primitive value. You rarely need to invoke the valueOf method yourself; JavaScript automatically invokes it when encountering an object where a primitive value is expected.\n\nBy default, the valueOf method is inherited by every object descended from Object. Every built-in core object overrides this method to return an appropriate value. If an object has no primitive value, valueOf returns the object itself, which is displayed as:\n\n\t[object Object]\nYou can use valueOf within your own code to convert a built-in object into a primitive value. When you create a custom object, you can override Object.prototype.valueOf() to call a custom method instead of the default Object method.\n\n##Overriding valueOf for custom objects\n\nYou can create a function to be called in place of the default valueOf method. Your function must take no arguments.\n\nSuppose you have an object type myNumberType and you want to create a valueOf method for it. The following code assigns a user-defined function to the object's valueOf method:\n\n\tmyNumberType.prototype.valueOf = function() { return customPrimitiveValue; };\nWith the preceding code in place, any time an object of type myNumberType is used in a context where it is to be represented as a primitive value, JavaScript automatically calls the function defined in the preceding code.\n\nAn object's valueOf method is usually invoked by JavaScript, but you can invoke it yourself as follows:\n\n\tmyNumber.valueOf()\nNote: Objects in string contexts convert via the toString() method, which is different from String objects converting to string primitives using valueOf. All objects have a string conversion, if only \"[object type]\". But many objects do not convert to number, boolean, or function.\n#Examples\n##Example: Using valueOf\n\n\to = new Object();\n\tmyVar = o.valueOf();      // [object Object]","commentRange":[222797,224834],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"seal":{"annotation":"method","name":"seal","text":"#Summary\nThe Object.seal() method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.\n\n#Syntax\n\tObject.seal(obj)\n\n#Description\nBy default, objects are extensible (new properties can be added to them). Sealing an object prevents new properties from being added and marks all existing properties as non-configurable. This has the effect of making the set of properties on the object fixed and immutable. Making all properties non-configurable also prevents them from being converted from data properties to accessor properties and vice versa, but it does not prevent the values of data properties from being changed. Attempting to delete or add properties to a sealed object, or to convert a data property to accessor or vice versa, will fail, either silently or by throwing a TypeError (most commonly, although not exclusively, when in strict mode code).\n\nThe prototype chain remains untouched. However, the __proto__  property is sealed as well.\n\n#Examples\n\tvar obj = {\n\t  prop: function() {},\n\t  foo: 'bar'\n\t};\n\n\t// New properties may be added, existing properties may be changed or removed.\n\tobj.foo = 'baz';\n\tobj.lumpy = 'woof';\n\tdelete obj.prop;\n\n\tvar o = Object.seal(obj);\n\n\tassert(o === obj);\n\tassert(Object.isSealed(obj) === true);\n\n\t// Changing property values on a sealed object still works.\n\tobj.foo = 'quux';\n\n\t// But you can't convert data properties to accessors, or vice versa.\n\tObject.defineProperty(obj, 'foo', { get: function() { return 'g'; } }); // throws a TypeError\n\n\t// Now any changes, other than to property values, will fail.\n\tobj.quaxxor = 'the friendly duck'; // silently doesn't add the property\n\tdelete obj.foo; // silently doesn't delete the property\n\n\t// ...and in strict mode such attempts will throw TypeErrors.\n\tfunction fail() {\n\t  'use strict';\n\t  delete obj.foo; // throws a TypeError\n\t  obj.sparky = 'arf'; // throws a TypeError\n\t}\n\tfail();\n\n\t// Attempted additions through Object.defineProperty will also throw.\n\tObject.defineProperty(obj, 'ohai', { value: 17 }); // throws a TypeError\n\tObject.defineProperty(obj, 'foo', { value: 'eit' }); // changes existing property value","children":[{"annotation":"static","name":"dummy","text":"","theRestString":"@param  obj The object which should be sealed."},{"annotation":"param","name":"obj","text":"The object which should be sealed.","theRestString":""}],"commentRange":[224839,227180],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"javascript.Any":{"annotation":"class","name":"Any","text":"This is an artificial type that means 'any value is valid here'","commentRange":[227186,227266],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[163706,165238],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.Any"},"javascript.ObjectPrototype":{"annotation":"class","name":"ObjectPrototype","text":"Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype\n\n#Description\nThe Object.prototype property represents the Object prototype object.\n\nAll objects in JavaScript are descended from Object; all objects inherit methods and properties from Object.prototype, although they may be overridden (except an Object with a null prototype, i.e. Object.create(null)). For example, other constructors' prototypes override the constructor property and provide their own toString() methods. Changes to the Object prototype object are propagated to all objects unless the properties and methods subject to those changes are overridden further along the prototype chain.\n\n#Examples\nSince Javascript doesn't exactly have sub-class objects, prototype is a useful workaround to make a “base class” object of certain functions that act as objects. For example:\n\n\tvar Person = function() {\n\t  this.canTalk = true;\n\t  this.greet = function() {\n\t    if (this.canTalk) {\n\t      console.log('Hi, I'm ' + this.name);\n\t    }\n\t  };\n\t};\n\n\tvar Employee = function(name, title) {\n\t  this.name = name;\n\t  this.title = title;\n\t  this.greet = function() {\n\t    if (this.canTalk) {\n\t      console.log(\"Hi, I'm \" + this.name + \", the \" + this.title);\n\t    }\n\t  };\n\t};\n\tEmployee.prototype = new Person();\n\n\tvar Customer = function(name) {\n\t  this.name = name;\n\t};\n\tCustomer.prototype = new Person();\n\n\tvar Mime = function(name) {\n\t  this.name = name;\n\t  this.canTalk = false;\n\t};\n\tMime.prototype = new Person();\n\n\tvar bob = new Employee('Bob', 'Builder');\n\tvar joe = new Customer('Joe');\n\tvar rg = new Employee('Red Green', 'Handyman');\n\tvar mike = new Customer('Mike');\n\tvar mime = new Mime('Mime');\n\tbob.greet();\n\tjoe.greet();\n\trg.greet();\n\tmike.greet();\n\tmime.greet();\n\nThis will output:\n\n\tHi, I'm Bob, the Builder\n\tHi, I'm Joe\n\tHi, I'm Red Green, the Handyman\n\tHi, I'm Mike","commentRange":[227268,229221],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[227268,229221],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.ObjectPrototype","properties":{"constructor":{"annotation":"property","type":"{Function}","name":"constructor","text":"Specifies the function that creates an object's prototype.\n\n##Summary\nReturns a reference to the Object function that created the instance's prototype. Note that the value of this property is a reference to the function itself, not a string containing the function's name. The value is only read-only for primitive values such as 1, true and \"test\".\n\n##Description\n\nAll objects inherit a constructor property from their prototype:\n\n\tvar o = {};\n\to.constructor === Object; // true\n\n\tvar a = [];\n\ta.constructor === Array; // true\n\n\tvar n = new Number(3);\n\tn.constructor === Number; // true\n\n##Examples\n\n###Example: Displaying the constructor of an object\n\nThe following example creates a prototype, Tree, and an object of that type, theTree. The example then displays the constructor property for the object theTree.\n\n\tfunction Tree(name) {\n\t  this.name = name;\n\t}\n\n\tvar theTree = new Tree('Redwood');\n\tconsole.log('theTree.constructor is ' + theTree.constructor);\n\tThis example displays the following output:\n\n\ttheTree.constructor is function Tree(name) {\n\t  this.name = name;\n\t}\n\n###Example: Changing the constructor of an object\n\nThe following example shows how to modify constructor value of generic objects. Only true, 1 and \"test\" will not be affected as they have read-only native constructors. This example shows that it is not always safe to rely on the constructor property of an object.\n\n\tfunction Type () {}\n\n\tvar types = [\n\t  new Array(),\n\t  [],\n\t  new Boolean(),\n\t  true,             // remains unchanged\n\t  new Date(),\n\t  new Error(),\n\t  new Function(),\n\t  function () {},\n\t  Math,\n\t  new Number(),\n\t  1,                // remains unchanged\n\t  new Object(),\n\t  {},\n\t  new RegExp(),\n\t  /(?:)/,\n\t  new String(),\n\t  'test'            // remains unchanged\n\t];\n\tfor (var i = 0; i < types.length; i++) {\n\t  types[i].constructor = Type;\n\t  types[i] = [types[i].constructor, types[i] instanceof Type, types[i].toString()];\n\t}\n\tconsole.log(types.join('\\n'));\n\tThis example displays the following output:\n\n\tfunction Type() {},false,\n\tfunction Type() {},false,\n\tfunction Type() {},false,false\n\tfunction Boolean() {\n\t    [native code]\n\t},false,true\n\tfunction Type() {},false,Mon Sep 01 2014 16:03:49 GMT+0600\n\tfunction Type() {},false,Error\n\tfunction Type() {},false,function anonymous() {\n\n\t}\n\tfunction Type() {},false,function () {}\n\tfunction Type() {},false,[object Math]\n\tfunction Type() {},false,0\n\tfunction Number() {\n\t    [native code]\n\t},false,1\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,[object Object]\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,/(?:)/\n\tfunction Type() {},false,\n\tfunction String() {\n\t    [native code]\n\t},false,тест","commentRange":[229225,231953],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"__noSuchMethod__":{"annotation":"property","type":"{Function}","name":"__noSuchMethod__","text":"Allows a function to be defined that will be executed when an undefined object member is called as a method.","commentRange":[231961,232228],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}},"javascript.String":{"annotation":"class","name":"String","text":"#Summary\nThe String global object is a constructor for strings, or a sequence of characters.\n\n#Syntax\nString literals take the forms:\n\n\t'string text' \"string text\" \"中文 español English हिन्दी العربية português বাংলা русский 日本語 ਪੰਜਾਬੀ 한국어\"\n\nBeside regular, printable characters, special characters can be encoded using escape notation:\n\n\tCode\tOutput\n\t\\0\tthe NUL character\n\t\\'\tsingle quote\n\t\\\"\tdouble quote\n\t\\\\\tbackslash\n\t\\n\tnew line\n\t\\r\tcarriage return\n\t\\v\tvertical tab\n\t\\t\ttab\n\t\\b\tbackspace\n\t\\f\tform feed\n\t\\uXXXX\tunicode codepoint\n\t\\xXX\tthe Latin-1 character\n\nOr, using the String global object directly:\n\n\tString(thing) new String(thing)\n\n#Description\nStrings are useful for holding data that can be represented in text form. Some of the most-used operations on strings are to check their length, to build and concatenate them using the + and += string operators, checking for the existence or location of substrings with the indexOf method, or extracting substrings with the substring method.\n\n##Character access\n\nThere are two ways to access an individual character in a string. The first is the charAt method:\n\n\treturn 'cat'.charAt(1); // returns \"a\"\n\nThe other way (introduced in ECMAScript 5) is to treat the string as an array-like object, where individual characters correspond to a numerical index:\n\n\treturn 'cat'[1]; // returns \"a\"\n\nFor character access using bracket notation, attempting to delete or assign a value to these properties will not succeed. The properties involved are neither writable nor configurable. (See Object.defineProperty for more information.)\n\n##Comparing strings\n\nC developers have the strcmp() function for comparing strings. In JavaScript, you just use the less-than and greater-than operators:\n\n\tvar a = \"a\";\n\tvar b = \"b\";\n\tif (a < b) // true\n\t  print(a + \" is less than \" + b);\n\telse if (a > b)\n\t  print(a + \" is greater than \" + b);\n\telse\n\t  print(a + \" and \" + b + \" are equal.\");\n\nA similar result can be achieved using the localeCompare method inherited by String instances.\n\n##Distinction between string primitives and String objects\n\nNote that JavaScript distinguishes between String objects and primitive string values. (The same is true of Boolean and Numbers.)\n\nString literals (denoted by double or single quotes) and strings returned from String calls in a non-constructor context (i.e., without using the new keyword) are primitive strings. JavaScript automatically converts primitives to String objects, so that it's possible to use String object methods for primitive strings. In contexts where a method is to be invoked on a primitive string or a property lookup occurs, JavaScript will automatically wrap the string primitive and call the method or perform the property lookup.\n\n\tvar s_prim = \"foo\";\n\tvar s_obj = new String(s_prim);\n\n\tconsole.log(typeof s_prim); // Logs \"string\"\n\tconsole.log(typeof s_obj);  // Logs \"object\"\n\tString primitives and String objects also give different results when using eval. Primitives passed to eval are treated as source code; String objects are treated as all other objects are, by returning the object. For example:\n\n\ts1 = \"2 + 2\";               // creates a string primitive\n\ts2 = new String(\"2 + 2\");   // creates a String object\n\tconsole.log(eval(s1));      // returns the number 4\n\tconsole.log(eval(s2));      // returns the string \"2 + 2\"\n\nFor these reasons, code may break when it encounters String objects when it expects a primitive string instead, although generally authors need not worry about the distinction.\n\nA String object can always be converted to its primitive counterpart with the valueOf method.\n\n\tconsole.log(eval(s2.valueOf())); // returns the number 4\n\nNote: For another possible approach to strings in JavaScript, please read the article about StringView – a C-like representation of strings based on typed arrays.\n\n\n#String generic methods\nThe String instance methods are also available in Firefox as of JavaScript 1.6 (though not part of the ECMAScript standard) on the String object for applying String methods to any object:\n\n\tvar num = 15;\n\talert(String.replace(num, /5/, '2'));\n\nGenerics are also available on Array methods.\n\nThe following is a shim to provide support to non-supporting browsers:\n\n\t//globals define\n\t// Assumes all supplied String instance methods already present\n\t// (one may use shims for these if not available)\n\t(function () {\n\t    'use strict';\n\n\t    var i,\n\t        // We could also build the array of methods with the following, but the\n\t        //   getOwnPropertyNames() method is non-shimable:\n\t        // Object.getOwnPropertyNames(String).filter(function (methodName)\n\t        //  {return typeof String[methodName] === 'function'});\n\t        methods = [\n\t            'quote', 'substring', 'toLowerCase', 'toUpperCase', 'charAt',\n\t            'charCodeAt', 'indexOf', 'lastIndexOf', 'startsWith', 'endsWith',\n\t            'trim', 'trimLeft', 'trimRight', 'toLocaleLowerCase',\n\t            'toLocaleUpperCase', 'localeCompare', 'match', 'search',\n\t            'replace', 'split', 'substr', 'concat', 'slice'\n\t        ],\n\t        methodCount = methods.length,\n\t        assignStringGeneric = function (methodName) {\n\t            var method = String.prototype[methodName];\n\t            String[methodName] = function (arg1) {\n\t                return method.apply(arg1, Array.prototype.slice.call(arguments, 1));\n\t            };\n\t        };\n\n\t    for (i = 0; i < methodCount; i++) {\n\t        assignStringGeneric(methods[i]);\n\t    }\n\t}());\n\n#Examples\n##String conversion\n\nIt's possible to use String as a \"safer\" toString alternative, as although it still normally calls the underlying toString, it also works for null and undefined. For example:\n\n\tvar outputStrings = [];\n\tfor (let i = 0, n = inputValues.length; i < n; ++i) {\n\t  outputStrings.push(String(inputValues[i]));\n\t}","commentRange":[232232,238098],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""},"module":{"annotation":"module","name":"javascript","text":"","commentRange":[232232,238098],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"absoluteName":"javascript.String","properties":{"length":{"annotation":"property","type":"{Number}","name":"length","text":"#Summary\nThe length property represents the length of a string.\n\n#Syntax\n\n\tstr.length\n\n#Description\n\nThis property returns the number of code units in the string. UTF-16, the string format used by JavaScript, uses a single 16-bit code unit to represent the most common characters, but needs to use two code units for less commonly-used characters, so it's possible for the value returned by length to not match the actual number of characters in the string.\n\nFor an empty string, length is 0.\n\nThe static property String.length returns the value 1.\n\n#Examples\n\n\tvar x = \"Mozilla\";\n\tvar empty = \"\";\n\n\tconsole.log(\"Mozilla is \" + x.length + \" code units long\");\n\t// \"Mozilla is 7 code units long\" \n\n\tconsole.log(\"The empty string is has a length of \" + empty.length);\n\t // \"The empty string is has a length of 0\"","commentRange":[238105,238950],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}},"methods":{"fromCharCode":{"annotation":"method","name":"fromCharCode","text":"#Summary\nThe static String.fromCharCode() method returns a string created by using the specified sequence of Unicode values.\n\n#Syntax\nString.fromCharCode(num1, ..., numN)\n#Description\nThis method returns a string and not a String object.\n\nBecause fromCharCode is a static method of String, you always use it as String.fromCharCode(), rather than as a method of a String object you created.\n\n#Examples\nExample: Using fromCharCode\n\nThe following example returns the string \"ABC\".\n\n\tString.fromCharCode(65,66,67)\n\n#Getting it to work with higher values\nAlthough most common Unicode values can be represented with one 16-bit number (as expected early on during JavaScript standardization) and fromCharCode() can be used to return a single character for the most common values (i.e., UCS-2 values which are the subset of UTF-16 with the most common characters), in order to deal with ALL legal Unicode values (up to 21 bits), fromCharCode() alone is inadequate. Since the higher code point characters use two (lower value) \"surrogate\" numbers to form a single character, String.fromCodePoint() (part of the ES6 draft) can be used to return such a pair and thus adequately represent these higher valued characters.","children":[{"annotation":"return","type":"{String}","name":"returns","text":"a string created by using the specified sequence of Unicode values.}","theRestString":"@param p1,...pn A sequence of numbers that are Unicode values"},{"annotation":"param","name":"p1","text":",...pn A sequence of numbers that are Unicode values","theRestString":""}],"commentRange":[238955,240351],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"charAt":{"annotation":"method","name":"charAt","text":"#Summary\nThe charAt() method returns the specified character from a string.\n\n#Syntax\n\tstr.charAt(index)\n#Description\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character in a string called stringName is stringName.length - 1. If the index you supply is out of range, JavaScript returns an empty string.\n\n#Examples\n##Example: Displaying characters at different locations in a string\n\nThe following example displays characters at different locations in the string \"Brave new world\":\n\n\tvar anyString = \"Brave new world\";\n\n\tconsole.log(\"The character at index 0   is '\" + anyString.charAt(0)   + \"'\");\n\tconsole.log(\"The character at index 1   is '\" + anyString.charAt(1)   + \"'\");\n\tconsole.log(\"The character at index 2   is '\" + anyString.charAt(2)   + \"'\");\n\tconsole.log(\"The character at index 3   is '\" + anyString.charAt(3)   + \"'\");\n\tconsole.log(\"The character at index 4   is '\" + anyString.charAt(4)   + \"'\");\n\tconsole.log(\"The character at index 999 is '\" + anyString.charAt(999) + \"'\");\n\nThese lines display the following:\n\n\tThe character at index 0 is 'B'\n\tThe character at index 1 is 'r'\n\tThe character at index 2 is 'a'\n\tThe character at index 3 is 'v'\n\tThe character at index 4 is 'e'\n\tThe character at index 999 is ''\n\n##Example: Getting whole characters\n\nThe following provides a means of ensuring that going through a string loop always provides a whole character, even if the string contains characters that are not in the Basic Multi-lingual Plane.\n\n\tvar str = 'A \\uD87E\\uDC04 Z'; // We could also use a non-BMP character directly\n\tfor (var i=0, chr; i < str.length; i++) {\n\t  if ((chr = getWholeChar(str, i)) === false) {\n\t    continue;\n\t  } // Adapt this line at the top of each loop, passing in the whole string and\n\t    // the current iteration and returning a variable to represent the \n\t    // individual character\n\n\t  alert(chr);\n\t}\n\n\tfunction getWholeChar (str, i) {\n\t  var code = str.charCodeAt(i);     \n\t \n\t  if (isNaN(code)) {\n\t    return ''; // Position not found\n\t  }\n\t  if (code < 0xD800 || code > 0xDFFF) {\n\t    return str.charAt(i);\n\t  }\n\n\t  // High surrogate (could change last hex to 0xDB7F to treat high private\n\t  // surrogates as single characters)\n\t  if (0xD800 <= code && code <= 0xDBFF) { \n\t    if (str.length <= (i+1))  {\n\t      throw 'High surrogate without following low surrogate';\n\t    }\n\t    var next = str.charCodeAt(i+1);\n\t      if (0xDC00 > next || next > 0xDFFF) {\n\t        throw 'High surrogate without following low surrogate';\n\t      }\n\t      return str.charAt(i)+str.charAt(i+1);\n\t  }\n\t  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n\t  if (i === 0) {\n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  var prev = str.charCodeAt(i-1);\n\t  \n\t  // (could change last hex to 0xDB7F to treat high private\n\t  // surrogates as single characters)\n\t  if (0xD800 > prev || prev > 0xDBFF) { \n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  // We can pass over low surrogates now as the second component\n\t  // in a pair which we have already processed\n\t  return false; \n\t}\n\nIn an exclusive JavaScript 1.7+ environment (such as Firefox) which allows destructured assignment, the following is a more succinct and somewhat more flexible alternative in that it does incrementing for an incrementing variable automatically (if the character warrants it in being a surrogate pair).\n\n\tvar str = 'A\\uD87E\\uDC04Z'; // We could also use a non-BMP character directly\n\tfor (var i=0, chr; i < str.length; i++) {\n\t  [chr, i] = getWholeCharAndI(str, i);\n\t  // Adapt this line at the top of each loop, passing in the whole string and\n\t  // the current iteration and returning an array with the individual character\n\t  // and 'i' value (only changed if a surrogate pair)\n\n\t  alert(chr);\n\t}\n\n\tfunction getWholeCharAndI (str, i) {\n\t  var code = str.charCodeAt(i);\n\n\t  if (isNaN(code)) {\n\t    return ''; // Position not found\n\t  }\n\t  if (code < 0xD800 || code > 0xDFFF) {\n\t    return [str.charAt(i), i]; // Normal character, keeping 'i' the same\n\t  }\n\n\t  // High surrogate (could change last hex to 0xDB7F to treat high private \n\t  // surrogates as single characters)\n\t  if (0xD800 <= code && code <= 0xDBFF) { \n\t    if (str.length <= (i+1))  {\n\t      throw 'High surrogate without following low surrogate';\n\t    }\n\t    var next = str.charCodeAt(i+1);\n\t      if (0xDC00 > next || next > 0xDFFF) {\n\t        throw 'High surrogate without following low surrogate';\n\t      }\n\t      return [str.charAt(i)+str.charAt(i+1), i+1];\n\t  }\n\t  // Low surrogate (0xDC00 <= code && code <= 0xDFFF)\n\t  if (i === 0) {\n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  var prev = str.charCodeAt(i-1);\n\n\t  // (could change last hex to 0xDB7F to treat high private surrogates\n\t  // as single characters)\n\t  if (0xD800 > prev || prev > 0xDBFF) { \n\t    throw 'Low surrogate without preceding high surrogate';\n\t  }\n\t  // Return the next character instead (and increment)\n\t  return [str.charAt(i+1), i+1]; \n\t}\n\n\n##Example: Fixing charAt to support non-Basic-Multilingual-Plane (BMP) characters\n\nWhile the example above may be more frequently useful for those wishing to support non-BMP characters (since it does not require the caller to know where any non-BMP character might appear), in the event that one does wish, in choosing a character by index, to treat the surrogate pairs within a string as the single characters they represent, one can use the following:\n\n\tfunction fixedCharAt (str, idx) {\n\t  var ret = '';\n\t  str += '';\n\t  var end = str.length;\n\n\t  var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t  while ((surrogatePairs.exec(str)) != null) {\n\t    var li = surrogatePairs.lastIndex;\n\t    if (li - 2 < idx) {\n\t      idx++;\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\n\t  if (idx >= end || idx < 0) {\n\t    return '';\n\t  }\n\n\t  ret += str.charAt(idx);\n\n\t  if (/[\\uD800-\\uDBFF]/.test(ret) && /[\\uDC00-\\uDFFF]/.test(str.charAt(idx+1))) {\n\t    // Go one further, since one of the \"characters\" is part of a surrogate pair\n\t    ret += str.charAt(idx+1); \n\t  }\n\t  return ret;\n\t}","children":[{"annotation":"param","type":"{Number}","name":"index","text":"An integer between 0 and 1-less-than the length of the string.","theRestString":"@return {String} the specified character from a string."},{"annotation":"return","type":"{String}","name":"the","text":"specified character from a string.","theRestString":""}],"commentRange":[240359,246651],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"charCodeAt":{"annotation":"method","name":"charCodeAt","text":"#Summary\nThe charCodeAt() method returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000).\n\n#Syntax\n\tstr.charCodeAt(index)\n#Description\nUnicode code points range from 0 to 1,114,111. The first 128 Unicode code points are a direct match of the ASCII character encoding. For information on Unicode, see the JavaScript Guide.\n\nNote that charCodeAt will always return a value that is less than 65,536. This is because the higher code points are represented by a pair of (lower valued) \"surrogate\" pseudo-characters which are used to comprise the real character. Because of this, in order to examine or reproduce the full character for individual characters of value 65,536 and above, for such characters, it is necessary to retrieve not only charCodeAt(i), but also charCodeAt(i+1) (as if examining/reproducing a string with two letters). See example 2 and 3 below.\n\ncharCodeAt returns NaN if the given index is not greater than 0 or is greater than the length of the string.\n\nBackward compatibilty: In historic versions (like JavaScript 1.2) the charCodeAt method returns a number indicating the ISO-Latin-1 codeset value of the character at the given index. The ISO-Latin-1 codeset ranges from 0 to 255. The first 0 to 127 are a direct match of the ASCII character set.\n\n#Examples\n##Example: Using charCodeAt\n\nThe following example returns 65, the Unicode value for A.\n\n\t\"ABC\".charCodeAt(0) // returns 65\n\n#Example: Fixing charCodeAt to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is unknown\n\nThis version might be used in for loops and the like when it is unknown whether non-BMP characters exist before the specified index position.\n\n\tfunction fixedCharCodeAt (str, idx) {\n\t    // ex. fixedCharCodeAt ('\\uD800\\uDC00', 0); // 65536\n\t    // ex. fixedCharCodeAt ('\\uD800\\uDC00', 1); // false\n\t    idx = idx || 0;\n\t    var code = str.charCodeAt(idx);\n\t    var hi, low;\n\t    \n\t    // High surrogate (could change last hex to 0xDB7F to treat high\n\t    // private surrogates as single characters)\n\t    if (0xD800 <= code && code <= 0xDBFF) {\n\t        hi = code;\n\t        low = str.charCodeAt(idx+1);\n\t        if (isNaN(low)) {\n\t            throw 'High surrogate not followed by low surrogate in fixedCharCodeAt()';\n\t        }\n\t        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    if (0xDC00 <= code && code <= 0xDFFF) { // Low surrogate\n\t        // We return false to allow loops to skip this iteration since should have\n\t        // already handled high surrogate above in the previous iteration\n\t        return false;\n\t        //hi = str.charCodeAt(idx-1);\n\t        //low = code;\n\t        //return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    return code;\n\t}\n\n##Example: Fixing charCodeAt to handle non-Basic-Multilingual-Plane characters if their presence earlier in the string is known\n\n\tfunction knownCharCodeAt (str, idx) {\n\t    str += '';\n\t    var code,\n\t        end = str.length;\n\n\t    var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t    while ((surrogatePairs.exec(str)) != null) {\n\t        var li = surrogatePairs.lastIndex;\n\t        if (li - 2 < idx) {\n\t            idx++;\n\t        }\n\t        else {\n\t            break;\n\t        }\n\t    }\n\n\t    if (idx >= end || idx < 0) {\n\t        return NaN;\n\t    }\n\n\t    code = str.charCodeAt(idx);\n\n\t    var hi, low;\n\t    if (0xD800 <= code && code <= 0xDBFF) {\n\t        hi = code;\n\t        low = str.charCodeAt(idx+1);\n\t        // Go one further, since one of the \"characters\" is part of a surrogate pair\n\t        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;\n\t    }\n\t    return code;\n\t}","children":[{"annotation":"param","type":"{Number}","name":"index","text":"An integer greater than or equal to 0 and less than the length of the string; if it is not a number, it defaults to 0.","theRestString":"@returns {Number}returns the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000)."},{"annotation":"returns","type":"{Number}","name":"returns","text":"the numeric Unicode value of the character at the given index (except for unicode codepoints > 0x10000).","theRestString":""}],"commentRange":[246656,250650],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"concat":{"annotation":"method","name":"concat","text":"#Summary\nThe concat() method combines the text of two or more strings and returns a new string.\n\n#Syntax\n\tstr.concat(string2, string3[, ..., stringN])\n\n#Description\nThe concat function combines the text from one or more strings and returns a new string. Changes to the text in one string do not affect the other string.\n\n#Examples\n##Example: Using concat\n\nThe following example combines strings into a new string.\n\n\tvar hello = \"Hello, \";\n\tconsole.log(hello.concat(\"Kevin\", \" have a nice day.\")); \n\n\t// Hello, Kevin have a nice day. \n\n#Performance\nIt is strongly recommended that assignment operators (+, +=) are used instead of the concat method. See this perfomance test.","children":[{"annotation":"param","name":"string2...stringN","text":"Strings to concatenate to this string.","theRestString":"@return {String}"},{"annotation":"return","type":"{String}","text":"","theRestString":""}],"commentRange":[250656,251435],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"indexOf":{"annotation":"method","name":"indexOf","text":"#Summary\nThe indexOf() method returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.\n\n#Syntax\n\tstr.indexOf(searchValue[, fromIndex])\n#Description\nCharacters in a string are indexed from left to right. The index of the first character is 0, and the index of the last character of a string called stringName is stringName.length - 1.\n\n\t\"Blue Whale\".indexOf(\"Blue\");     // returns  0\n\t\"Blue Whale\".indexOf(\"Blute\");    // returns -1\n\t\"Blue Whale\".indexOf(\"Whale\", 0); // returns  5\n\t\"Blue Whale\".indexOf(\"Whale\", 5); // returns  5\n\t\"Blue Whale\".indexOf(\"\", 9);      // returns  9\n\t\"Blue Whale\".indexOf(\"\", 10);     // returns 10\n\t\"Blue Whale\".indexOf(\"\", 11);     // returns 10\n\n##Case-sensitivity\n\nThe indexOf method is case sensitive. For example, the following expression returns -1:\n\n\"Blue Whale\".indexOf(\"blue\") // returns -1\n##Checking occurrences\n\nNote that '0' doesn't evaluate to true and '-1' doesn't evaluate to false. Therefore, when checking if a specific string exists within another string the correct way to check would be:\n\n\"Blue Whale\".indexOf(\"Blue\") != -1; // true\n\"Blue Whale\".indexOf(\"Bloe\") != -1; // false\n\n#Examples\n##Example: Using indexOf and lastIndexOf\n\nThe following example uses indexOf and lastIndexOf to locate values in the string \"Brave new world\".\n\n\tvar anyString = \"Brave new world\";\n\n\tconsole.log(\"The index of the first w from the beginning is \" + anyString.indexOf(\"w\"));\n\t// Displays 8\n\tconsole.log(\"The index of the first w from the end is \" + anyString.lastIndexOf(\"w\")); \n\t// Displays 10\n\n\tconsole.log(\"The index of 'new' from the beginning is \" + anyString.indexOf(\"new\"));   \n\t// Displays 6\n\tconsole.log(\"The index of 'new' from the end is \" + anyString.lastIndexOf(\"new\"));\n\t// Displays 6\n##Example: indexOf and case-sensitivity\n\nThe following example defines two string variables. The variables contain the same string except that the second string contains uppercase letters. The first log method displays 19. But because the indexOf method is case sensitive, the string \"cheddar\" is not found in myCapString, so the second log method displays -1.\n\n\tvar myString    = \"brie, pepper jack, cheddar\";\n\tvar myCapString = \"Brie, Pepper Jack, Cheddar\";\n\n\tconsole.log('myString.indexOf(\"cheddar\") is ' + myString.indexOf(\"cheddar\"));    \n\t// Displays 19\n\tconsole.log('myCapString.indexOf(\"cheddar\") is ' + myCapString.indexOf(\"cheddar\")); \n\t// Displays -1\n##Example: Using indexOf to count occurrences of a letter in a string\n\nThe following example sets count to the number of occurrences of the letter x in the string str:\n\n\tcount = 0;\n\tpos = str.indexOf(\"x\");\n\n\twhile ( pos != -1 ) {\n\t   count++;\n\t   pos = str.indexOf( \"x\",pos + 1 );\n\t}","children":[{"annotation":"param","type":"{String}","name":"searchValue","text":"A string representing the value to search for.","theRestString":"@param {Number} fromIndex The location within the calling string to start the search from. It can be any integer. The default value is 0. If fromIndex < 0 the entire string is searched (same as passing 0). If fromIndex >= str.length, the method will return -1 unless searchValue is an empty string in which case str.length is returned. \n@optional dummy @returns {Number} the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found."},{"annotation":"param","type":"{Number}","name":"fromIndex","text":"The location within the calling string to start the search from. It can be any integer. The default value is 0. If fromIndex < 0 the entire string is searched (same as passing 0). If fromIndex >= str.length, the method will return -1 unless searchValue is an empty string in which case str.length is returned.","theRestString":"@optional dummy @returns {Number} the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found."},{"annotation":"optional","name":"dummy","text":"","theRestString":"@returns {Number} the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found."},{"annotation":"returns","type":"{Number}","name":"the","text":"index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.","theRestString":""}],"commentRange":[251440,254863],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}}}},"modules":{"ideal":{"annotation":"module","name":"ideal","text":"","commentRange":[2,73],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"ideasAndProblems67":{"annotation":"module","name":"ideasAndProblems67","text":"","commentRange":[1816,2457],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"pretty.names_9":{"annotation":"module","name":"pretty.names_9","text":"lorem ipsum liprim trogus","commentRange":[2459,2736],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"life":{"annotation":"module","name":"life","text":"","commentRange":[2738,2983],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"problem1":{"annotation":"module","name":"problem1","text":"This is a description of planet earth city from the point of view of an alien observing us from a space ship.","commentRange":[3375,3729],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"}},"shortjsdoc":{"annotation":"module","name":"shortjsdoc","text":"\n\nthis is the main class for all the application utilities for rendering jsdoc data generated by jsdocgenerator1 js-indentator plugin using backbone. The user should provide with underscore templates.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nthis file add methods to Abstract Application for dealing with types and html markup.","commentRange":[103140,103223],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}},"javascript":{"annotation":"module","name":"javascript","text":"","commentRange":[124295,127963],"file":{"annotation":"filename","name":"annotations","text":"","commentRange":[61747,61825],"file":{"annotation":"filename","type":"{Foo}","name":"fileName","text":"ALL.js","commentRange":[2,73],"file":null,"fileName":"ALL.js"},"fileName":""}}},"filenames":{},"projectMetadata":{"name":"my-personal-project","version":"0.1.1","description":"This porject contains some javascript source files that uses short-jsdoc for documenting all known supported cases and combinations. ","author":"Sebastián Gurin","license":"ISC","bugs":{"url":"https://github.com/cancerberoSgx/short-jsdoc/issues"},"homepage":"https://github.com/cancerberoSgx/short-jsdoc"}}
